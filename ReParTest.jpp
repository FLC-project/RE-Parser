/*
 * @(#)ReParTest.jpp       1.0 2023/03/01
 *
 * Copyright (c) 2023 Angelo Borsotti. All Rights Reserved.
 * This computer program is protected under Copyright.
 */

package pbsp;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.*;
import java.time.LocalTime;
import java.time.Duration;
import java.time.Instant;
import lbj.*;
import lbj.HashBag.*;
import pbsp.ReParallel.*;

/**
 * The <code>ReParTest</code> class provides the testing of the <code>RePar</code> class.
 *
 * @author  Angelo Borsotti
 * @version 1.0   1 March 2023
 */

/* The program can be called passing options on the command line to get different
 * measures:
 *
 *    bench:      measure the gain for increasing lengths and processors
 *    m-compare:  compare the times between the sequential parser, the parallel with 1 processor
 *                and the parallel with 2 processors
 *    m-dag:      print the measures of dag
 *    m-phases:   print the speed and relative duration of the phases
 *    m-chunks:   print the size of chunks and nr of start states
 *    m-oper:     print the number of operations of each step
 *    m-para:     print the diagram of the times of the reachers and builders
 *    m-decay:    print the measures of the parses of the reachers
 *    fa:         print the size of the fa's
 *    seq:        print the measurements of the sequential parser
 *    par:        print the measurements of the parallel parser with 1 thread and threads for all cores
 *    rec:        print the measurements of the parallel recognizer with 1 thread and threads for all cores
 *    data:       print the lengths of texts, the size of the REs, etc.
 *    meDfaVsDfa: measure the performance of the ME-FA
 */

//# Whether builders use the reverse dfa
#define BUILDER_REVDFA;

//# Whether parallel execution is simulated
//#define SIMULATE;

//# Whether debugging trace is enabled
//#define DEBUG;

//# Whether measures are done on a cpu with many cores
#define MANY_CORES;

//# Whether no parsings and recognizions done in the bench case
//#define DRY_RUN;

//# Whether the absolute times and serial parser and recognizion is also done
#define ABS_TIME;

public class ReParTest {

    /** The step of the number of threads to make parses for increasing threads. */
    private static int CORE_STEP = 8;

    /** The number of step of threads. */
    #ifdef MANY_CORES
    private static int CORE_STEPS = 9;
    #else
    private static int CORE_STEPS = 1;
    #endif

    /** The maximum number of threads measured. */
    #ifdef MANY_CORES
    private static int CORE_MAX = CORE_STEP * CORE_STEPS;
    #else
    private static int CORE_MAX = 3;
    #endif

    /** The number of threads for the table of numbers of transitions. */
    #ifdef MANY_CORES
    private static int CORE_NTRANS = 34;
    #else
    private static int CORE_NTRANS = 2;
    #endif

    /** The number of RE buckets used out of regen. */
    #ifdef MANY_CORES
    private static int REGEN_RE_BUCKETS = 6;
    #else
    private static int REGEN_RE_BUCKETS = 2;
    #endif

    /** The number of REs used for each bucket. */
    #ifdef MANY_CORES
    private static int REGEN_RES = 10;
    #else
    private static int REGEN_RES = 3;
    #endif

    /** The number of text buckets used out of regen. */
    #ifdef MANY_CORES
    private static int REGEN_TEXT_BUCKETS = 6;
    #else
    private static int REGEN_TEXT_BUCKETS = 2;
    #endif

    /** The number of hundreds of times the regen texts are repeated to get the actual texts. */
    private static int regenTextRep = 3;

    /** The number of times a same measure is repeated to get more stable results. */
    #ifdef MANY_CORES
    private static int REP_MEA = 3;
    #else
    private static int REP_MEA = 1;
    #endif


    /** The name of the feature under testing. */
    private static String featureName;

    /** The flag to enable the trace of the tests. */
    private static boolean ckshow = false;

    /** The number of tests failed. */
    private static int testErrors;

    /** The number of the test. */
    static int testId;

    /**
     * Start the testing of a feature. Record its name and trace it
     * if the tracing of tests is enabled.
     *
     * @param      s feature name
     */

    private static void feature(String s){
        featureName = s;
        if (ckshow) Trc.out.printf("%s\n",featureName);
    }

    /**
     * Trace a test of a feature.
     *
     * @param      t number of the test
     */

    private static void showTest(int t){
        testId = t;
        if (ckshow) Trc.out.printf("-- test %s %s ---\n",featureName,t);
    }

    /**
     * Report the failure of a test.
     *
     * @param      t number of the test
     */

    private static void trcfail(int t){
        Trc.out.printf("\n");
        Trc.out.printf("-- test %s %s failed---\n",featureName,t);
        testErrors++;
    }

    /**
     * Deliver the specified string with spaces removed.
     *
     * @param      str string
     * @return     string
     */

    private static String removeSpaces(String str){
        String s = "";
        for (int i = 0; i < str.length(); i++){
            if (str.charAt(i) == ' ') continue;
            s += str.charAt(i);
        }
        return s;
    }

    /**
     * Trace the specified message followed by the expected value and the actual one.
     *
     * @param      str message
     * @param      e expected value
     * @param      a actual value
     * @return     string
     */

    private static void trc(String s, String e, String a){
        Trc.out.printf("%s expected: |%s| actual: |%s|\n",s,e,a);
    }
    private static void trc(String s, boolean e, boolean a){
        Trc.out.printf("%s expected: |%s| actual: |%s|\n",s,e,a);
    }
    private static void trc(String s, int e, int a){
        Trc.out.printf("%s expected: |%s| actual: |%s|\n",s,e,a);
    }

    /**
     * Deliver an IntSetBit set with the elements present in the specified array.
     *
     * @param      arr array
     * @param      re reference to the RE
     * @return     set
     */

    private static IntSetBit arrToIntSetBit(int[] arr, ReParallel re){
        int max = 0;
        for (int i = 0; i < arr.length; i++){
            if (arr[i] > max) max = arr[i];
        }
        re.nfa.stateNr = max + 10;     // enlarge set
        IntSetBit res = re.new IntSetBit();
        for (int i = 0; i < arr.length; i++){
            res.add(arr[i]);
        }
        return res;
    }

    /**
     * Test the representation of the specified set as a string.
     *
     * @param      t test number
     * @param      isb set
     * @param      exp string expected
     */

    private static void testIntSet(int t, IntSetBit isb, String exp){
        showTest(t);
        String act = isb.toString();
        if (!exp.equals(act)){
            trcfail(t);
            trc("set",exp,act);
        }
    }

    /**
     * Test the creation of a set with the specified elements.
     *
     * @param      t test number
     * @param      arr elements
     * @param      re reference to the RE
     * @param      exp expected string representation of the created set
     */

    private static void testNew(int t, int[] arr, ReParallel re, String exp){
        IntSetBit isb = arrToIntSetBit(arr,re);
        testIntSet(t,isb,exp);
    }

    /**
     * Execute the tests of the IntSetBit.
     */

    private static void testIntSetBit(){
        ReParallel re = new ReParallel();
        re.nfa = re.new Nfa();
        re.nfa.stateNr = 10;
        feature("IntSetBit");
        testNew(1,new int[]{},re,"{}");
        testNew(2,new int[]{0},re,"{0}");
        testNew(3,new int[]{0,1,2},re,"{0 1 2}");
        testNew(4,new int[]{10,21,32},re,"{10 21 32}");
        IntSetBit isb = re.new IntSetBit(10);
        testIntSet(5,isb,"{10}");
        IntSetBit isb1 = re.new IntSetBit(20);
        testIntSet(6,isb,"{10}");
        isb1 = re.new IntSetBit(20);
        isb.assign(isb);
        testIntSet(7,isb,"{10}");
        isb1 = re.new IntSetBit(20);
        isb.add(isb1);
        testIntSet(8,isb,"{10 20}");
        isb.clear();
        testIntSet(10,isb,"{}");
        if (!isb.isEmpty()){
            trcfail(11);
        }
        isb.add(isb1);
        if (isb.isEmpty()){
            trcfail(12);
        }
        isb.clear();
        isb.add(3);
        isb.add(4);
        isb.add(5);
        isb.add(6);
        isb.add(7);
        isb.add(8);
        if (isb.intersects(isb1)){
            trcfail(13);
        }
        isb1.add(4);
        if (!isb.intersects(isb1)){
            trcfail(14);
        }
        re.nfa.stateNr = 150;
        isb = re.new IntSetBit(10);
        isb.add(100);
        testIntSet(15,isb,"{10 100}");

    }

    /**
     * Test the adding of an element to the specified dag hash table.
     *
     * @param      t test number
     * @param      htb hash table
     * @param      arr element to add
     * @param      expected element index
     */

    private static void testHtbAdd(int t, DagBuilder htb, long[] arr, int exp){
        showTest(t);
        int actual = htb.addUnique(arr,arr.length);
        if (actual != exp){
            trcfail(t);
            trc("el",""+exp,""+actual);
        }
    }

    #ifdef BUILDER_REVDFA
    #else
    /**
     * Test the adding of a unique element to the specified dag hash table.
     *
     * @param      t test number
     * @param      htb hash table
     * @param      arr element to add
     * @param      expected element index
     */

    private static void testHstateAddu(int t, Hstate hstate, long[] key, long[] val, int exp){
        showTest(t);
        int actual = hstate.search(key);
        if (actual == 0){
            actual = hstate.add(key,val);
        }
        if (actual != exp){
            trcfail(t);
            trc("el",""+exp,""+actual);
        }
    }

    /**
     * Test the adding of an element to the specified hash table.
     *
     * @param      t test number
     * @param      hstate hash table
     * @param      key key of the element to add
     * @param      val value of the element to add
     * @param      expected element index
     */

    private static void testHstateAdd(int t, Hstate hstate, long[] key, long[] val, int exp){
        showTest(t);
        int actual = hstate.add(key,val);
        if (actual != exp){
            trcfail(t);
            trc("el",""+exp,""+actual);
        }
    }

    /**
     * Test the searching of an element in the specified hash table.
     *
     * @param      t test number
     * @param      hstate hash table
     * @param      key key of the element to add
     * @param      expected element index
     */

    private static void testHstateSearch(int t, Hstate hstate, long[] key, int exp){
        showTest(t);
        int actual = hstate.search(key);
        if (actual != exp){
            trcfail(t);
            trc("el",""+exp,""+actual);
        }
    }
    #endif

    /**
     * Test the hash tables.
     */

    private static void testHtb(){
        feature("htb");
        ReParallel re = new ReParallel();
        DagBuilder htb = re.new DagBuilder(8,"m");
        testHtbAdd(0,htb,new long[]{0,1,2},1);
        testHtbAdd(1,htb,new long[]{0,1,2},1);
        testHtbAdd(3,htb,new long[]{0,1,2,4},6);
        for (int i = 0; i < 20; i++){
            long[] el = new long[3];
            el[0] = i+1;
            el[1] = i+2;
            el[2] = i+3;
            testHtbAdd(4+i,htb,el,12+i*(el.length+2));
        }

        #ifdef BUILDER_REVDFA
        #else
        feature("hstate");
        Hstate hstate = re.new Hstate(3,3);
        testHstateAddu(0,hstate,new long[]{0,1,2},new long[]{3,4,5},5);
        testHstateAddu(1,hstate,new long[]{0,1,2},new long[]{3,4,5},5);
        testHstateAddu(2,hstate,new long[]{3,4,5},new long[]{3,4,5},12);
        testHstateSearch(3,hstate,new long[]{3,4,5},12);
        testHstateSearch(4,hstate,new long[]{3,4,6},0);
        testHstateAdd(5,hstate,new long[]{3,4,6},new long[]{3,4,7},19);
        #endif
    }

    /**
     * Test that the specified sequence of parentheses is allowed.
     *
     * @param      t test number
     * @param      rex RE
     * @param      str parentheses
     * @param      er expected result
     */

    private static void testAllowed(int t, String rex, String str, boolean er){
        showTest(t);
        if (!re.compile(rex)){
            trcfail(t);
            return;
        }
        int[] arr = new int[str.length()];
        int n = 0;
        for (int i = 0; i < str.length(); i+=2){
            int ch = str.charAt(i);
            if (ch == '('){
                int nr = str.charAt(i+1) - '0';
                arr[n++] = nr + (ReParallel.ELEOPEN << ReParallel.ELEKINDSHIFT);
            } else {
                int nr = str.charAt(i+1) - '0';
                arr[n++] = nr + (ReParallel.ELECLOSE << ReParallel.ELEKINDSHIFT);
            }
        }
        BSsymbol sym = re.new BSsymbol();
        sym.arr = Arrays.copyOf(arr,n);
        boolean act = re.isAllowedSeq(sym);
        if (act != er){
            trcfail(t);
            trc("res",er,act);
        }
    }

    /**
     * Test that the AST built from the specified RE generates the same RE.
     *
     * @param      t number of the test case
     * @param      str RE
     * @param      exp expected generated RE ("error" if erroneous)
     */

    private static void testAst(int t, String str, String exp){
        showTest(t);
        String actual = "";
        if (!re.compile(str)){
            actual = "error";
        } else {
            actual = re.astRoot.toRE();
        }
        if (!removeSpaces(actual).equals(removeSpaces(exp))){
            trcfail(t);
            trc("re",exp,actual);
        }
        if (exp.equals("error")) return;
    }
    
    /**
     * Test that the NFA built from the specified RE generates the expected NFA.
     *
     * @param      t number of the test case
     * @param      str RE
     * @param      exp expected generated NFA
     */

    private static void testNFA(int t, String str, String exp){
        showTest(t);
        if (!re.compile(str)){
            trcfail(t);
        }
        String actual = re.nfa.toString();
        if (!actual.equals(exp)){
            trcfail(t);
            trc("nfa",exp,actual);
        }
    }

    /**
     * Test that the tree built from the specified RE generates the expected tree.
     *
     * @param      t number of the test case
     * @param      str RE
     * @param      text text
     * @param      exp expected tree
     */

    private static void testTree(int t, String str, String text, String exp){
        showTest(t);
        if (meDfaVsDfa){
            if (!re.compile(str,ReParallel.MIN_ME_DFA)){
                System.out.printf("RePar ri-dfa compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+2000);
            }
            if (!re.compile(str,ReParallel.DFA)){
                System.out.printf("RePar dfa compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+3000);
            }
            if (!re.compile(str,ReParallel.DFA_TR)){
                System.out.printf("RePar dfa-tr compile error\n");
            }

            if (!re.compile(str,ReParallel.NFA)){
                System.out.printf("RePar nfa compile error\n");
            }
            if (re.recParNfa(text,0) != !exp.equals("nomatch")){
                trcfail(t+4000);
            }

            if (!re.compile(str,ReParallel.DFA_F)){
                System.out.printf("RePar dfa-f compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+5000);
            }
            if (!re.compile(str,ReParallel.DFA_B)){
                System.out.printf("RePar dfa-b compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+6000);
            }
            if (!re.compile(str,ReParallel.DFA_FB)){
                System.out.printf("RePar dfa-fb compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+7000);
            }
            if (!re.compile(str,ReParallel.NME_DFA)){
                System.out.printf("RePar dfa-fb compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+8000);
            }
            if (!re.compile(str,ReParallel.NME_DFA_B)){
                System.out.printf("RePar dfa-fb compile error\n");
            }
            if (re.recPar(text,1) != !exp.equals("nomatch")){
                trcfail(t+9000);
            }

            /*
            if (!re.compile(str,ReParallel.SFA)){
                System.out.printf("RePar cd-dfa compile error\n");
            }
            if (re.recParSfa(text,0) != !exp.equals("nomatch")){
                trcfail(t+5000);
            }
            */
            return;
        }
        if (!re.compile(str)){
            System.out.printf("RePar compile error\n");
        }

        if (!re.matchSeq(text)){
            if (!exp.equals("nomatch")){
                trcfail(t);
                return;
            }
        } else {
            if (exp.length() > 0 && !exp.startsWith("%")){
                String actual = re.dagToString();
                if (!actual.equals(exp)){
                    trcfail(t+1000);
                    trc("dag",exp,actual);
                }
            }
            re.checkDag(re.dagHtb);
        }
        if (meDfaVsDfa) return;
        Object htb1 = re.dagHtb;
        if (!re.matchPar(text,1)){
            if (!exp.equals("nomatch")){
                trcfail(t+2000);
            }
        } else {
            re.checkDag(re.dagHtb);
        }
        Object htb2 = re.dagHtb;
        if (!exp.equals("nomatch")){
            if (!re.compareDag(htb1,htb2)){
                trcfail(t+3000);
            }
        }
    }

    /**
     * Test the specified matches are delivered.
     *
     * @param      t number of the test case
     * @param      str RE
     * @param      text text
     * @param      gr group
     * @param      m match
     * @param      exp expected matches
     */

    private static void testGet(int t, String str, String text, int gr,
        Match m, String exp){
        showTest(t);
        if (!re.compile(str)){
            System.out.printf("compile error\n");
        }
        if (!re.matchSeq(text)){
            if (!exp.equals("nomatch")){
                trcfail(t);
            }
        } else {
            List<Match> mat = re.getMatches(m,gr);
            String actual = "null";
            if (mat != null) actual = mat.toString();
                if (!actual.equals(exp)){
                trcfail(t);
                trc("matches",exp,actual);
            }
            matches = mat;
        }
    }

    /**
     * Test the specified list of children is delivered.
     *
     * @param      t number of the test case
     * @param      str RE
     * @param      text text
     * @param      m match
     * @param      exp expected list
     */

    private static void testChildren(int t, String str, String text,
        Match m, String exp){
        showTest(t);
        if (!re.compile(str)){
            System.out.printf("compile error\n");
        }
        if (!re.matchSeq(text)){
            if (!exp.equals("nomatch")){
                trcfail(t);
            }
        } else {
            List<Match> mat = re.getChildren(m);
            String actual = "null";
            if (mat != null) actual = mat.toString();
                if (!actual.equals(exp)){
                trcfail(t);
                trc("matches",exp,actual);
            }
            matches = mat;
        }
    }

    /** The matches. */
    private static List<Match> matches;
    
    /** The RE. */
    private static ReParallel re;

    /**
     * Run all tests.
     */

    private static void test(){
        re = new ReParallel();
        re.testing = true;
        // ckshow = true;
        if (!re.extra_nullablebody){
            feature("allowed sequences");
            testAllowed(0,"","",true);
            testAllowed(1,"a","(0",true);
            testAllowed(2,"(a)","(0",true);
            testAllowed(3,"(a)*","(0)0",true);
            testAllowed(4,"(a)*","(0)0",true);
            testAllowed(5,"(a)*","(0)0(0)0",false);
            testAllowed(6,"a*b*","(1)1(3)3",true);
            testAllowed(7,"(a|)*","(1)1(1(2",false);
            testAllowed(8,"(a|)*","(1)1(1(3)3)1",false);
            testAllowed(9,"(a|)*","(1(3)3(3)3)1",false);
            testAllowed(10,"(a|b*)*","(0(1(3)3)1(1(3",false);
            testAllowed(11,"(a*|b*)*","(0(1(2(3)3)2)1(1(4(5)5)4)1)0",false);
            testAllowed(12,"(a|b*)*",")2)1(1(3)3)1(1(3)3",false);
            testAllowed(13,"a((b)*)*c",")4)3(3)3)2(5",false);
            testAllowed(14,"(ab|(a)*)*",")4)2)1(1",true);
        }
        
        // ast
        feature("ast");
        testAst(1,"","\u03b5");
        testAst(2,"a","a");
        testAst(3,"a b","ab");
        testAst(4,"a b c","abc");
        testAst(5,"a|b","a|b");
        testAst(6,"a|b|c","a|b|c");
        testAst(7,"(a)","(a)");
        testAst(8,"(a)*","(a)*");
        testAst(9,"(a)+","(a)+");
        testAst(10,"(a b)","(ab)");
        testAst(11,"(a|b)","(a|b)");
        testAst(12,"(a (b))","(a(b))");
        testAst(13,"(a)?","(a)?");
        testAst(14,"((a))","((a))");
        testAst(15,"a (b) c","a(b)c");
        testAst(16,"a (b*) c","a((b)*)c");
        testAst(17,"ab|c","ab|c");
        testAst(18,"a*","(a)*");
        testAst(19,"a+","(a)+");
        testAst(20,"a?","(a)?");
        testAst(21,"a{2}","(a){2}");
        testAst(22,"a{2,}","(a){2,}");
        testAst(23,"a{2,4}","(a){2,4}");
        testAst(24,"(a){2}","(a){2}");
        testAst(25,"(a){2,}","(a){2,}");
        testAst(26,"(a){2,4}","(a){2,4}");
        testAst(27,"a*(b|\u03b5)","(a)*(b|\u03b5)");
        testAst(28,"a{0,}","(a)*");
        testAst(29,"a{1,}","(a)+");
        testAst(30,".",".");
        testAst(31,"[ab]","[ab]");
        testAst(32,"[abd]","[abd]");
        testAst(33,"[a-d]","[a-d]");
        testAst(34,"[^a-dg-p]","[^a-dg-p]");
        testAst(35,"(a){,4}","(a){,4}");
        testAst(36,"\\^","\\^");
        testAst(37,"[\\.]","[\\.]");
        testAst(38,"[\\[-\\]]","[\\[-\\]]");
        testAst(39,"[A-Z\n]","[\\nA-Z]");
        testAst(40,"\\ ","\\ ");
        testAst(41,"[a-e][d-g]","[a-e][d-g]");

        testAst(100,"()","(\u03b5)");
        testAst(101,"|","\u03b5|\u03b5");
        testAst(102,"a|","a|\u03b5");
        testAst(103,"()*","(\u03b5)*");
        testAst(104,"()?","(\u03b5)?");

        testAst(200,"(","error");
        testAst(201,"(a","error");
        testAst(202,"a{0}","error");
        testAst(203,"a{3,2}","error");
        testAst(204,"[","error");
        testAst(205,"[a","error");
        testAst(206,"[^","error");
        testAst(207,"[a-","error");
        testAst(208,"[a-b","error");
        testAst(209,"a|*","error");

        feature("NFA");
        testNFA(1,"","0:^->1; 1f:");
        testNFA(2,"a","0:^->2; 2:a->1; 1f:");
        testNFA(3,"ab","0:^->2; 2:a->3; 3:b->1; 1f:");
        testNFA(4,"a|b","0:^->3,^->4; 3:a->1; 4:b->2; 1f:; 2f:");
        testNFA(5,"a|b|c","0:^->4,^->5,^->6; 4:a->1; 5:b->2; 6:c->3; 1f:; 2f:; 3f:");
        testNFA(6,"a*","0:^->2,^->3; 2:a->1,a->4; 3f:; 1f:; 4:a->1,a->4");
        testNFA(7,"a+","0:^->2; 2:a->1,a->3; 1f:; 3:a->1,a->3");
        testNFA(8,"a?","0:^->2,^->3; 2:a->1; 3f:; 1f:");
        testNFA(9,"a{2}","0:^->1; 1:a->3; 3:a->2; 2f:");
        testNFA(10,"a{2,}","0:^->1; 1:a->3; 3:a->2,a->4; 2f:; 4:a->2,a->4");
        testNFA(11,"a{2,4}","0:^->1; 1:a->5; 5:a->2,a->6; 2f:; 6:a->3,a->7; 3f:; 7:a->4; 4f:");
        testNFA(12,"a{0,2}","0:^->1; 1:a->2,a->4; 2f:; 4:a->3; 3f:");
        testNFA(13,".","0:^->2; 2:.->1; 1f:");
        testNFA(14,"[ab]","0:^->2; 2:[ab]->1; 1f:");
        testNFA(15,"[abd]","0:^->2; 2:[abd]->1; 1f:");
        testNFA(16,"[a-d]","0:^->2; 2:[a-d]->1; 1f:");
        testNFA(17,"[^a-dg-p]","0:^->2; 2:[^a-dg-p]->1; 1f:");
        testNFA(21,"","0:^->1; 1f:");
        testNFA(22,"a","0:^->2; 2:a->1; 1f:");
        testNFA(23,"ab","0:^->2; 2:a->3; 3:b->1; 1f:");
        testNFA(24,"a|b","0:^->3,^->4; 3:a->1; 4:b->2; 1f:; 2f:");
        testNFA(25,"a|b|c","0:^->4,^->5,^->6; 4:a->1; 5:b->2; 6:c->3; 1f:; 2f:; 3f:");
        testNFA(26,"a*","0:^->2,^->3; 2:a->1,a->4; 3f:; 1f:; 4:a->1,a->4");
        testNFA(27,"a+","0:^->2; 2:a->1,a->3; 1f:; 3:a->1,a->3");
        testNFA(28,"a?","0:^->2,^->3; 2:a->1; 3f:; 1f:");
        testNFA(29,"a{2}","0:^->1; 1:a->3; 3:a->2; 2f:");
        testNFA(30,"a{2,}","0:^->1; 1:a->3; 3:a->2,a->4; 2f:; 4:a->2,a->4");
        testNFA(31,"a{2,4}","0:^->1; 1:a->5; 5:a->2,a->6; 2f:; 6:a->3,a->7; 3f:; 7:a->4; 4f:");
        testNFA(32,"a{0,2}","0:^->1; 1:a->2,a->4; 2f:; 4:a->3; 3f:");
        testNFA(33,".","0:^->2; 2:.->1; 1f:");
        testNFA(34,"[ab]","0:^->2; 2:[ab]->1; 1f:");
        testNFA(35,"[abd]","0:^->2; 2:[abd]->1; 1f:");
        testNFA(36,"[a-d]","0:^->2; 2:[a-d]->1; 1f:");
        testNFA(37,"[^a-dg-p]","0:^->2; 2:[^a-dg-p]->1; 1f:");
        testNFA(38,"((h(b)|h)z)*","0:^->4,^->7,^->9; 4f:; 7:h->2; 9:h->1; 2:z->3,z->6,z->8; 1:b->5; 3f:; 6:h->2; 8:h->1; 5:z->3,z->6,z->8");
        testNFA(39,"abc","0:^->2; 2:a->3; 3:b->4; 4:c->1; 1f:");
        testNFA(40,"b((a)){2}","0:^->1; 1:b->2; 2:a->3; 3:a->4; 4f:");
        if (re.extra_nullablebody){
            testNFA(41,"ab**c","0:^->2; 2:a->3,a->4,a->7,a->8; 3:b->5,b->6,b->9,b->10," +
                "b->11; 4:c->1; 7:b->5,b->6,b->9,b->10,b->11; 8:c->1; 5:b->5,b->6,b->9," +
                "b->10,b->11; 6:c->1; 9:b->5,b->6,b->9,b->10,b->11; 10:c->1; 11:b->5,b->6," +
                "b->9,b->10,b->11; 1f:");
        } else {
            testNFA(41,"ab**c","0:^->2; 2:a->3,a->4,a->7; 3:b->5,b->6,b->8; 4:c->1; 7:c->1; 5:b->5," +
                "b->6,b->8; 6:c->1; 8:b->5,b->6,b->8; 1f:");
        }
        testNFA(16,"[a-g][d-p]","0:^->2; 2:[a-g]->3; 3:[d-p]->1; 1f:");

        feature("tree");
        testTree(0,"a","a","(0,)0");
        testTree(1,"ab","ab","(0(1,)1(2,)2)0");
        testTree(2,"a|b","a","(0(1,)1)0");
        testTree(3,"a|a","a","(0(1|(0(2,)1)0|)2)0");
        testTree(4,"a*","aaa","(0(1,)1(1,)1(1,)1)0");
        testTree(5,"a*","","(0)0");
        testTree(6,"a+","aaa","(0(1,)1(1,)1(1,)1)0");
        testTree(7,"a(b)c","abc","(0(1,)1(2(3,)3)2(4,)4)0");
        testTree(8,"ace|bcd","ace","(0(1(2,)2(3,)3(4,)4)1)0");
        testTree(9,"abc|abcd","ab","nomatch");
        testTree(10,"abc|abcd","abc","(0(1(2,)2(3,)3(4,)4)1)0");
        testTree(11,"abc|abcd","abcde","nomatch");
        testTree(12,"abc|abd","abc","");
        testTree(13,"a(b|bc)c","abc","");
        testTree(14,"(a|b)*","aabbabababbb","");

        testTree(300,"a","a","(0,)0");
        testTree(301,"aa","aa","(0(1,)1(2,)2)0");
        testTree(302,"a|b","a","(0(1,)1)0");
        testTree(303,"a|b","b","(0(2,)2)0");
        testTree(304,"(a)*","","(0)0");
        testTree(305,"(a)*","a","(0(1,)1)0");
        testTree(306,"(a)*","aa","(0(1,)1(1,)1)0");
        testTree(307,"(a)+","a","(0(1,)1)0");
        testTree(308,"(a)+","aa","(0(1,)1(1,)1)0");
        testTree(309,"(a)","a","(0(1,)1)0");
        testTree(310,"(a)?","","(0)0");
        testTree(311,"(a)?","a","(0(1,)1)0");
        testTree(312,"(a)*b","b","(0(1)1(3,)3)0");
        testTree(313,"(a)*b","ab","(0(1(2,)2)1(3,)3)0");
        testTree(314,"aaab|aaac","aaac","(0(6(7,)7(8,)8(9,)9(10,)10)6)0");
        testTree(315,"(ab|(a)*)*","aba","");
        testTree(316,"(a)?(ab)?","ab","");
        testTree(317,"(a)?((ab)?)(b)?","ab","");
        testTree(3171,"((a)?)(((ab)?)((b)?))","ab","");
        testTree(318,"((a)?((ab)?))(b)?","ab","");
        testTree(319,"(a)?(((ab)?)(b)?)","ab","");
        testTree(320,"(a)?(a)?","a","");
        testTree(321,"((a)?(a)?)((a)?(a)?)","aaa","");
        testTree(322,"((a)?(a)?)((a)?(a)?)((a)?(a)?)","aaa","");
        testTree(323,"((a)?(a)?)*","aaa","");
        testTree(324,"(a)?((ab)?)(b)?","ab","");
        testTree(325,"(ab)?((b)?a)","aba","");
        testTree(326,"(a|ab|ba)*","aba","");
        testTree(327,"(aba|a*b)(aba|a*b)","ababa","");
        testTree(328,"(aba|a*b)*","ababa","");
        testTree(329,"(aba|ab|a)(aba|ab|a)","ababa","");
        testTree(330,"(aba|ab|a)*","ababa","");
        testTree(331,"(a(b)?)(a(b)?)","aba","");
        testTree(332,"(a(b)?)+","aba","");
        testTree(333,"(a*)(a*)","aa","");
        testTree(334,"a*(a*)","aa","");
        testTree(335,"(aa(b(b))?)+","aabbaa","");
        testTree(336,"(a(b)?)+","aba","");
        testTree(337,"(a)?b","b","");
        testTree(338,"a*b*","a","");
        testTree(400,"","","");
        testTree(401,"()","","");
        testTree(402,"()*","","");
        testTree(403,"()+","","");
        testTree(404,"()?","","");
        testTree(405,"a*a*","","");
        testTree(406,".","a","");
        testTree(407,"[ab]","b","");
        testTree(408,"[abd]","b","");
        testTree(409,"[a-d]","b","");
        testTree(410,"[^a-dg-p]","e","");
        testTree(411,".a.","aaa","");
        testTree(412,"((a)*)*","","");
        testTree(413,"(a|b)*","a","");
        testTree(414,"(a|aa)*","aaa","");
        testTree(415,"((a)?)","","");
        testTree(416,"((ab)?)","","");
        testTree(417,"\\\n","\r","nomatch");
        testTree(418,"\\\n","\n","");
        testTree(419,".|\\\n","\r","");
        testTree(420,"(.|\\\n)*","a\r\nb","");

        // ambiguous
        testTree(500,"((a)*)*","aa","");
        testTree(501,"(a|b|ab)*","ab","");
        testTree(502,"(ab|a|b)*","abab","");
        testTree(503,"(a|ab)(bc|c)","abc","");
        testTree(504,"(a|a*)*","aa","");
        testTree(505,"(a*|a)*","aa","");
        testTree(506,"a*|(a|b)*","aaa","");
        testTree(5061,"((a)*)|(((a)|(b))*)","aaa","");
        testTree(507,"(a|ab)(c|bcd)(de|e)","abcde","");
        testTree(508,"(a+|ba|aba)*b","abab","");
        testTree(509,"(a|b|ab)*","abab","");
        testTree(510,"a*aa","aaaa","");
        testTree(511,"(((ab))|a()b)*","ab","");
        testTree(512,"(a*|a*a*)*b","b","");
        testTree(513,"(a*a*|a*)*b","b","");
        testTree(514,"(a)*(f|j|ajf)*","aajf","");
        testTree(515,"(a|a)(b|b)","ab","");
        testTree(516,"a((b)?)*c","abbc","");
        testTree(517,"a|(a|b)","a","");
        testTree(518,"a|(a|b)","b","");
        testTree(519,"(())*","","");
        testTree(520,"((a)?|(a)?)","","");

        testTree(600,"","","");
        testTree(601,"a","a","");
        testTree(602,"abc","abc","");
        testTree(603,"a|bc","a","");
        testTree(604,"a|bc","bc","");
        testTree(605,"a(b)c","abc","");
        testTree(606,"a(bc)d","abcd","");
        testTree(607,"a(b|cd)e","abe","");
        testTree(608,"a(b|cd)e","acde","");
        testTree(609,"a*","a","");
        testTree(610,"(a)","a","");
        testTree(611,"a*","aa","");
        testTree(612,"ab*c","abc","");
        testTree(613,"a*","","");
        testTree(614,"a+","a","");
        testTree(615,"(a)?","","");
        testTree(616,"(a)?","a","");
        testTree(617,"a*b","b","");
        testTree(618,"((xx)(a|b|ab)*)*","xxab","");
        testTree(619,"(a|aa)(a)?","aa","");
        testTree(620,"(x+x+)+y","xxxx","nomatch");
        testTree(621,"(x+x+)+y","xxxxy","");
        testTree(622,"((xx)(a|b|ab)*)*","xxaxx","");
        testTree(623,"(a*b)*","aabab","");
        testTree(624,"((a|){2,3}){2}","aa","");
        testTree(625,"[a-g]|[c-q]","d","");
        testTree(626,"(.|\\\n)*(\\^(abc)+$)(.|\\\n)*","^abcabc$","");
        testTree(627,"(.|\\\n)*(\\^\n(abc\n)+$\n)(.|\\\n)*","^\nabc\nabc\n$\n","");

        testTree(700,"abc","ab","nomatch");
        testTree(701,"ab","abc","nomatch");
        testTree(702,"abd","acd","nomatch");
        testTree(703,"ab(d)?","abc","nomatch");

        // failures
        testTree(800,"a*bc","b","nomatch");
        testTree(801,"a(b)c","ac","nomatch");
        testTree(802,"abc*","a","nomatch");
        testTree(803,"a|b|c","d","nomatch");
        testTree(804,"abc","abcd","nomatch");
        testTree(805,"a+bc","bc","nomatch");
        testTree(806,"ab+c","ac","nomatch");
        testTree(807,"abc+","ab","nomatch");
        testTree(808,"a(b)?c","adc","nomatch");
        testTree(809,"a(b)?c","abbc","nomatch");
        testTree(810,"a(b)c","ac","nomatch");
        testTree(811,"a(b|d)c","ac","nomatch");
        testTree(812,"a(b|d)c","aac","nomatch");
        testTree(813,"a(b|dd)c","adc","nomatch");
        testTree(814,"a(b|d+)c","ac","nomatch");
        testTree(815,"a(b|(d)?)c","addc","nomatch");
        testTree(816,"a","","nomatch");
        testTree(817,"a(b|d)","abc","nomatch");

        // problematic
        testTree(900,"(a|)*","a","");
        testTree(901,"(a|())*","a","");
        testTree(902,"(a|()*)*","a","");
        testTree(903,"(a|(b)*)*","a","");
        testTree(904,"(a|(a|b)*)*","a","");
        testTree(905,"(a|(a)*|(a|c)*)*","a","");
        testTree(906,"a***","aaa","");
        testTree(907,"a***","aaa","");
        testTree(908,"((a|){2,3}){2}","aa","");
        testTree(909,"(a|)*","","");
        testTree(920,"(x(a*|ab*))*","xab","");
        testTree(921,"(x(a*|ab*))*","xabxab","");
        testTree(922,"(a|)*","","");

        // bounded groups
        testTree(930,"(a){3}","aa","nomatch");
        testTree(931,"(a){3}","aaa","");
        testTree(932,"(a){3}","aaaa","nomatch");
        testTree(933,"(a){2,3}","a","nomatch");
        testTree(934,"(a){2,3}","aa","");
        testTree(935,"(a){2,3}","aaa","");
        testTree(936,"(a){2,3}","aaaa","nomatch");
        testTree(937,"(a){2,}","a","nomatch");
        testTree(938,"(a){2,}","aa","");
        testTree(939,"(a){2,}","aaa","");
        testTree(940,"(a){,2}","a","");
        testTree(941,"(a){,2}","aa","");
        testTree(942,"(a){,2}","aaa","nomatch");
        testTree(943,"(a|){2}","","");
        testTree(944,"(a|){2}","a","");
        testTree(945,"(a|){2}","aa","");
        testTree(946,"(a|){2}","aaa","nomatch");
        testTree(947,"(a|){2,3}","a","");
        testTree(948,"(a|){2,3}","aa","");
        testTree(949,"(a|){2,3}","aaa","");
        testTree(950,"(a|){2,3}","aaaa","nomatch");
        testTree(951,"(a|){2,}","a","");
        testTree(952,"(a|){2,}","aa","");
        testTree(953,"(a|){2,}","aaa","");
        testTree(954,"(a|){,2}","a","");
        testTree(955,"(a|){,2}","aa","");
        testTree(956,"(a|){,2}","aaa","nomatch");

        if (!meDfaVsDfa){
            feature("get");
            testGet(0,"abc","abc",0,null,"[0-3:2(0]");
            testGet(1,"a(b)c","abc",0,null,"[0-3:4(0]");
            testGet(2,"a(b)c","abc",1,matches.get(0),"[1-2:1(2]");
            testGet(3,"a((b))c","abc",2,null,"[1-2:3(3]");
            if (re.extra_nullablebody){
                testGet(4,"a((b)*)*c","abc",2,null,"[1-1:7(3, 1-2:3(3, 1-2:7(3, 2-2:10(3]");
            } else {
                testGet(4,"a((b)*)*c","abc",2,null,"[1-2:3(3]");
            }
            testGet(5,"a(b)c(b)","abcb",2,null,"[3-4:3(5]");
            testGet(6,"a((bc)de)*","abcdebcde",2,null,"[1-3:5(4, 5-7:6(4]");
            testGet(7,"a((bc)de)*","abcdebcde",2,new Match(4,8),"[5-7:6(4]");
            testGet(8,"a(b)c","abc",2,null,"null");
            testGet(9,"((a)+|ba|aba)*b","aab",0,null,"[0-3:15(0]");
            testGet(10,"((a)+|ba|aba)*b","aab",2,null,"[0-1:15(3, 0-2:15(3, 1-2:6(3]");
            testGet(11,"a*","",0,null,"[0-0:3(0]");
            testGet(12,"(.*)(abc)(.*)","xxxabcxxabc",3,null,"[3-6:3(4, 8-11:3(4]");
            testGet(13,"(a|ab)(c|bc)","abc",0,null,"[0-3:2(0, 0-3:5(0]");
            List<Match> m = matches;
            testGet(14,"(a|ab)(c|bc)","abc",1,m.get(0),"[0-1:2(1]");
            testGet(15,"(a|ab)(c|bc)","abc",2,m.get(0),"[1-3:6(7, 2-3:7(7]");
            testGet(16,"(a|ab)(c|bc)","abc",1,m.get(1),"[0-2:5(1]");
            testGet(17,"(a|ab)(c|bc)","abc",2,m.get(1),"[1-3:6(7, 2-3:7(7]");
            testGet(18,"a*|b*","",0,new Match(0,0),"[0-0:5(0, 0-0:6(0]");
            testGet(19,"((a|aa))*","aaaa",2,null,"[0-1:3(1, 0-2:6(1, 1-2:4(1, 1-3:7(1, 2-3:4(1, 2-3:8(1, 2-4:7(1, 2-4:9(1, 3-4:4(1, 3-4:8(1]");
            testGet(20,"b((a)){2}","baa",2,null,"[1-2:2(3, 2-3:3(3]");
            testGet(21,"b((a)){2}","baa",1,null,"[1-3:2(2]");
            testGet(22,"a(b)c","abc",1,null,"[1-2:1(2]");
            testChildren(40,"a(b)c","abc",null,"[0-1:4(1, 1-2:1(2, 2-3:2(4]");
            testChildren(43,"a(b)*c","abbc",null,"[0-1:4(1, 1-3:1(2, 3-4:2(4]");
            m = matches;
            testChildren(44,"a(b)*c","abbc",m.get(0),"[]");
            testChildren(45,"a|b","b",null,"[0-1:4(0]");
            testChildren(46,"a|a","a",null,"[0-1:3(0, 0-1:4(0]");
            testGet(47,"a|a","a",0,null,"[0-1:3(0, 0-1:4(0]");
            m = matches;
            testChildren(48,"a|a","a",m.get(0),"[0-1:3(0]");
            testChildren(49,"a|a","a",m.get(1),"[0-1:4(0]");
            testGet(50,"a*","a",0,null,"[0-1:2(0]");
            if (re.extra_nullablebody){
                testGet(51,"(a|)*","a",0,null,"[0-1:3(0, 0-1:7(0]");
            } else {
                testGet(51,"(a|)*","a",0,null,"[0-1:3(0]");
            }

            re.testing = false;
            //Trc.out.printf("%s\n",re.dagToGraph());
        }
        //re.settrc("");
    }

    /**
     * Test the specified number of threads and chunks.
     *
     * @param      t number of the test case
     * @param      L length of text
     * @param      M minimum chunk size
     * @param      P number of cores
     * @param      D <code>true</code> if in testing, <code>false</code> otherwise
     * @param      B <code>true</code> if load balancing, <code>false</code> otherwise
     * @param      eT expected number of threads
     * @param      eN expected number of chunks
     */

    private static void testThCh(int t, int L, int M, int P, boolean D, boolean B,
        int eT, int eN){
        showTest(t);
        ThCh tc = re.nrThreads(L,M,P,D,B);
        int T = tc.nt();
        int N = tc.nc();
        // check consistency conditions
        if (T > P || T == 0 || (B? N > t*4 : N > T) || N == 0){
            trcfail(t);
            Trc.out.printf("T: %s N: %s\n",T,N);
            return;
        }
        if (T != eT){
            trcfail(t);
            trc("threads",eT,T);
        }
        if (N != eN){
            trcfail(t);
            trc("chunks",eN,N);
        }
    }

    /**
     * Test the number of threads and chunks.
     */

    private static void testThreadsChunks(){
        feature("threads and chunks");
        // in testing, no balancing
        testThCh(0,0,1,1,true,false,1,1);
        testThCh(1,1,1,1,true,false,1,1);
        testThCh(2,2,1,1,true,false,1,1);
        testThCh(3,2,1,2,true,false,2,2);
        testThCh(4,3,1,1,true,false,1,1);
        testThCh(5,3,1,2,true,false,2,2);
        testThCh(6,4,1,1,true,false,1,1);
        testThCh(7,4,1,2,true,false,2,2);
        // in testing, balancing
        testThCh(10,0,1,1,true,true,1,1);
        testThCh(11,1,1,1,true,true,1,1);
        testThCh(12,2,1,1,true,true,1,1);
        testThCh(13,2,1,2,true,true,2,2);
        testThCh(14,3,1,1,true,true,1,1);
        testThCh(15,3,1,2,true,true,2,2);
        testThCh(16,4,1,1,true,true,1,1);
        testThCh(17,4,1,2,true,true,2,2);
        testThCh(18,8,1,2,true,true,2,2);

        // not in testing, no balancing
        testThCh(20,1000,100,2,false,false,2,2);
        testThCh(21,1000,100,4,false,false,4,4);
        testThCh(22,1000,100,8,false,false,8,8);
        testThCh(23,1000,100,16,false,false,10,10);
        testThCh(24,10,100,16,false,false,1,1);

        // not in testing, balancing
        testThCh(30,1000,100,2,false,true,2,8);
        testThCh(31,1000,100,4,false,true,4,16);
        testThCh(32,1000,100,8,false,true,8,32);
        testThCh(33,1000,100,16,false,true,10,40);
        testThCh(34,10,100,16,false,true,1,1);
    }

    /**
     * Print the header line of the measures according to the option specified.
     */

    private static void timeCompareHeader(){
        if (options.contains("m-dag")){
            System.out.printf("seq  paral text-len  gain   htb-size htb-adds dag-longrate\n");
        }
        if (options.contains("m-phases")){
            System.out.printf("seq  paral text-len  gain  speed init L/R reachers sew builders end\n");
        }
        if (options.contains("m-compare")){
            System.out.printf("seq  paral text-len  gain  seq 1-core 2-cores\n");
        }
        if (options.contains("m-chunks")){
            System.out.printf("seq  paral text-len  gain  chunk chunk-len start-states aveStates\n");
        }
        if (options.contains("m-surv")){
            System.out.printf("seq  paral text-len  gain  survived parses\n");
        }
        if (options.contains("m-oper")){
            System.out.printf("seq  paral text-len  gain  fwd-op bwd-op\n");
        }
        if (options.contains("m-para")){
        }
        if (options.contains("m-decay")){
            System.out.printf("seq  paral text-len  gain  chunk, length, decay, parses-lengths\n");
        }
        if (options.contains("m-footprint")){
            System.out.printf("seq  paral text-len  gain  footPrint\n");
        }
    }

    /**
     * Deliver a string representing the algorithm run: T threads C chunks R if recognizion only.
     *
     * @param      rex RE
     * @return     string
     */

    private static String toAlg(ReParallel re){
        return "T" + re.nrThreads + "C" + re.nrChunks + (re.recognizionOnly ? "R": "");
    }
    
    /**
     * Do the measures specified by the options.
     *
     * @param      rex RE
     * @param      text text
     * @param      seq sequntial number of the measure
     */

    private static void timeCompare(String rex, String text, int seq){
        ReParallel re = new ReParallel();
        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        long tm0 = 0;
        for (int i = 0; i < REP_MEA; i++){
            long t1 = System.nanoTime();
            if (!re.matchSeq(text)){
                String str = (re.cursor + 30) < text.length() ?
                    text.substring(re.cursor,re.cursor + 30) :
                    text.substring(re.cursor,text.length());
                System.out.printf("matchSeq not matched at: %s: |%s|\n",re.cursor,str);
                return;
            }
            long t2 = System.nanoTime();
            tm0 += (t2-t1);
        }
        tm0 /= REP_MEA;
        ReParallel.Measure m0 = re.measure;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        long tm1 = 0;
        for (int i = 0; i < REP_MEA; i++){
            long t1 = System.nanoTime();
            if (!re.matchPar(text,1)){
                String str = (re.cursor + 30) < text.length() ?
                    text.substring(re.cursor,re.cursor + 30) :
                    text.substring(re.cursor,text.length());
                System.out.printf("matchPar,1 not matched at: %s: |%s|\n",re.cursor,str);
                return;
            }
            long t2 = System.nanoTime();
            tm1 += (t2-t1);
        }
        tm1 /= REP_MEA;
        ReParallel.Measure m1 = re.measure;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        long tm2 = 0;
        for (int i = 0; i < REP_MEA; i++){
            long t3 = System.nanoTime();
            if (!re.matchPar(text,0)){
                System.out.printf("matchPar,0 not matched\n");
            }
            long t4 = System.nanoTime();
            t4 -= t3;
            tm2 += t4;
        }
        tm2 /= REP_MEA;
        ReParallel.Measure m2 = re.measure;
        //if (!re.compareDag(m1.htb,m2.htb)){
        //System.out.printf("!!!!!\n");
        //}

        double gain = (double)tm2/tm1;
        String parall = toAlg(re);

        if (options.contains("m-dag") && m2 != null){
            // print the measures of dag
            System.out.printf("%s: %s %s %.2f --- %s %s %.2f\n",
                seq,parall,text.length(),gain,m2.htb.size(),m2.htb.nrAdd,m2.longRate);
        }
            
        if (options.contains("m-phases") && m2 != null){
            // print the speed and relative duration of the phases
            double tot = (double)(m2.timePar[m2.timePar.length-1] - m2.timePar[0]);
            String str = "";
            for (int i = 0; i < m2.timePar.length-1; i++){
                str += String.format(" %.2f",((double)(m2.timePar[i+1] - m2.timePar[i])/tot));
            }
            System.out.printf("%s: %s %s %.2f --- %.2f %s\n",
                seq,parall,text.length(),gain,(double)text.length()/(tm2/1000000),str);
        }
        
        if (options.contains("m-compare")){
            // print the comparison berween seq, 1 core and 2 cores
            System.out.printf("%s: %s %s %.2f --- %s %s %s\n",
                seq,parall,text.length(),gain,tm0/1000000,tm1/1000000,tm2/1000000);
        }

        if (options.contains("m-chunks") && m2 != null){
            // print the size of chunks and nr of start states
            String str = "";
            for (int i = 0; i < m2.sizeChunk.length; i++){
                str += String.format(" %s: %s %s %.2f",
                    i,m2.sizeChunk[i],m2.chunkStart[i],m2.aveStChunk[i]);
            }
            System.out.printf("%s: %s %s %.2f --- %s\n",
                seq,parall,text.length(),gain,str);
        }

        if (options.contains("m-surv")){
            // print the average parses survived in the reachers
            int tot = 0;
            for (int i = 0; i < m2.parsesSurvived.length; i++){
                tot += m2.parsesSurvived[i];
            }
            System.out.printf("%s: %s %s %.2f --- %.2f\n",
                seq,parall,text.length(),gain,(double)tot/m2.parsesSurvived.length);
        }

        if (options.contains("m-oper") && m2 != null){
            // print the number of operations of each step
            String strf = "";
            String strb = "";
            for (int i = 0; i < m2.nrOpFwd.length; i++){
                strf += String.format(" %s",m2.nrOpFwd[i]);
                strb += String.format(" %s",m2.nrOpBwd[i]);
            }
            System.out.printf("%s: %s %s %.2f --- %s -- %s\n",
                seq,parall,text.length(),gain,strf,strb);
        }

        if (options.contains("m-para") && m2 != null){
            printParallel(re);
        }

        if (options.contains("m-decay") && m2 != null){
            // print the measures of the parses of the reachers
            System.out.printf("%s: %s %s %.2f\n",
                seq,parall,text.length(),gain);
            for (int i = 0; i < m2.parsesLen.length; i++){
                // remove zeroes
                int n = 0;
                for (int j = 0; j < m2.parsesLen[i].length; j++){
                    if (m2.parsesLen[i][j] > 0) n++;
                }
                int[] lengths = new int[n];
                n = 0;
                for (int j = 0; j < m2.parsesLen[i].length; j++){
                    if (m2.parsesLen[i][j] > 0) lengths[n++] = m2.parsesLen[i][j];
                }
                Arrays.sort(lengths);
                int idx = (int)(lengths.length * 0.64);
                double decay = lengths[idx] / m2.sizeChunk[i];
                System.out.printf("  chunk %s length %s decay %.2f%% %s\n",
                    i,m2.sizeChunk[i],decay*100,Arrays.toString(lengths));
            }
        }

        if (options.contains("m-footPrint") && m2 != null){
            // print the footprint
            int size = 0;
            for (int i = 0; i < m2.footPrint.length; i++){
                size += m2.footPrint[i];
            }
            System.out.printf("%s: %s %s %.2f --- %s %.2f bytes/tok\n",
                seq,parall,text.length(),gain,size,(double)size/text.length());
        }
    }

    /**
     * Print the diagram of the times of the reachers and builders.
     *
     * @param      re RE
     */

    static void printParallel(ReParallel re){
        // check that the parts that should run in parallel did that
        if (re.measure.timeStartFwd[0] > re.measure.timeEndFwd[1] ||
            re.measure.timeStartFwd[1] > re.measure.timeEndFwd[0]){
            System.out.printf(" --- fwd not in parallel fwd start %s, fwd end %s\n",
                arrToMs(re.measure.timeStartFwd),arrToMs(re.measure.timeEndFwd));
        }
        if (re.measure.timeStartBwd[0] > re.measure.timeEndBwd[1] ||
            re.measure.timeStartBwd[1] > re.measure.timeEndBwd[0]){
            System.out.printf(" --- bwd not in parallel bwd start %s, bwd end %s\n",
                arrToMs(re.measure.timeStartBwd),arrToMs(re.measure.timeEndBwd));
        }

        // check that the parts are balanced
        long dfwd0 = re.measure.timeEndFwd[0] - re.measure.timeStartFwd[0];
        long dfwd1 = re.measure.timeEndFwd[1] - re.measure.timeStartFwd[1];
        long diffFwd = inters(re.measure.timeStartFwd[0],re.measure.timeEndFwd[0],
            re.measure.timeStartFwd[1],re.measure.timeEndFwd[1]);
        if (Math.abs(dfwd0-dfwd1) > dfwd0*0.5){
            System.out.printf(" --- fwd times much diff %s %s -- chunks %s %s -- overlap %s\n",
                dfwd0/1000000,dfwd1/1000000,re.measure.sizeChunk[0],
                re.measure.sizeChunk[1],diffFwd/1000000);
        }
        // measure the time of each fwd and compare to the others, and the same with bwd,
        // and compare also the intersection, if it is small compared to the length
        long dbwd0 = re.measure.timeEndBwd[0] - re.measure.timeStartBwd[0];
        long dbwd1 = re.measure.timeEndBwd[1] - re.measure.timeStartBwd[1];
        long diffBwd = inters(re.measure.timeStartBwd[0],re.measure.timeEndBwd[0],
            re.measure.timeStartBwd[1],re.measure.timeEndBwd[1]);
        if (Math.abs(dbwd0-dbwd1) > dbwd0*0.5){
            System.out.printf(" --- bwd times much diff %s %s -- chunks %s %s -- overlap %s\n",
                dbwd0/1000000,dbwd1/1000000,re.measure.sizeChunk[0],
                re.measure.sizeChunk[1],diffBwd/1000000);
        }
        
        if (diffFwd < dfwd0*0.5){
            System.out.printf(" --- fwd intersects little %s %s\n",
                diffFwd/1000000,dfwd0/1000000);
        }
        if (diffBwd < dbwd0*0.5){
            System.out.printf(" --- bwd intersects little %s %s\n",
                diffBwd/1000000,dbwd0/1000000);
        }
    }

    /**
     * Deliver a string repesenting the values of the specified array in milliseconds.
     *
     * @param      arr array
     * @return     string
     */

    static String arrToMs(long[] arr){
        String res = "[";
        for (int i = 0; i < arr.length; i++){
            if (i > 0) res += ", ";
            res += arr[i]/1000000;
        }
        return res + "]";
    }

    /**
     * Deliver the length of the intersection of the specified intervals.
     *
     * @param      t0 start time of the first interval
     * @param      t1 end time of the first interval
     * @param      s0 start time of the second interval
     * @param      s1 end time of the second interval
     * @return     length of the intersection, 0 if the intervals are disjoint
     */

    /* Cases of intersections:
     *     t        --------
     * 1:  s     ------
     * 2:  s     --------------
     * 3:  s           ----
     * 4:  s           ----------
     */
    
    static long inters(long t0, long t1, long s0, long s1){
        long diff = 0;
        if (t0 > s0){
            if (t0 < s1){
                if (t1 < s1){
                    diff = t1 - t0;   // case 2
                } else {
                    diff = s1 - t0;   // case 1
                }
            }
        } else {
            if (s0 < t1){
                if (s1 < t1){
                    diff = s1 - s0;   // case 3
                } else {
                    diff = t1 - s0;   // case 4
                }
            }
        }
        return diff;
    }

    /**
     * Measure the parse times of the specified benchmark.
     *
     * @param      rex regular expression
     * @param      text text
     * @param      lenghts array of the lenghts of the portions of the text
     * @param      bench name of the benchmark
     * @param      rec <code>true</code> to execute only recognizion, <code>false</code> otherwise.
     */

    static void measureBench(String rex, String text, int[] lenghts, String bench){
        if (!meDfaVsDfa){
            measureBench(rex,text,lenghts,bench,false);   // parsing
        }
        measureBench(rex,text,lenghts,bench,true);        // recognizion
    }
    static void measureBench1(String rex, String text, int[] lenghts, String bench, boolean rec){
        Trc.out.printf("\n%s parallel %s\n",bench,rec?"recognizion":"parsing");
        ReParallel re = new ReParallel();
        for (int j = 0; j < lenghts.length; j++){
            Trc.out.printf(" %s",lenghts[j]);
        }
        Trc.out.printf("\n");
        for (int i = 2; i < 18; i += 2){
            String line = "";
            for (int j = 0; j < 6; j++){
                if (!re.compile(rex)){
                    System.out.printf("measureBench compile error at: %s\n",re.cursor);
                    return;
                }
                String tx = text.substring(0,lenghts[j]);
                long tm1 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!re.matchPar(tx,1,rec)){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                            lenghts[j],re.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm1 += (t2-t1);
                }
                tm1 /= REP_MEA;
                // Trc.out.printf("P %s len %s par-1 time %s\n",i,tx.length(),tm1/1000000);
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!re.matchPar(tx,i,rec)){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s P %s not matched at: %s: |%s|\n",
                            lenghts[j],re.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                }
                tm0 /= REP_MEA;
                // Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tm0/1000000);
                line += String.format(" %.2f",((double)tm1/(double)tm0));
            }
            Trc.out.printf("%s %s\n",i,line);
        }

        Trc.out.printf("\n%s parallel vs serial %s\n",bench,rec?"recognizion":"parsing");
        String line = "";
        for (int j = 0; j < 6; j++){
            if (!re.compile(rex)){
                System.out.printf("measureBench compile error at: %s\n",re.cursor);
                return;
            }
            String tx = text.substring(0,lenghts[j]);
            long tm1 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchSeq(tx,rec)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm1 += (t2-t1);
            }
            tm1 /= REP_MEA;
            // Trc.out.printf("P %s len %s par-1 time %s\n",i,tx.length(),tm1/1000000);
            long tm0 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchPar(tx,1,rec)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s P % snot matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm0 += (t2-t1);
            }
            tm0 /= REP_MEA;
            // Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tm0/1000000);
            line += String.format(" %.2f",((double)tm1/(double)tm0));
        }
        Trc.out.printf("%s\n",line);
    }

    /* For each test print:
     *  x: nr of cores
     *  y: text lengths (6 values)
     *  z: speedup
     *
     *  x  y  z        only once
     *  2  1  0.79     block of data for y = 1
     *  ..
     *  16 1  1.00 
     *
     *  2  2  0.79     block of data for y = 2
     *  ..
     *  16 2  1.00
     *
     *  ..
     *
     *  2  6  0.79     block of data for y = 6
     *  ..
     *  16 6  1.00
     */

    static String labelLength(int len){
        String res = "";
        if (len < 1000){
            res += len;
        } else {
            res += (int)(len/1000) + "K";
        }
        return res;
    }

    static void measureBench1(int[] lenghts, String bench){
        Trc.out.printf("\n%s\n",bench);
        for (int j = 0; j < lenghts.length; j++){
            Trc.out.printf(" %s:%s",lenghts[j],labelLength(lenghts[j]));
        }
        Trc.out.printf("\n");
    }

    static void measureBench(String rex, String text, int[] lenghts, String bench, boolean rec){
        if (meDfaVsDfa){
            measureBenchMeDfa(rex,text,null,lenghts,bench);
            return;
        }
        Trc.out.printf("\n%s parallel %s\n",bench,rec?"recognizion":"parsing");
        ReParallel re = new ReParallel();
        for (int j = 0; j < lenghts.length; j++){
            Trc.out.printf(" %s",labelLength(lenghts[j]));
        }
        Trc.out.printf("\n");
        Trc.out.printf("x  y  z\n");
        for (int j = 0; j < 6; j++){
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                if (!re.compile(rex)){
                    System.out.printf("measureBench compile error at: %s\n",re.cursor);
                    return;
                }
                String tx = text.substring(0,lenghts[j]);
                long tm1 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!re.matchPar(tx,1,rec)){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                            lenghts[j],re.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm1 += (t2-t1);
                }
                tm1 /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("P %s len %s par-1 time %s\n",i,tx.length(),tm1/1000000);
                #endif
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!re.matchPar(tx,i,rec)){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s P %s not matched at: %s: |%s|\n",
                            lenghts[j],re.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                }
                tm0 /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tm0/1000000);
                #endif                
                #ifdef ABS_TIME
                Trc.out.printf("%-3s%-3s%.2f %s\n",i,j+1,((double)tm1/(double)tm0),tm0/1000000);
                #else
                Trc.out.printf("%-3s%-3s%.2f\n",i,j+1,((double)tm1/(double)tm0));
                #endif
            }
            Trc.out.printf("\n");
        }

        Trc.out.printf("\n%s parallel vs serial %s\n",bench,rec?"recognizion":"parsing");
        String line = "";
        for (int j = 0; j < 6; j++){
            if (!re.compile(rex)){
                System.out.printf("measureBench compile error at: %s\n",re.cursor);
                return;
            }
            String tx = text.substring(0,lenghts[j]);
            long tm1 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchSeq(tx,rec)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm1 += (t2-t1);
            }
            tm1 /= REP_MEA;
            // Trc.out.printf("P %s len %s par-1 time %s\n",i,tx.length(),tm1/1000000);
            long tm0 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchPar(tx,1,rec)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s P % snot matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm0 += (t2-t1);
            }
            tm0 /= REP_MEA;
            // Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tm0/1000000);
            line += String.format(" %.2f",((double)tm1/(double)tm0));
        }
        Trc.out.printf("%s\n",line);

        #ifdef ABS_TIME
        Trc.out.printf("\n%s serial parsing and recognizion\n",bench);
        String linepars = "parsing";
        String linerec = "recogn.";
        for (int j = 0; j < 6; j++){
            if (!re.compile(rex)){
                System.out.printf("measureBench compile error at: %s\n",re.cursor);
                return;
            }
            String tx = text.substring(0,lenghts[j]);
            long tm1 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchPar(tx,1)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm1 += (t2-t1);
            }
            tm1 /= REP_MEA;
            linepars += String.format("\t%s",tm1/1000000);
            // Trc.out.printf("P %s len %s par-1 time %s\n",i,tx.length(),tm1/1000000);
            long tm0 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifndef DRY_RUN
                if (!re.matchPar(tx,1,true)){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s P % snot matched at: %s: |%s|\n",
                        lenghts[j],re.cursor,str);
                    return;
                }
                #endif
                long t2 = System.nanoTime();
                tm0 += (t2-t1);
            }
            tm0 /= REP_MEA;
            // Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tm0/1000000);
            linerec += String.format("\t%s",tm0/1000000);
        }
        Trc.out.printf("%s\n%s\n",linepars,linerec);
        #endif
    }

    /**
     * Measure the speedup of recognizion of the specified benchmark of the RI-DFA
     * recognizer vs the DFA one.
     *
     * @param      rex regular expression
     * @param      text text, if only one (which is sliced to obtain several)
     * @param      texts array of texts
     * @param      lenghts array of the lenghts of the portions of the text
     * @param      bench name of the benchmark
     */

    static void measureBenchMeDfa(String rex, String text, String[] texts,
        int[] lenghts, String bench){
        if (dfaTrans){
            measureBenchTrans(rex,text,texts,lenghts,bench);
            return;
        }
        #ifdef DEBUG
        Trc.out.printf("\n%s RI-DFA vs DFA and NFA\n",bench);
        #endif
        ReParallel re = new ReParallel();
        ReParallel reDfa = new ReParallel();
        ReParallel reNfa = new ReParallel();
        // ReParallel reSfa = new ReParallel();
        int nrRuns = 0;

        StringBuilder sb1 = new StringBuilder();    // for dfa comparison
        sb1.append("% " + bench + " RI-DFA comparison with deterministic MEFA\n");
        StringBuilder sb2 = new StringBuilder();    // for nfa comparison
        sb2.append("% " + bench + " RI-DFA comparison with nondeterministic MEFA\n");
        StringBuilder sb3 = new StringBuilder();    // for transitions dfa comparison
        sb3.append(bench + " RI-DFA comparison with det. MEFA transitions");
        StringBuilder sb4 = new StringBuilder();    // for transitions nfa comparison
        sb4.append(bench + " RI-DFA comparison with nondet. MEFA transitions");
        for (int j = 0; j < lenghts.length; j++){
            sb1.append(" " + labelLength(lenghts[j]));
            sb2.append(" " + labelLength(lenghts[j]));
        }
        sb1.append("\nx  y  z\n");
        sb2.append("\nx  y  z\n");

        for (int j = 0; j < 6; j++){
            sb1.append("\n");
            sb2.append("\n");
            #ifdef DEBUG
            Trc.out.printf("text length slot %s: %s%%\n",j,(j+1)*16);
            #endif
            long totlenRi = 0;
            long totlenDfa = 0;
            long totlenNfa = 0;
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                #ifdef DEBUG
                Trc.out.printf("cores %s\n",i);
                #endif
                // use the ri-dfa
                if (!re.compile(rex,ReParallel.MIN_ME_DFA)){
                    System.out.printf("%s measureBenchMeDfa compile error at: %s\n",benchName,re.cursor);
                    return;
                }
                String tx = null;
                if (text != null){
                    tx = text.substring(0,lenghts[j]);
                } else {
                    tx = texts[j];
                }
                long tmRi = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!re.recPar(tx,i)){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("%s MIN_ME_DFA measureBenchMeDfa len %s 1 not matched at: %s: |%s|\n",
                            benchName,lenghts[j],re.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tmRi += (t2-t1);
                }
                tmRi /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("RI-DFA P %s len %s par-%s time %s\n",i,tx.length(),i,tmRi/1000000);
                #endif
                if (i == CORE_NTRANS){
                    totlenRi = transitions(re);          // total transitions reachers
                }
                nrRuns++;

                // use the dfa
                if (!reDfa.compile(rex,ReParallel.DFA)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
                    return;
                }
                long tmDfa = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!reDfa.recPar(tx,i)){
                        String str = (reDfa.cursor + 30) < tx.length() ?
                            tx.substring(reDfa.cursor,reDfa.cursor + 30) :
                            tx.substring(reDfa.cursor,tx.length());
                        System.out.printf("%s DFA measureBenchMeDfa len %s P %s not matched at: %s: |%s|\n",
                            benchName,lenghts[j],i,reDfa.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tmDfa += (t2-t1);
                }
                tmDfa /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("DFA P %s len %s par-%s time %s\n",i,tx.length(),i,tmDfa/1000000);
                #endif                
                // N.B. recognizion time DFA / RI-DFA = speedup
                sb1.append(String.format("%-3s%-3s%.2f\n",i,j+1,((double)tmDfa/(double)tmRi)));
                if (i == CORE_NTRANS){
                    totlenDfa = transitions(reDfa);    // total transitions reachers
                }
                nrRuns++;

                // use the nfa
                if (!reNfa.compile(rex,ReParallel.NFA)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reNfa.cursor);
                    return;
                }
                long tmNfa = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    if (!reNfa.recParNfa(tx,i)){
                        String str = (reNfa.cursor + 30) < tx.length() ?
                            tx.substring(reNfa.cursor,reNfa.cursor + 30) :
                            tx.substring(reNfa.cursor,tx.length());
                        System.out.printf("%s NFA measureBenchMeDfa len %s P %s not matched at: %s: |%s|\n",
                            benchName,lenghts[j],i,reNfa.cursor,str);
                        return;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tmNfa += (t2-t1);
                }
                tmNfa /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("NFA P %s len %s par-%s time %s\n",i,tx.length(),i,tmNfa/1000000);
                #endif                
                // N.B. recognizion time NFA / RI-DFA = speedup
                sb2.append(String.format("%-3s%-3s%.2f\n",i,j+1,((double)tmNfa/(double)tmRi)));
                if (i == CORE_NTRANS){
                    totlenNfa = transitions(reNfa);    // total transitions reachers
                }
                nrRuns++;

                /*
                // use the sfa
                if (!reSfa.compile(rex,ReParallel.SFA)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reSfa.cursor);
                    return;
                }
                long tmSfa = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    if (!reSfa.recParSfa(tx,i)){
                        String str = (reSfa.cursor + 30) < tx.length() ?
                            tx.substring(reSfa.cursor,reSfa.cursor + 30) :
                            tx.substring(reSfa.cursor,tx.length());
                        System.out.printf("%s SFA measureBenchMeDfa len %s P %s not matched at: %s: |%s|\n",
                            benchName,lenghts[j],i,reSfa.cursor,str);
                        return;
                    }
                    long t2 = System.nanoTime();
                    tmSfa += (t2-t1);
                }
                tmSfa /= REP_MEA;
                #ifdef DEBUG
                Trc.out.printf("P %s len %s par-%s time %s\n",i,tx.length(),i,tmSfa/1000000);
                #endif                
                */
                nrRuns++;
            }
            sb3.append(String.format("\t& %.2f",
                (double)totlenDfa/totlenRi));
            sb4.append(String.format("\t& %.2f",
                (double)totlenNfa/totlenRi));
        }
        Trc.out.printf("\n%s%s\n%s\n%s\n",sb1,sb2,sb3,sb4);
        Trc.out.printf("nr of recognizions %s\n",nrRuns);
    }

    /**
     * Measure the number of transitions of the recognizion of the specified benchmark
     * of a number of algorithms vs the DFA one.
     *
     * @param      rex regular expression
     * @param      text text, if only one (which is sliced to obtain several)
     * @param      texts array of texts
     * @param      lenghts array of the lenghts of the portions of the text
     * @param      bench name of the benchmark
     */

    static void measureBenchTrans(String rex, String text, String[] texts,
        int[] lenghts, String bench){
        #ifdef DEBUG
        Trc.out.printf("\n%s DFAs transitions comparison\n",bench);
            #endif
        ReParallel reDfa = new ReParallel();
        ReParallel reDfaf = new ReParallel();
        ReParallel reDfab = new ReParallel();
        ReParallel reDfafb = new ReParallel();
        ReParallel reDfaMmefa = new ReParallel();
        ReParallel reDfaMmefab = new ReParallel();
        ReParallel reDfaMefa = new ReParallel();
        ReParallel reDfaMefab = new ReParallel();
        int nrRuns = 0;

        Trc.out.printf("bench\tlen\tdfa-f\tdfa-b\tdfa-fb\tmmefa\tmmefa-b\tmefa\tmefa-b\n");
        for (int j = 0; j < 6; j++){
            #ifdef DEBUG
            Trc.out.printf("text length slot %s: %s%%\n",j,(j+1)*16);
            #endif
            long totlenDfa = 0;
            long totlenDfaf = 0;
            long totlenDfab = 0;
            long totlenDfafb = 0;
            long totlenDfaMmefa = 0;
            long totlenDfaMmefab = 0;
            long totlenDfaMefa = 0;
            long totlenDfaMefab = 0;
            String tx = null;
            if (text != null){
                tx = text.substring(0,lenghts[j]);
            } else {
                tx = texts[j];
            }
            totlenDfa = measureTrans(reDfa,rex,tx,ReParallel.DFA,j,lenghts);
            nrRuns++;
            totlenDfaf = measureTrans(reDfaf,rex,tx,ReParallel.DFA_F,j,lenghts);
            nrRuns++;
            totlenDfab = measureTrans(reDfab,rex,tx,ReParallel.DFA_B,j,lenghts);
            nrRuns++;
            totlenDfafb = measureTrans(reDfafb,rex,tx,ReParallel.DFA_FB,j,lenghts);
            nrRuns++;
            totlenDfaMmefa = measureTrans(reDfaMmefa,rex,tx,ReParallel.MIN_ME_DFA,j,lenghts);
            nrRuns++;
            totlenDfaMmefab = measureTrans(reDfaMmefab,rex,tx,ReParallel.MIN_ME_DFA_B,j,lenghts);
            nrRuns++;
            totlenDfaMefa = measureTrans(reDfaMefa,rex,tx,ReParallel.NME_DFA,j,lenghts);
            nrRuns++;
            totlenDfaMefab = measureTrans(reDfaMefab,rex,tx,ReParallel.NME_DFA_B,j,lenghts);
            nrRuns++;
            Trc.out.printf("%s\t%s\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n",bench,j,
                (double)totlenDfaf/(double)totlenDfa,
                (double)totlenDfab/(double)totlenDfa,
                (double)totlenDfafb/(double)totlenDfa,
                (double)totlenDfaMmefa/(double)totlenDfa,
                (double)totlenDfaMmefab/(double)totlenDfa,
                (double)totlenDfaMefa/(double)totlenDfa,
                (double)totlenDfaMefab/(double)totlenDfa);
        }
        Trc.out.printf("nr of recognizions %s\n",nrRuns);
    }

    static long measureTrans(ReParallel reDfa, String rex, String tx, int kind,
        int j, int[] lenghts){
        if (!reDfa.compile(rex,kind)){
            System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
            return 0;
        }
        int i = CORE_NTRANS;        // number of cores (chunks)
        #ifndef DRY_RUN
        if (!reDfa.recPar(tx,i)){
            String str = (reDfa.cursor + 30) < tx.length() ?
                tx.substring(reDfa.cursor,reDfa.cursor + 30) :
                tx.substring(reDfa.cursor,tx.length());
            System.out.printf("%s measureBenchTrans %s len %s P %s not matched at: %s: |%s|\n",
                benchName,kind,lenghts[j],i,reDfa.cursor,str);
            return 0;
        }
        #endif
        long totlenDfa = transitions(reDfa);    // total transitions reachers
        // Trc.out.printf("---%s kind %s len %s initials %s trans %s\n",benchName,kind,j,reDfa.measure.initialStates,totlenDfa);
        return totlenDfa;
    }

    /**
     * Deliver the number of transitions done for recognizion by the FA of the specified RE,
     *
     * @param      re parallel recognizer
     * @return     total number of transitions
     */

    static long transitions(ReParallel re){
        #ifdef DRY_RUN
        return 1;
        #else
        ReParallel.Measure m = re.measure;
        long totlen = 0;                     // total transitions reachers
        if (m != null){
            for (int i = 0; i < m.nrtrans.length; i++){
                totlen += m.nrtrans[i];
            }
        }
        return totlen;
        #endif
    }
    
    static void benchData(String bench, int[] lengths, int relen){
        Trc.out.printf("data of %s\n",bench);
        long ave = 0;
        for (int i = 0; i < lengths.length; i++){
            ave += lengths[i];
        }
        Trc.out.printf("text lengths: %s ave: %s\n",
            Arrays.toString(lengths),ave/lengths.length);
        Trc.out.printf("(average) re length: %s\n",relen);
    }
    
    /**
     * Run the sequential parser.
     *
     * @param      rex regular expression
     * @param      text text
     * @param      bench name of the benchmark
     */

    static void runSequential(String rex, String text, String bench){
        ReParallel rep = new ReParallel();
        rep.compile(rex);
        System.out.printf("%s seq %s\n",bench,LocalTime.now());
        Instant i0 = Instant.now();
        if (!rep.matchSeq(text)){
            System.out.printf("matchSeq not matched at: %s: |%s|\n",
                rep.cursor,rep.text.substring(rep.cursor));
        }
        Instant i1 = Instant.now();
        System.out.printf("%s seq %s %s elapsed %s\n",bench,toAlg(rep),
            LocalTime.now(),Duration.between(i0,i1));

        ReParallel re2 = new ReParallel();
        re2.compile(rex);
        if (!re2.matchPar(text,1)){
            System.out.printf("matchPar not matched at: %s: |%s|\n",
                re2.cursor,re2.text.substring(re2.cursor));
        }
        if (!ReParallel.compareDag(rep.dagHtb,re2.dagHtb)){
            System.out.printf("dag diff\n");
        }
    }

    /**
     * Run the parallel parser.
     *
     * @param      rex regular expression
     * @param      text text
     * @param      bench name of the benchmark
     */

    static void runParallel(String rex, String text, String bench){
        ReParallel rep = new ReParallel();
        rep.compile(rex);
        System.out.printf("%s par %s\n",bench,LocalTime.now());
        Instant i0 = Instant.now();
        if (!rep.matchPar(text,0)){
            System.out.printf("matchPar-0 not matched at: %s: |%s|\n",
                rep.cursor,rep.text.substring(rep.cursor));
        }
        Instant i1 = Instant.now();
        System.out.printf("%s par %s %s elapsed %s\n",bench,toAlg(rep),
            LocalTime.now(),Duration.between(i0,i1));

        ReParallel re2 = new ReParallel();
        re2.compile(rex);
        if (!re2.matchPar(text,1)){
            System.out.printf("matchPar-1 not matched at: %s: |%s|\n",
                re2.cursor,re2.text.substring(re2.cursor));
        }
        if (!ReParallel.compareDag(rep.dagHtb,re2.dagHtb)){
            System.out.printf("dag diff\n");
        }
    }

    /**
     * Run the test to measure the benefits of the ri-dfa.
     *
     * @param      rex regular expression
     * @param      text text
     * @param      bench name of the benchmark
     */

    static void runParallelMeDfa(String rex, String text, String bench){
        ReParallel rep = new ReParallel();
        rep.compile(rex);
        // System.out.printf("%s par %s\n",bench,LocalTime.now());
        Instant i0 = Instant.now();
        if (!rep.matchPar(text,0,false)){
            System.out.printf("matchPar-0 not matched at: %s: |%s|\n",
                rep.cursor,rep.text.substring(rep.cursor));
        }
        Instant i1 = Instant.now();
        System.out.printf("%s par %s %s elapsed %s\n",bench,toAlg(rep),
            LocalTime.now(),Duration.between(i0,i1));

        ReParallel re2 = new ReParallel();
        re2.compile(rex);
        if (!re2.matchSeq(text)){
            System.out.printf("matchSeq not matched at: %s: |%s|\n",
                re2.cursor,re2.text.substring(re2.cursor));
        }
        if (!ReParallel.compareDag(rep.dagHtb,re2.dagHtb)){
            System.out.printf("dag diff\n");
        }
    }

    /**
     * Show the number of states of the various FAs if the option "fa" is present.
     *
     * @param    rex string of the RE
     */

    static void showFa(String rex){
        ReParallel re = new ReParallel();
        if (options.contains("fa")){
            if (meDfaVsDfa){
                long t1 = System.nanoTime();
                re.compile(rex,ReParallel.MIN_ME_DFA);
                long t2 = System.nanoTime() -t1 ;
                ReParallel reDfa = new ReParallel();
                reDfa.compile(rex,ReParallel.DFA);
                Trc.out.printf("%s states nfa %s ri-dfa %s minimized initial %s dfa %s\n",
                    benchName,
                    re.nfa.stateNr,re.dfa.stateNr,re.dfa.start1.length,reDfa.dfa.strictStateNr);
                Trc.out.printf("%s compile time %s\n",benchName,t2/1000000);
            } else {
                long t1 = System.nanoTime();
                re.compile(rex);
                long t2 = System.nanoTime() -t1 ;
                Trc.out.printf("%s states nfa %s dfa %s revdfa %s ri-dfa %s rev-ri-dfa %s\n",
                    benchName,
                    re.nfa.stateNr,re.dfa.strictStateNr,re.revdfa.strictStateNr,re.dfa.stateNr,re.revdfa.stateNr);
                Trc.out.printf("%s compile time %s\n",benchName,t2/1000000);
            }
        }
    }

    /**
     * Run the bigdata benchmark.
     */

    private static String bigdataRe = "((hfj)z)*";
    
    private static void testBigData(){
        benchName = "bigdata";

        re = new ReParallel();
        String rex = bigdataRe;
        if (!re.compile(rex)){
            System.out.printf("compile error\n");
        }
        showFa(rex);
        int[] lengths = new int[]{409600,819200,1638400,3276800,6553600,13107200};
        if (options.contains("bench")){
            char[] longarr = new char[26214400];
            int k = 0;
            String piece = "hfjz";
            for (int i = 0; i < 6553600; i++){
                for (int j = 0; j < piece.length(); j++){
                    longarr[k++] = piece.charAt(j);
                }
            }
            String text = String.valueOf(longarr);
            measureBench(rex,text,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }

        if (options.contains("seq")){
            char[] longarr = new char[26214400];
            int k = 0;
            String piece = "hfjz";
            for (int i = 0; i < 6553600; i++){
                for (int j = 0; j < piece.length(); j++){
                    longarr[k++] = piece.charAt(j);
                }
            }
            String text = String.valueOf(longarr);
            runSequential(rex,text,benchName);
        }
        if (options.contains("par")){
            char[] longarr = new char[26214400];
            int k = 0;
            String piece = "hfjz";
            for (int i = 0; i < 6553600; i++){
                for (int j = 0; j < piece.length(); j++){
                    longarr[k++] = piece.charAt(j);
                }
            }
            String text = String.valueOf(longarr);
            runParallel(rex,text,benchName);
        }
        if (options.contains("ri-dfa")){
            char[] longarr = new char[26214400];
            int k = 0;
            String piece = "hfjz";
            for (int i = 0; i < 6553600; i++){
                for (int j = 0; j < piece.length(); j++){
                    longarr[k++] = piece.charAt(j);
                }
            }
            String text = String.valueOf(longarr);
            runParallelMeDfa(rex,text,benchName);
        }

        if (optionContains("m-")){
            String text = null;
            timeCompareHeader();
            int n = 100;
            for (int ii = 0; ii < 20; ii++, n = n*2){
                String piece = "hfjz";
                char[] longarr = new char[4*n];
                int k = 0;
                for (int i = 0; i < n; i++){
                    for (int j = 0; j < piece.length(); j++){
                        longarr[k++] = piece.charAt(j);
                    }
                }
                text = String.valueOf(longarr);
                timeCompare(rex,text,ii);
            }
        }
    }
    
    /**
     * Run the fasta benchmark.
     */

    private static String fastaRe = "(>PZ[0-9]*(_[A-Z]*)?(\\ [A-Za-z]*=[0-9\\.]*)*\n ([A-Z\n]*((ATG([ACTG]{3})+((TAA)|(TAG)|(TGA))))?[A-Z\n])*)*";
    
    private static void testFasta(){
        benchName = "fasta";
        
        re = new ReParallel();
        String rex = fastaRe;

        if (!re.compile(rex)){
            int end = re.cursor + 20;
            if (end >= rex.length()) end = rex.length();
            System.out.printf("compile error at: %s %s\n",re.cursor,rex.substring(re.cursor,end));
            return;
        }
        showFa(rex);

        String text = null;
        Path filePath = null;
        try {
            filePath = Path.of("pz_cDNAs.fasta.txt");
            text = Files.readString(filePath);
        } catch (Throwable exc){
            System.out.printf("error on file %s\n",filePath);
            System.exit(1);
        }

        int[] lengths = new int[]{658001,679557,701113,722669,744225,765781};
        if (options.contains("bench")){
            String tx = "";
            String piece = null;
            int idx = 0;
            for (int i = 0; i < 20; i++){
                for (int j = 0; j < 40; j++){            // take increasing pieces of the text
                    idx = text.indexOf(">PZ",idx);
                    if (idx < 0) break;
                    idx += 3;
                }
                if (idx < 0) break;
                tx = text.substring(0,idx-3);
                if (piece == null){
                    piece = tx;
                }
            }
            for (int i = 1; i < 30; i++){
                StringBuilder sx = new StringBuilder();
                sx.append(text);
                for (int j = 0; j < i; j++){
                    sx.append(piece);
                }
                tx = sx.toString();
            }
            measureBench(rex,tx,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }

        if (options.contains("seq")){
            runSequential(rex,text,benchName);
        }

        if (options.contains("par")){
            runParallel(rex,text,benchName);
        }
        if (options.contains("ri-dfa")){
            runParallelMeDfa(rex,text,benchName);
        }

        /*
        List<Match> offs = re.getMatches(new Match(0,text.length()+1),2);
        if (offs != null){
            for (Offsets o : offs){
                Trc.out.printf("%s-%s %s\n",o.start,o.end,text.substring(o.start,o.end));
            }
        }
        */

        if (optionContains("m-")){
            timeCompareHeader();
            String piece = null;
            int idx = 0;
            for (int i = 0; i < 20; i++){
                for (int j = 0; j < 40; j++){            // take increasing pieces of the text
                    idx = text.indexOf(">PZ",idx);
                    if (idx < 0) break;
                    idx += 3;
                }
                if (idx < 0) break;
                String tx = text.substring(0,idx-3);
                timeCompare(rex,tx,i);
                if (piece == null){
                    piece = tx;
                }
            }
            timeCompare(rex,text,20);
            for (int i = 1; i < 30; i++){
                StringBuilder sx = new StringBuilder();
                sx.append(text);
                for (int j = 0; j < i; j++){
                    sx.append(piece);
                }
                String tx = sx.toString();
                timeCompare(rex,tx,20+i);
            }
        }
    }

    /**
     * Run the traffic benchmark.
     */

    private static String trafficRe;
    static {
        String prop = "\"[a-z_]+\":(\"[^\\\"]*\"|[a-z_]+)";
        String props = "(\"[a-z_]+\":(\"[^\\\"]*\"|\\[[^\\]]*\\]|[a-z_]+)(,)?)*";
        String propn = "\"[a-z_]+\":\\{" + props + "}";
        String propsn = "\\{" + props + "\\}";
        String udpdns = "\"[a-z_]+\":" + propsn;
        String udpdnsstar = "(" + udpdns + "(,)?)*";
        String layers = "\"[a-z_]+\":\\{" + udpdnsstar + "\\}";
        String head = "(" + prop + ",){8}";
        String line = "\\{" + head + layers + "\\}";
        String rex = "(" + line + "\n)*";
        trafficRe = rex;
    }
    
    private static void testTraffic(){
        benchName = "traffic";
        
        re = new ReParallel();
        String rex = trafficRe;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s |%s|\n",re.cursor,rex);
            return;
        }
        showFa(rex);

        String text = null;
        Path filePath = null;
        try {
            filePath = Path.of("traffic.json");
            text = Files.readString(filePath);
        } catch (IOException exc){
            System.out.printf("error on file %s\n",filePath);
            System.exit(1);
        }

        int[] lengths = new int[]{1572638,3166866,4762805,7971861,9578522,11182240};
        if (options.contains("bench")){
            measureBench(rex,text,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }

        if (options.contains("seq")){
            runSequential(rex,text,benchName);
        }

        if (options.contains("par")){
            runParallel(rex,text,benchName);
        }
        if (options.contains("ri-dfa")){
            runParallelMeDfa(rex,text,benchName);
        }

        if (optionContains("m-")){
            timeCompareHeader();
            int idx = 0;
            int start = idx;
            l: for (int i = 0; i < 20; i++){
                int st = idx;
                for (int j = 0; j < 1000; j++){
                    idx = text.indexOf('\n',idx+1);
                    if (idx < 0) break l;
                }
                int end = idx + 1;
                String tx = text.substring(start,end);
                timeCompare(rex,tx,i);
            }
        }
        
        /*
        for (int i = 0; i < re.groupNumbers.length; i++){
            Trc.out.printf("---group %s--------\n",i);
            List<Match> offs = re.getMatches(new Match(0,text.length()+1),i);
            if (offs != null){
                for (Offsets o : offs){
                    Trc.out.printf("-----------\n");
                    Trc.out.printf("%s-%s |%s|\n",o.start,o.end,text.substring(o.start,o.end));
                }
            }
        }
        */
    }

    /**
     * Run the Bible benchmark.
     */

    private static String bibleRe;
    static {
        String h3 = "(<h3\\ id=\"[^\\\"]*\">)";
        String rex = "(.|\n)*" + h3 + "(.|\n)*";
        bibleRe = rex;
    }
    
    private static void testBible(){
        benchName = "bible";
        
        re = new ReParallel();

        String text = null;
        Path filePath = null;
        try {
            filePath = Path.of("bible.html");
            text = Files.readString(filePath);
        } catch (IOException exc){
            System.out.printf("error on file %s\n",filePath);
            System.exit(1);
        }

        String rex = bibleRe;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        showFa(rex);

        int[] lengths = new int[]{1500000,2000000,2500000,3000000,3500000,4000000};
        if (options.contains("bench")){
            measureBench(rex,text,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }

        if (options.contains("seq")){
            runSequential(rex,text,benchName);
        }

        if (options.contains("par")){
            runParallel(rex,text,benchName);
        }
        if (options.contains("ri-dfa")){
            runParallelMeDfa(rex,text,benchName);
        }

        /*
        List<Match> offs = re.getMatches(null,2);
        if (offs != null){
            for (Match o : offs){
                Trc.out.printf("-----------\n");
                Trc.out.printf("%s-%s |%s|\n",o.start,o.end,text.substring(o.start,o.end));
                List<Match> id = re.getMatches(o,3);
                for (Match mo : id){
                    Trc.out.printf("%s-%s |%s|\n",mo.start,mo.end,text.substring(mo.start,mo.end));
                }
            }
        }
        */

        if (optionContains("m-")){
            timeCompareHeader();
            for (int i = 0; i < 20; i++){
                int end = (i+1)*500000;
                if (end > text.length()) end = text.length();
                String tx = text.substring(0,end);
                timeCompare(rex,tx,i);
                if (end == text.length()) break;
            }
        }
    }

    /**
     * Run the parametric RE benchmark.
     */

    /*
    private static String paramRe;
    static {
        paramRe = "(a|b)* a (a|b){9}";
    }

    private static void testParam(){
        benchName = "param";
        re = new ReParallel();
        String rex = paramRe;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        showFa(rex);

        StringBuilder sb = new StringBuilder();
        quasiRandom(sb,10000);
        String text = sb.toString();

        int[] lengths = new int[]{1000,2000,3000,4000,5000,6000};
        if (options.contains("bench")){
            measureBench(rex,text,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }

        if (options.contains("seq")){
            runSequential(rex,text,benchName);
        }
        if (options.contains("par")){
            runParallel(rex,text,benchName);
        }
        if (options.contains("ri-dfa")){
            runParallelMeDfa(rex,text,benchName);
        }

        if (optionContains("m-")){
            timeCompareHeader();
            for (int i = 0; i < 20; i++){
                int end = (i+1)*(text.length/20);
                if (end > text.length()) end = text.length();
                String tx = text.substring(0,end);
                timeCompare(rex,tx,i);
                if (end == text.length()) break;
            }
        }
    }
    */

    /**
     * Run the ReGen benchmark.
     */

    /*
     * This is a picture of the values in the benchmark:
     *
     *  REs                   ,-------------texts buckets------------------------,
     *            RE lenghts  length 0..99    length 100..199      length 900..999
     *  bucket 0  0..9        text bucket 0   text bucket 1 ...    text bucket 9
     *     0.0                0.0.0           0.0.1                0.0.9
     *     0.1                0.1.0           0.1.1                0.1.9
     *     ...                ...             ...                  ...
     *     0.99               0.99.0          0.99.1               0.99.9
     *  bucket 1  10..19
     *     1.0                1.0.0           1.0.1                1.0.9
     *     1.1                1.1.0           1.1.1                1.1.9
     *     ...                ...             ...                  ...
     *     1.99               1.99.0          1.99.1               1.99.9
     *  ...
     *  bucket 9  90..99
     *
     * I.e. It has 1000 REs, subdivided in 10 groups (buckets) of 100, by increasing lengths
     * (0:9,10:19,...).
     * Each RE has 100 texts, also subdivided in 10 groups (buckets), by increasing lengths
     * (0:99,100:199,...).
     * All REs have all the form (...)*  so as to allow to concatenate texts to obtain
     * longer texts.
     * Since texts in buckets are short, longer texts are built with them by concatenating
     * all texts in a same bucket, cycling and repeating until the desired length is reached.
     * This produces a text for each bucket; to generate several texts we do the same, but
     * on different text buckets, obtaining texts of different lengths.
     *
     * We can take a RE bucket, and an interval of text lengths, i.e. text buckets, and for
     * each text bucket build one text, parse it, and do the same for all the REs in the RE
     * bucket, and then repeat for all the text buckets.
     * This means 100*10*9 = 9000 parses, which is quite a lot.
     * Let's then take only the upper 6 RE buckets, and only the first 10 REs in them,
     * and for them, the last 6 text bucket, and concatenate the texts in them 1000 times.
     * For each RE we run the parallel parser measuring the parse time for increasing number
     * of threads.
     * We then sum the times of the parses of a same text bucket and a same number of threads
     * for all the REs. This produces a chart that represents the speedup of a large number
     * of REs.
     *
     * There are applications in which there are several REs, and a need to locate in a larger
     * text all occurrences of texts of any RE. This can be obtained by building a RE that
     * is the union of all. The problem is that the DFA could become large.
     */  

    /** The numeric suffix of the generated sample and chart files. */
    private static final String SNUMBER = "4";

    /** The name of the samples file. */
    private static final String SAMPLES = "samples" + SNUMBER + ".ser";

    /** The number of parsing or recognizions done. */
    private static int nrRuns;

    private static void testReGen(){
        benchName = "regen";
        
        String[][] res = new String[10][];
        String[][][][] texts = new String[res.length][][][];

        try {
            FileInputStream fileIn = new FileInputStream(SAMPLES);
            ObjectInputStream in = new ObjectInputStream(fileIn);
            res = (String[][])in.readObject();
            texts = (String[][][][])in.readObject();
            in.close();
            fileIn.close();
            // System.out.printf("benchmark samples read, file index: %s\n",SNUMBER);
        } catch(FileNotFoundException exc){
            System.out.printf("samples not found\n");
        } catch(IOException exc){
            exc.printStackTrace();
            System.out.printf("%s\n",exc);
            System.exit(1);
        } catch(ClassNotFoundException c){
            System.out.printf("samples not found\n");
            System.exit(1);
        }

        // show the size of the corpus
        /*
        System.out.printf("serialized REs\n");
        System.out.printf("REs buckets %s\n",res.length);
        System.out.printf("REs in each bucket %s\n",res[0].length);
        int n = 0;
        for (int i = 0; i < res.length; i++){
            n += res[i].length;
        }
        System.out.printf("total REs %s\n",n);
        System.out.printf("texts for RE buckets %s each %s buckets %s in each bucket %s\n",
            texts.length,texts[0].length,texts[0][0].length,texts[0][0][0].length);
        n = 0;
        for (int i = 0; i < texts.length; i++){
            for (int j = 0; j < texts[i].length; j++){
                for (int k = 0; k < texts[i][j].length; k++){
                    n += texts[i][j][k].length;
                }
            }
        }
        System.out.printf("total texts %s\n",n);
        for (int i = 0; i < res.length; i++){
            double len = 0;
            n = 0;
            for (int j = 0; j < res[i].length; j++){    // visit REs of bucket i
                int l = res[i][j].length();
                if (l > 0){
                    len += l;
                    n++;
                }
            }
            System.out.printf("RE bucket %s, REs: %s,lengths %s:%s ave RE length %.2f\n",
                i,n,i*10,(i+1)*10-1,len/n);
            for (int k = 0; k < texts[0][0].length; k++){   // visit all texts of bucket k
                n = 0;
                len = 0;
                for (int j = 0; j < texts[i].length; j++){
                    for (int l = 0; l < texts[i][j][k].length; l++){
                        int ln = texts[i][j][k][l].length();
                        if (ln > 0){
                            len += ln;
                            n++;
                        }
                    }
                }
                System.out.printf("    text bucket %s, texts: %s,lengths %s:%s ave text length %.2f\n",
                    k,n,k*100,(k+1)*100-1,len/n);
            }
        }
        */

        if (options.contains("fa")){
            int nfanr = 0;
            int dfanr = 0;
            int medfanr = 0;
            int medfaininr = 0;
            for (int i = 0; i < res.length; i++){
                for (int k = 0; k < res[i].length; k++){
                    String rex = res[i][k];
                    rex = rex.replaceAll("\\[","(");
                    rex = rex.replaceAll("\\]",")?");
                    ReParallel re = new ReParallel();
                    ReParallel reDfa = new ReParallel();
                    if (!re.compile(rex)){
                        System.out.printf("testReGen %s compile error at: %s\n",rex,re.cursor);
                        continue;
                    }
                    if (meDfaVsDfa){
                        re.compile(rex,ReParallel.MIN_ME_DFA);
                        reDfa.compile(rex,ReParallel.DFA);
                    }
                    Trc.out.printf("RE length %s states nfa %s dfa %s revdfa %s ri-dfa %s rev-ri-dfa %s\n",
                        rex.length(),re.nfa.stateNr,re.dfa.strictStateNr,re.revdfa.strictStateNr,re.dfa.stateNr,re.revdfa.stateNr);
                    nfanr += re.nfa.stateNr;
                    dfanr += reDfa.dfa.strictStateNr;
                    medfanr += re.dfa.stateNr;
                    medfaininr += re.dfa.start1.length;
                }
            }
            if (meDfaVsDfa){
                Trc.out.printf("states nfa %s ri-dfa %s minimized initial %s dfa %s\n",
                    nfanr,medfanr,medfaininr,dfanr);
            }
        }            

        ben: if (options.contains("bench")){
            if (dfaTrans){
                measureTransRegen(res,texts);
                break ben;
            }
            // visit the upper REGEN_TEXT_BUCKETS Re buckets
            long[][] accres = new long[REGEN_TEXT_BUCKETS][];           // accumulated times for text lenghts and threads
            for (int j = 0; j < accres.length; j++){
                accres[j] = new long[CORE_STEPS+1];
            }
            long[][] rlenres = new long[REGEN_TEXT_BUCKETS][];          // accumulated times for RE lenghts and threads
            for (int j = 0; j < rlenres.length; j++){
                rlenres[j] = new long[CORE_STEPS+1];
            }

            long[][] accresDfa = null;
            long[][] accresNfa = null;
            long[][] rlenresDfa = null;
            long[] accNtrRi = null;           // accumulated number of transitions for RI-DFA
            long[] accNtrDfa = null;          // accumulated number of transitions for DFA
            long[] accNtrNfa = null;          // accumulated number of transitions for NFA

            if (meDfaVsDfa){
                nrRuns = 0;
                accresDfa = new long[REGEN_TEXT_BUCKETS][];           // accumulated times for text lenghts and threads
                for (int j = 0; j < accresDfa.length; j++){
                    accresDfa[j] = new long[CORE_STEPS+1];
                }
                accresNfa = new long[REGEN_TEXT_BUCKETS][];           // accumulated times for text lenghts and threads
                for (int j = 0; j < accresNfa.length; j++){
                    accresNfa[j] = new long[CORE_STEPS+1];
                }
                accNtrRi = new long[REGEN_TEXT_BUCKETS];
                accNtrDfa = new long[REGEN_TEXT_BUCKETS];
                accNtrNfa = new long[REGEN_TEXT_BUCKETS];
            }
            for (int i = 4; i < 4+REGEN_RE_BUCKETS; i++){
                #ifdef DEBUG
                Trc.out.printf("\nregen parallel parsing for RE bucket %s\n",i);
                #endif
                // for each produce a matrix of data with a column for each thread and
                // a row for each length
                int z = 0;
                for (int k = 0; k < res[i].length; k++){
                    long[][] val = new long[REGEN_TEXT_BUCKETS][];
                    for (int j = 0; j < val.length; j++){
                        val[j] = new long[CORE_STEPS+1];
                    }
                    long[][] valDfa = null;
                    long[][] valNfa = null;
                    long[] valNtrRi = null;
                    long[] valNtrDfa = null;
                    long[] valNtrNfa = null;
                    if (meDfaVsDfa){
                        valDfa = new long[REGEN_TEXT_BUCKETS][];
                        for (int j = 0; j < valDfa.length; j++){
                            valDfa[j] = new long[CORE_STEPS+1];
                        }
                        valNfa = new long[REGEN_TEXT_BUCKETS][];
                        for (int j = 0; j < valNfa.length; j++){
                            valNfa[j] = new long[CORE_STEPS+1];
                        }
                        valNtrRi = new long[REGEN_TEXT_BUCKETS];
                        valNtrDfa = new long[REGEN_TEXT_BUCKETS];
                        valNtrNfa = new long[REGEN_TEXT_BUCKETS];
                    }
                    #ifdef DEBUG
                    Trc.out.printf("  parsings for RE bucket %s %s-th RE: %s\n",i,k,res[i][k]);
                    #endif
                    if (measureBenchRegen(res[i][k],texts[i][k],val,valDfa,valNfa,
                        valNtrRi,valNtrDfa,valNtrNfa)){
                        for (int j = 0; j < val.length; j++){
                            for (int l = 0; l < val[j].length; l++){
                                accres[j][l] += val[j][l];
                            }
                        }
                        for (int j = 0; j < val.length; j++){
                            for (int l = 0; l < val[j].length; l++){
                                rlenres[i-4][l] += val[j][l];
                            }
                        }
                        if (meDfaVsDfa){
                            for (int j = 0; j < valDfa.length; j++){
                                for (int l = 0; l < valDfa[j].length; l++){
                                    accresDfa[j][l] += valDfa[j][l];
                                }
                            }
                            for (int j = 0; j < valNfa.length; j++){
                                for (int l = 0; l < valNfa[j].length; l++){
                                    accresNfa[j][l] += valNfa[j][l];
                                }
                            }
                            for (int j = 0; j < valNtrRi.length; j++){
                                accNtrRi[j] += valNtrRi[j];
                            }
                            for (int j = 0; j < valNtrDfa.length; j++){
                                accNtrDfa[j] += valNtrDfa[j];
                            }
                            for (int j = 0; j < valNtrNfa.length; j++){
                                accNtrNfa[j] += valNtrNfa[j];
                            }
                            #ifdef DEBUG
                            Trc.out.printf("  acc\n    ri-dfa %s\n    dfa %s\n    nfa %s\n",
                                arrToString(accres),arrToString(accresDfa),arrToString(accresNfa));
                            Trc.out.printf("  accNtr\n    ri-dfa %s\n    dfa %s\n    nfa %s\n",
                                Arrays.toString(accNtrRi),Arrays.toString(accNtrDfa),Arrays.toString(accNtrNfa));
                            #endif
                        }
                        z++;
                        if (z >= REGEN_RES) break;
                    }
                    #ifdef DEBUG
                    Trc.out.printf("    done\n");
                    #endif
                }
            }
            #ifdef DEBUG
            Trc.out.printf("done, computing speedup\n");
            #endif
            // now we have in accres all the parse times
            if (meDfaVsDfa){
                Trc.out.printf("\nRI-DFA comparison with deterministic MEFA\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf(" %sK",(400+j*100)*regenTextRep);
                }
                Trc.out.printf("\n");
                Trc.out.printf("x  y  z\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf("\n");
                    for (int l = 1, th = 2; l < accres[j].length; l++, th += CORE_STEP){
                        Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                            (double)accresDfa[j][l]/(double)accres[j][l]);
                    }
                }
                Trc.out.printf("\n");
                Trc.out.printf("\nRI-DFA comparison with nondeterministic MEFA\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf(" %sK",(400+j*100)*regenTextRep);
                }
                Trc.out.printf("\n");
                Trc.out.printf("x  y  z\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf("\n");
                    for (int l = 1, th = 2; l < accres[j].length; l++, th += CORE_STEP){
                        Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                            (double)accresNfa[j][l]/(double)accres[j][l]);
                    }
                }
                Trc.out.printf("\n");
                Trc.out.printf("regen RI-DFA comparison with det. MEFA transitions");
                for (int j = 0; j < accNtrRi.length; j++){
                    Trc.out.printf("\t& %.2f",
                        (double)accNtrDfa[j]/accNtrRi[j]);
                }
                Trc.out.printf("\n");
                Trc.out.printf("regen RI-DFA comparison with nondet. MEFA transitions");
                for (int j = 0; j < accNtrRi.length; j++){
                    Trc.out.printf("\t& %.2f",
                        (double)accNtrNfa[j]/accNtrRi[j]);
                }
                Trc.out.printf("\n");
                //Trc.out.printf("nr of recognizions %s\n",nrRuns);
            } else {
                Trc.out.printf("\nReGen parallel parsing\n");
                Trc.out.printf("\nspeedup by text length and threads\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf(" %sK",(400+j*100)*regenTextRep);
                }
                Trc.out.printf("\n");
                Trc.out.printf("x  y  z\n");
                for (int j = 0; j < accres.length; j++){
                    Trc.out.printf("\n");
                    for (int l = 1, th = 2; l < accres[j].length; l++, th += CORE_STEP){
                        if (meDfaVsDfa){
                            Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                                (double)accresDfa[j][l]/(double)accres[j][l]);
                        } else {
                            Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                                (double)accres[j][0]/(double)accres[j][l]);
                        }
                    }
                }
                Trc.out.printf("\n");
                Trc.out.printf("\nspeedup by RE length and threads\n");
                // now we have in rlenres all the parse times
                for (int j = 0; j < rlenres.length; j++){
                    Trc.out.printf(" %s",40+j*10);
                }
                for (int j = 0; j < rlenres.length; j++){
                    Trc.out.printf("\n");
                    for (int l = 1, th = 2; l < rlenres[j].length; l++, th += CORE_STEP){
                        if (meDfaVsDfa){
                            Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                                (double)rlenresDfa[j][l]/(double)rlenres[j][l]);
                        } else {
                            Trc.out.printf("%-3s%-3s%.2f\n",th,j+1,
                                (double)rlenres[j][0]/(double)rlenres[j][l]);
                        }
                    }
                }
            }
        }
        if (options.contains("data")){
            int[] lengths = new int[REGEN_TEXT_BUCKETS];
            int relen = 0;
            int nr = 0;
            for (int i = 4; i < 4+REGEN_RE_BUCKETS; i++){
                for (int k = 0; k < res[i].length; k++){
                    relen += res[i][k].length();
                    nr++;
                }
            }
            for (int j = 0; j < 6; j++){
                lengths[j] = ((400+j*100)*regenTextRep)*1000;
            }
            benchData(benchName,lengths,relen/nr);
        }
        if (optionContains("m-")){
            String text = null;
            timeCompareHeader();
            String rex = res[4][0];
            rex = rex.replaceAll("\\[","(");
            rex = rex.replaceAll("\\]",")?");
            text = rep(texts[4][0][4],100);
            timeCompare(rex,text,0);
        }
    }

    /**
     * Parse the specified RE for the specified text buckets for an increasing number
     * of threads, and record the parse times.
     *
     * @param      rex RE
     * @param      text buckets
     * @param      res resulting parse times with RI-DFA
     * @param      resDfa resulting parse times with DFA
     * @param      resNfa resulting parse times with NFA
     * @param      valNtrRi resulting number of transitions with RI-DFA
     * @param      valNtrDfa resulting number of transitions with DFA
     * @param      valNtrNfa resulting number of transitions with NFA
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    static boolean measureBenchRegen(String rex, String[][] texts, long[][] res,
        long[][] resDfa, long[][] resNfa, long[] valNtrRi, long[] valNtrDfa, long[] valNtrNfa){
        if (meDfaVsDfa){
            return measureBenchRegenMeDfa(rex,texts,res,resDfa,resNfa,
                valNtrRi,valNtrDfa,valNtrNfa);
        }
        rex = rex.replaceAll("\\[","(");
        rex = rex.replaceAll("\\]",")?");
        ReParallel re = new ReParallel();
        if (!re.compile(rex)){
            System.out.printf("measureBenchRegen %s compile error at: %s\n",rex,re.cursor);
            return false;
        }
        for (int j = 0; j < REGEN_TEXT_BUCKETS; j++){
            String tx = rep(texts[j+4],100*regenTextRep);
            #ifdef DEBUG
            Trc.out.printf("    text bucket %s text len %s\n",j+4,tx.length());
            #endif
            long tm1 = 0;
            for (int k = 0; k < REP_MEA; k++){
                long t1 = System.nanoTime();
                #ifdef SIMULATE
                boolean b = re.matchParSim(tx,1);
                #else
                boolean b = re.matchPar(tx,1,false);
                #endif
                if (!b){
                    String str = (re.cursor + 30) < tx.length() ?
                        tx.substring(re.cursor,re.cursor + 30) :
                        tx.substring(re.cursor,tx.length());
                    System.out.printf("measureBench len %s 1 not matched at: %s: |%s|\n",
                        tx.length(),re.cursor,str);
                    return false;
                }
                #ifdef SIMULATE
                ReParallel.Measure mea = re.measure;
                tm1 += (mea.timePar[REGEN_TEXT_BUCKETS]-mea.timePar[0]);
                #else
                long t2 = System.nanoTime();
                tm1 += (t2-t1);
                #endif
                // discard REs that need a hash table for dags: they have long parse times
                int longs = 0;
                for (int i = 0; i < re.dag.length; i++){
                    if (re.dag[i] < 0) longs++;
                }
                if ((double)longs/re.dag.length > 0.1){
                    // System.out.printf("!!! long rate %.2f\n",(double)longs/re.dag.length);
                    return false;
                }
            }
            tm1 /= REP_MEA;
            res[j][0] = tm1;
            #ifdef DEBUG
            Trc.out.printf("    serial time %s\n",tm1/1000000);
            #endif

            int p = 1;
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifdef SIMULATE
                    boolean b = re.matchParSim(tx,i);
                    #else
                    boolean b = re.matchPar(tx,i,false);
                    #endif
                    if (!b){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s P %s not matched at: %s: |%s|\n",
                            tx.length(),i,re.cursor,str);
                        return false;
                    }
                    #ifdef SIMULATE
                    tm0 += simTime(re.measure);
                    #else
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                    #endif
                }
                tm0 /= REP_MEA;
                res[j][p++] = tm0;
                #ifdef DEBUG
                Trc.out.printf("    parallel threads %s time %s speedup %.2f\n",
                    i,tm0/1000000,((double)tm1/(double)tm0));
                #endif
            }
        }
        return true;
    }

    /**
     * Parse the specified RE for the specified text buckets for an increasing number
     * of threads, and record the recognizion times.
     *
     * @param      rex RE
     * @param      text buckets
     * @param      res resulting parse times with RI-DFA
     * @param      resDfa resulting parse times with DFA
     * @param      resNfa resulting parse times with NFA
     * @param      valNtrRi resulting number of transitions with RI-DFA
     * @param      valNtrDfa resulting number of transitions with DFA
     * @param      valNtrNfa resulting number of transitions with NFA
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

     /*
      * res is indexed with text slots: for each slot it has a vector, indexed with cores
      * that contains the time
      */

    static boolean measureBenchRegenMeDfa(String rex, String[][] texts, long[][] res,
        long[][] resDfa, long[][] resNfa, long[] valNtrRi, long[] valNtrDfa, long[] valNtrNfa){
        rex = rex.replaceAll("\\[","(");
        rex = rex.replaceAll("\\]",")?");
        ReParallel re = new ReParallel();
        if (!re.compile(rex,ReParallel.MIN_ME_DFA)){
            System.out.printf("measureBenchRegen ri-dfa %s compile error at: %s\n",rex,re.cursor);
            return false;
        }
        ReParallel reDfa = new ReParallel();
        if (!reDfa.compile(rex,ReParallel.DFA)){
            System.out.printf("measureBenchRegen dfa %s compile error at: %s\n",rex,reDfa.cursor);
            return false;
        }
        ReParallel reNfa = new ReParallel();
        if (!reNfa.compile(rex,ReParallel.NFA)){
            System.out.printf("measureBenchRegen nfa %s compile error at: %s\n",rex,reDfa.cursor);
            return false;
        }
        for (int j = 0; j < REGEN_TEXT_BUCKETS; j++){
            String tx = rep(texts[j+4],100*regenTextRep);
            #ifdef DEBUG
            Trc.out.printf("    text bucket %s text len %s\n",j+4,tx.length());
            #endif
            long totlenRi = 0;

            int p = 1;
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    boolean b = re.recPar(tx,i);
                    if (!b){
                        String str = (re.cursor + 30) < tx.length() ?
                            tx.substring(re.cursor,re.cursor + 30) :
                            tx.substring(re.cursor,tx.length());
                        System.out.printf("measureBench len %s P %s not matched at: %s: |%s|\n",
                            tx.length(),i,re.cursor,str);
                        return false;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                }
                tm0 /= REP_MEA;
                res[j][p++] = tm0;
                #ifdef DEBUG
                Trc.out.printf("    RI-DFA parallel threads %s time %s trans %s\n",
                    i,tm0/1000000,transitions(re));
                #endif
                totlenRi += transitions(re);          // total transitions reachers
                if (i == CORE_NTRANS){
                    valNtrRi[j] += transitions(re);          // total transitions reachers
                }
                nrRuns++;
            }

            long totlenDfa = 0;
            p = 1;
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    boolean b = reDfa.recPar(tx,i);
                    if (!b){
                        String str = (reDfa.cursor + 30) < tx.length() ?
                            tx.substring(reDfa.cursor,reDfa.cursor + 30) :
                            tx.substring(reDfa.cursor,tx.length());
                        System.out.printf("measureBench len %s P %s not matched at: %s: |%s|\n",
                            tx.length(),i,reDfa.cursor,str);
                        return false;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                }
                tm0 /= REP_MEA;
                resDfa[j][p++] = tm0;
                #ifdef DEBUG
                Trc.out.printf("    DFA parallel threads %s time %s trans %s\n",
                    i,tm0/1000000,transitions(reDfa));
                #endif
                totlenDfa += transitions(reDfa);    // total transitions reachers
                if (i == CORE_NTRANS){
                    valNtrDfa[j] += transitions(reDfa);          // total transitions reachers
                }
                nrRuns++;
            }

            // use the nfa
            p = 1;
            for (int i = 2; i < CORE_MAX; i += CORE_STEP){
                long tm0 = 0;
                for (int k = 0; k < REP_MEA; k++){
                    long t1 = System.nanoTime();
                    #ifndef DRY_RUN
                    boolean b = reNfa.recParNfa(tx,i);
                    if (!b){
                        String str = (reNfa.cursor + 30) < tx.length() ?
                            tx.substring(reNfa.cursor,reNfa.cursor + 30) :
                            tx.substring(reNfa.cursor,tx.length());
                        System.out.printf("NFA measureBenchMeDfa len %s P %s not matched at: %s: |%s|\n",
                            tx.length(),i,reNfa.cursor,str);
                        return false;
                    }
                    #endif
                    long t2 = System.nanoTime();
                    tm0 += (t2-t1);
                }
                tm0 /= REP_MEA;
                resNfa[j][p++] = tm0;
                #ifdef DEBUG
                Trc.out.printf("    NFA parallel threads %s time %s trans %s\n",
                    i,tm0/1000000,transitions(reNfa));
                #endif
                if (i == CORE_NTRANS){
                    valNtrNfa[j] += transitions(reNfa);          // total transitions reachers
                }
                nrRuns++;
            }
        }
        #ifdef DEBUG
        Trc.out.printf("  res\n    ri-dfa %s\n    dfa %s\n    nfa %s\n",
            arrToString(res),arrToString(resDfa),arrToString(resNfa));
        #endif
        return true;
    }

    private static String arrToString(long[][] arr){
        StringBuilder sb = new  StringBuilder();
        sb.append("[");
        for (int i = 0; i < arr.length; i++){
            sb.append("[");
            for (int j = 0; j < arr[i].length; j++){
                sb.append(" " + arr[i][j]);
            }
            sb.append("]");
        }
        sb.append("]");
        return sb.toString();
    }

    static void measureTransRegen(String[][] res, String[][][][] texts){
        ReParallel reDfa = new ReParallel();
        ReParallel reDfab = new ReParallel();
        ReParallel reDfaMmefa = new ReParallel();
        ReParallel reDfaMmefab = new ReParallel();
        long totlenDfa = 0;
        long totlenDfab = 0;
        long totlenDfaMmefa = 0;
        long totlenDfaMmefab = 0;
        int nrRuns = 0;

        int startRei = 8;
        int startRek = 98;
        int startTextj = 6;
        for (int i = startRei; i < res.length; i++){
            for (int k = startRek; k < res[i].length; k++){
                String rex = res[i][k];
                if (rex.length() == 0) continue;
                Trc.out.printf("regen %s %s\n",i,k);
                rex = rex.replaceAll("\\[","(");
                rex = rex.replaceAll("\\]",")?");
                if (!reDfa.compile(rex,ReParallel.DFA)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
                    continue;
                }
                if (!reDfab.compile(rex,ReParallel.DFA_B)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
                    continue;
                }
                if (!reDfaMmefa.compile(rex,ReParallel.MIN_ME_DFA)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
                    continue;
                }
                if (!reDfaMmefab.compile(rex,ReParallel.MIN_ME_DFA_B)){
                    System.out.printf("measureBenchMeDfa compile error at: %s\n",reDfa.cursor);
                    continue;
                }
                for (int j = startTextj; j < texts[i][k].length; j++){
                    for (int l = 0; l < texts[i][k][j].length; l++){
                        String tx = rep(texts[i][k][j],100*regenTextRep);
                        Trc.out.printf("   %s %s %s\n",j,l,tx.length());
                        totlenDfa += measureTransRegenRec(reDfa,tx,ReParallel.DFA,i,j);
                        nrRuns++;
                        totlenDfab += measureTransRegenRec(reDfab,tx,ReParallel.DFA_B,i,j);
                        nrRuns++;
                        totlenDfaMmefa += measureTransRegenRec(reDfaMmefa,tx,ReParallel.MIN_ME_DFA,i,j);
                        nrRuns++;
                        totlenDfaMmefab += measureTransRegenRec(reDfaMmefab,tx,ReParallel.MIN_ME_DFA_B,i,j);
                        nrRuns++;
                    }
                }
            }
        }
        Trc.out.printf("bench\t dfa-b \tminmefa\tminmefa-b\n");
        Trc.out.printf("regen\t %.2f \t %.2f \t %.2f\n",
            (double)totlenDfab/(double)totlenDfa,
            (double)totlenDfaMmefa/(double)totlenDfa,
            (double)totlenDfaMmefab/(double)totlenDfa);
        Trc.out.printf("nr of recognizions %s\n",nrRuns);
    }
    static long measureTransRegenRec(ReParallel reDfa, String tx, int kind, int i, int j){
        int c = CORE_NTRANS;        // number of cores (chunks)
        #ifndef DRY_RUN
        if (!reDfa.recPar(tx,c)){
            String str = (reDfa.cursor + 30) < tx.length() ?
                tx.substring(reDfa.cursor,reDfa.cursor + 30) :
                tx.substring(reDfa.cursor,tx.length());
            System.out.printf("regen measureBenchTrans %s %s,%s not matched at: %s: |%s|\n",
                kind,i,j,reDfa.cursor,str);
            return 0;
        }
        #endif
        long totlenDfa = transitions(reDfa);    // total transitions reachers
        // Trc.out.printf("---%s kind %s len %s initials %s trans %s\n",benchName,kind,j,reDfa.measure.initialStates,totlenDfa);
        return totlenDfa;
    }

    // trace the measures of a recognizion
    private static void traceRecognizion(String re, int kind, String text, int nc){
        ReParallel r = new ReParallel();
        if (!r.compile(re,kind)){
            Trc.out.printf("compilation error\n");
            return;
        }
        if (!r.recPar(text,nc)){
            Trc.out.printf("not recognized\n");
        }
        r.measure.trace();
    }

    /**
     * Run the (a|b)*a(a|b){6} benchmark.
     */

    private static String ex1Re = "(a|b)*a(a|b){6}";
    
    private static void testEx1(){
        benchName = "ex1";
        
        re = new ReParallel();

        String text = null;

        String rex = ex1Re;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        showFa(rex);

        int[] lengths = new int[]{1000000,2000000,3000000,4000000,5000000,6000000};
        if (options.contains("bench")){
            String[] texts = new String[6];
            for (int i = 0; i < 6; i++){
                StringBuilder sb = new StringBuilder();
                quasiRandom(sb,1000000*(i+1));
                sb.append('a');
                quasiRandom(sb,6);
                quasiRandom(sb,10);
                texts[i] = sb.toString();
            }
            measureBenchMeDfa(rex,null,texts,lengths,"ex1");
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }
    }
    
    /**
     * Appendo to the specified string builder a string of (quasi) random a's and b's.
     *
     * @param   sb string builder
     * @param   n length of the string
     */

    static void quasiRandom(StringBuilder sb, int n){
        for (int i = 1; i <= n; i++){
            String s = Double.toString(Math.log(i));
            char c = s.charAt(s.length()-1);
            // Trc.out.printf("%s\n",c >= '5' ? "a" : "b");
            sb.append(c >= '5' ? "a" : "b");
        }
    }

    /**
     * Run the (a|b)*b(a|b){10}b(a|b)* benchmark.
     */

    private static String ex2Re = "(a|b)*b(a|b){6}b(a|b)*";
    
    private static void testEx2(){
        benchName = "ex2";
        
        re = new ReParallel();

        String text = null;

        String rex = ex2Re;

        if (!re.compile(rex)){
            System.out.printf("compile error at: %s\n",re.cursor);
            return;
        }
        showFa(rex);

        int[] lengths = new int[]{200000,400000,600000,800000,1000000,1200000};
        if (options.contains("bench")){
            String[] texts = new String[6];
            for (int i = 0; i < 6; i++){
                StringBuilder sb = new StringBuilder();
                quasiRandom(sb,100000*i);
                sb.append('b');
                sb.append("abaabbbbaa");
                sb.append('b');
                quasiRandom(sb,100000*i);
                texts[i] = sb.toString();
            }
            measureBenchMeDfa(rex,null,texts,lengths,benchName);
        }
        if (options.contains("data")){
            benchData(benchName,lengths,rex.length());
        }
    }
    
    /**
     * Deliver a string concatenating the ones of the specified bucket for the specified
     * number of times.
     *
     * @param      bucket vector of strings
     * @param      rep number of times
     * @return     string
     */

    private static String rep(String[] bucket, int rep){
        /*
        #ifdef DEBUG
        for (int j = 0; j < bucket.length; j++){
            Trc.out.printf("text bucket %s\n",bucket[j].length());
        }
        #endif
        */
        StringBuffer reptext = new StringBuffer();
        for (int i = 0; i < rep; i++){
            for (int j = 0; j < bucket.length; j++){
                reptext.append(bucket[j]);
            }
        }
        return reptext.toString();
    }

    #ifdef SIMULATE
    /**
     * Deliver the time of the execution of the threads and builders simulating a
     * parallel execution done by a number of threads.
     * number of times.
     *
     * @param      mea measure times and number of threads
     * @return     long time
     */

    private static long simTime(ReParallel.Measure mea){
        long t = mea.timePar[2] - mea.timePar[0] +   // initial
            mea.timePar[4] - mea.timePar[3] +        // sewing
            mea.timePar[6] - mea.timePar[5];         // final
        // compute time of parallel reachers
        long[] buckets = new long[mea.nrThreads];
        for (int i = 0; i < mea.nrChunks; i++){
            long min = Long.MAX_VALUE;
            int idx = 0;
            for (int j = 0; j < buckets.length; j++){
                if (buckets[j] < min){
                    min = buckets[j];
                    idx = j;
                }
            }
            buckets[idx] += mea.timeEndFwd[i] - mea.timeStartFwd[i];
        }
        long max = 0;
        for (int j = 0; j < buckets.length; j++){
            if (buckets[j] > max){
                max = buckets[j];
            }
        }
        t += max;
        
        // compute time of parallel builders
        buckets = new long[mea.nrThreads];
        for (int i = 0; i < mea.nrChunks; i++){
            long min = Long.MAX_VALUE;
            int idx = 0;
            for (int j = 0; j < buckets.length; j++){
                if (buckets[j] < min){
                    min = buckets[j];
                    idx = j;
                }
            }
            buckets[idx] += mea.timeEndBwd[i] - mea.timeStartBwd[i];
        }
        max = 0;
        for (int j = 0; j < buckets.length; j++){
            if (buckets[j] > max){
                max = buckets[j];
            }
        }
        t += max;
        return t;
    }
    #endif

    /**
     * Show the number of states of the fa's of the specified benchmark;
     *
     * @param      bench name of the benchmark
     */

    private static void testFa(String bench){
        re = new ReParallel();
        boolean show = false;
        String res = null;
        switch (bench){
        case "bigdata":
            res = bigdataRe;
            // show = true;
            break;
        case "fasta":
            res = fastaRe;
            break;
        case "traffic":
            res = trafficRe;
            break;
        case "bible":
            res = bibleRe;
            break;
        default:
            res = bench;
            show = true;
        }
        if (!re.compile(res)){
            System.out.printf("compile error\n");
        }
        Trc.out.printf("%s nfa states %s dfa states %s (multi-entry %s) revdfa states %s (multi-entry %s) re-len %s\n",
            bench,re.nfa.stateNr,re.dfa.strictStateNr,re.dfa.stateNr-re.dfa.strictStateNr,
            re.revdfa.strictStateNr,re.revdfa.stateNr-re.revdfa.strictStateNr,res.length());

        if (show){
            /*
            re.nfa.trace();
            Trc.out.printf("%s %s\n",bench,re.nfa.toGraph());
            re.dfa.trace();
            Trc.out.printf("%s %s\n",bench,re.dfa.toGraph());
            re.revdfa.trace();
            Trc.out.printf("%s %s\n",bench,re.revdfa.toGraph());
            */

            /*
            for (int i = 1; i < 10; i++){
                String rex = "(a|b)*a(a|b){"+ i + "}";
                if (!re.compile(rex)){
                    System.out.printf("compile error\n");
                }
                Trc.out.printf("RE: %s\n",rex);
                Trc.out.printf("%s nfa states %s dfa states %s (multi-entry %s) revdfa states %s (multi-entry %s)\n",
                    i,re.nfa.stateNr,re.dfa.strictStateNr,re.dfa.stateNr-re.dfa.strictStateNr,
                    re.revdfa.strictStateNr,re.revdfa.stateNr-re.revdfa.strictStateNr);

                long tm1 = 0;
                int length = 0;
                ReParallel.Measure m = null;
                for (int j = 0; j < REP_MEA; j++){
                    // generate text
                    StringBuffer sb = new StringBuffer();
                    // generate initial part
                    for (int k = 0; k < 1000000; k++){
                        // use different patterns for the 3 cases
                        if (j == 0){
                            sb.append(((k & 1) == 0) ? "ababababab" : "bababababa");
                        } else if (j == 1){
                            sb.append(((k & 1) == 0) ? "aabbbababa" : "bbbababaaa");
                        } else {
                            sb.append(((k & 1) == 0) ? "abbbabaaab" : "babbaababa");
                        }
                    }
                    // add the middle term
                    sb.append("a");
                    // add the trailer
                    for (int k = 0; k < i; k++){
                        sb.append(((k & 1) == 0) ? "a" : "b");
                    }

                    re.compile("(a|b)*a(a|b){"+ i + "}");
                    // perhaps without back sewing
                    length = sb.length();
                    long t1 = System.nanoTime();
                    if (!re.matchPar(sb.toString(),2,false)){
                        Trc.out.printf("rep %s error\n",i);
                    }
                    long t2 = System.nanoTime();
                    tm1 += (t2-t1);
                    m = re.measure;
                }
                tm1 /= REP_MEA;
                double surv = 0;
                if (m != null){
                    // compute the average parses survived in the reachers
                    int tot = 0;
                    for (int k = 0; k < m.parsesSurvived.length; k++){
                        tot += m.parsesSurvived[k];
                    }
                    surv = (double)tot/m.parsesSurvived.length;
                }
                System.out.printf("%s: text length %s elapsed %s ms surv %.2f\n",
                    i,length,tm1/1000000,surv);
            }
            */
        }
    }

    static String paperExampleText(int n){
        StringBuilder sb = new StringBuilder();
        quasiRandom(sb,1000000*(n));
        sb.append('a');
        quasiRandom(sb,6);
        return sb.toString();
    }

    static String stefanoExampleText(int n){
        StringBuilder sb = new StringBuilder();
        quasiRandom(sb,100000*n);
        sb.append('b');
        sb.append("abaabbbbaa");
        sb.append('b');
        quasiRandom(sb,100000*n);
        return sb.toString();
    }

    /**
     * Show the number of states of the specified FA.
     *
     * @param      bench name of the benchmark
     * @param      res re
     * @param      kind king of the FA
     */

    static void showFas(String bench, String res, int kind){
        ReParallel re = new ReParallel();
        if (!re.compile(res,kind)){
            System.out.printf("compile error\n");
        }
        switch (kind){
        case ReParallel.MIN_ME_DFA:
            if (re.dfaKind == ReParallel.MIN_ME_DFA){
                Trc.out.printf("%s initial ri-dfa states %s\n",
                    bench,re.dfa.start1.length);
            } else {
                Trc.out.printf("%s dfa states %s\n",bench,re.dfa.stateNr);
            }
            break;
        case ReParallel.NFA:
            Trc.out.printf("%s nfa states %s\n",bench,re.nfa.stateNr);
            break;
        case ReParallel.DFA:
            Trc.out.printf("%s dfa states %s\n",bench,re.dfa.stateNr);
            break;
        case ReParallel.ME_DFA:
            Trc.out.printf("%s ri-dfa states %s nfa %s dfa %s\n",
                bench,re.dfa.stateNr,re.nfa.stateNr,re.dfa.strictStateNr);
            break;
        }
    }

    static void showFas(String bench, String res){
        showFas(bench,res,ReParallel.MIN_ME_DFA);
        showFas(bench,res,ReParallel.NFA);
        showFas(bench,res,ReParallel.DFA);
    }
    static void showFas(){
        showFas("bigdata",bigdataRe);
        showFas("fasta",fastaRe);
        showFas("traffic",trafficRe);
        showFas("bible",bibleRe);
        showFas("ex1",ex1Re);
        showFas("ex2",ex2Re);
    }

    /**
     * Measure the statistics of regen
     */

    private static void testStatis(){
        String[][] res = new String[10][];
        try {
            FileInputStream fileIn = new FileInputStream(SAMPLES);
            ObjectInputStream in = new ObjectInputStream(fileIn);
            res = (String[][])in.readObject();
            in.close();
            fileIn.close();
            // System.out.printf("benchmark samples read, file index: %s\n",SNUMBER);
        } catch(FileNotFoundException exc){
            System.out.printf("samples not found\n");
        } catch(IOException exc){
            exc.printStackTrace();
            System.out.printf("%s\n",exc);
            System.exit(1);
        } catch(ClassNotFoundException c){
            System.out.printf("samples not found\n");
            System.exit(1);
        }

        double[] steps = new double[]{0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,Double.MAX_VALUE};
        int[] distr = new int[steps.length];    // for population 0.5, 0.6 ... 2.0
        int[] distr1 = new int[steps.length];   // same, for ri-dfa
        int nRe = 0;
        for (int i = 0; i < res.length; i++){
            // Trc.out.printf("re bucket %s\n",i);
            for (int k = 0; k < res[i].length; k++){
                nRe++;
                String rex = res[i][k];
                rex = rex.replaceAll("\\[","(");
                rex = rex.replaceAll("\\]",")?");
                ReParallel reNfa = new ReParallel();
                if (!reNfa.compile(rex,ReParallel.NFA)){
                    System.out.printf("testStatis nfa %s compile error at: %s\n",rex,reNfa.cursor);
                    continue;
                }
                ReParallel reDfa = new ReParallel();
                if (!reDfa.compile(rex,ReParallel.DFA)){
                    System.out.printf("testStatis dfa %s compile error at: %s\n",rex,reDfa.cursor);
                    continue;
                }
                double rate = (double)reNfa.nfa.stateNr/reDfa.dfa.stateNr;
                for (int j = 0; j < steps.length; j++){
                    if (rate <= steps[j]){
                        distr[j]++;
                        break;
                    }
                }
                ReParallel re = new ReParallel();
                if (!re.compile(rex,ReParallel.MIN_ME_DFA)){
                    System.out.printf("testStatis ri-dfa %s compile error at: %s\n",rex,re.cursor);
                    continue;
                }
                rate = (double)re.minMeDfaStartStates/reDfa.dfa.stateNr;
                for (int j = 0; j < steps.length; j++){
                    if (rate <= steps[j]){
                        distr1[j]++;
                        break;
                    }
                }
            }
        }
        Trc.out.printf("distribution of nfa/dfa\n");
        for (int j = 0; j < steps.length; j++){
            if (j == steps.length-1){
                Trc.out.printf(">%.2f %s\n",steps[j-1],distr[j]);
            } else {
                Trc.out.printf("%.2f %s\n",steps[j],distr[j]);
            }
        }
        Trc.out.printf("distribution of ri-dfa/dfa\n");
        for (int j = 0; j < steps.length; j++){
            if (j == steps.length-1){
                Trc.out.printf(">%.2f %s\n",steps[j-1],distr1[j]);
            } else {
                Trc.out.printf("%.2f %s\n",steps[j],distr1[j]);
            }
        }
        Trc.out.printf("nr. of REs %s\n",nRe);
    }

    /**
     * Tell if the options contain one that starts with the specified string.
     *
     * @param      str string
     * @return     <code>true</code> if it does, <code>false</code> otherwise
     */

    static boolean optionContains(String str){
        for (String s : options){
            if (s.startsWith("m-")){
                return true;
            }
        }
        return false;
    }

    /** The name of the current bench. */
    private static String benchName;

    /** The command options. */
    static Set<String> options;

    /** Whether measureBench compares RI-DFA vs DFA recognizion. */
    static boolean meDfaVsDfa = false;

    /** Whether measureBench compares DFA transitions. */
    static boolean dfaTrans = false;


    /**
     * Main program.
     *
     * @param      args vector of the arguments
     */

    public static void main(String[] args){
        Locale.setDefault(Locale.US);
        options = new TreeSet<String>();
        for (int i = 0; i < args.length; i++){
            try {
                regenTextRep = Integer.parseInt(args[i]);
                continue;
            } catch (NumberFormatException exc){
            }
            options.add(args[i]);
        }
        if (options.contains("meDfaVsDfa")){
            meDfaVsDfa = true;
            options.remove("meDfaVsDfa");
        }

        if (options.contains("dfaTrans")){
            dfaTrans = true;
            options.remove("dfaTrans");
        }

        testIntSetBit();
        testHtb();
        test();
        testThreadsChunks();
        if (testErrors > 0){
            System.out.printf("end test %s tests failed\n",testErrors);
            return;
        } else {
            System.out.printf("all tests passed\n");
        }
        if (options.contains("tests")){
            return;
        }
        /*
        if (options.contains("fa")){
            testFa("(a|b)*a(a|b){3}");
            testFa("bigdata");
            testFa("fasta");
            testFa("traffic");
            testFa("bible");
        }
        */
        if (options.contains("fa")){
            testBigData();
            testFasta();
            testTraffic();
            testBible();
        }
        if (options.contains("bigdata")){
            testBigData();
        }
        if (options.contains("fasta")){
            testFasta();
        }
        if (options.contains("traffic")){
            testTraffic();
        }
        if (options.contains("bible")){
            testBible();
        }
        if (options.contains("regen")){
            testReGen();
        }
        if (options.contains("ex1")){
            testEx1();
        }
        if (options.contains("ex2")){
            testEx2();
        }

        if (options.contains("cores")){
            CORE_STEP = 4;
            options.clear();
        }
        /*
        if (!options.contains("bigdata") && !options.contains("fasta") &&
            !options.contains("traffic") && !options.contains("bible") &&
            !options.contains("regen")){
            testBigData();
            testFasta();
            testTraffic();
            testBible();
        }
        */
        if (options.contains("statis")){
            testStatis();
        }
        if (options.contains("pbsp.ReParTest")){   // called from jar
            options.remove("pbsp.ReParTest");
        }
        if (dfaTrans){
            // testReGen();
        }
        if (options.contains("data")){
            testBigData();
            testFasta();
            testTraffic();
            testBible();
            testReGen();
        }            
        if (options.isEmpty()){
            options.add("bench");
            testBigData();
            testFasta();
            testTraffic();
            testBible();
            // testReGen();
            if (meDfaVsDfa){
                testEx1();
                // testEx2();
            }
        }
    }
}
