/*
 * @(#)ReParallel.jpp       1.0 2023/03/01
 *
 * Copyright (c) 2023 Angelo Borsotti. All Rights Reserved.
 * This computer program is protected under Copyright.
 */

package pbsp;
import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import lbj.*;
import lbj.HashBag.*;
import lbj.IntSet.*;
import lbj.Graph.*;

/**
 * The <code>ReParallel</code> class provides regular expression parsing with the parallel
 * algorithm.
 *
 * @author  Angelo Borsotti
 * @version 1.0   1 March 2023
 */

/*
 * This is the RE parser that supports extended syntax: character classes, dot, bounded
 * groups, full Unicode, escape, and that builds the numbered REs to be used to perform
 * parsing using local languages ngrams and triples. No disambiguation.
 * It does not build the BS dfa, but the ngrams and with them it builds the nfa and the dfa.
 * It minimizes the footprint, which is important because the dag is long as the text (+1)
 * and then its size depends on that of its elements. They cannot be objects, or arrays
 * representing explicitly a graph. They instead represent here subsets of the only triples
 * that belong to accepting paths.
 * (This file is the previous versions of it with BD_LONG, SUBCLASSES, DFA, PAR_DFA, MEMOIZE,
 * EXTRA_NULLABLEBODY, REV_DFA, BUILDER_DFA selected).
 *
 * Bounded groups
 *
 * They cannot be simply converted in subexpressions, e.g. (a){3} into (a)(a)(a), because
 * this lead to have several subexpressions, but representing the original one, which is
 * a problem when extracting data from the dag because the caller sees only one group instead
 * of many.
 * Let's then create dedicated asts with sequence numbers that are different from position
 * numbers. Here are the digrams:
 *
 *        e{n}   prev e1, e1 e2, e2 e3, ... en foll(e)
 *        e{n,m} prev e1, e1 e2, e2 e3, ... en foll(e), en en+1, en+1 en+2, ... en+x em, em foll(e)
 *        e{n,}  prev e1, e1 e2, e2 e3, ... en foll(e), en en
 *       
 * These asts have the the number of e, so as to let the tree have instances of the same
 * subexpressions (and not copies differently numbered).
 * Since the digrams have dedicated asts, one for each iteration, the n-grams and the triples
 * of each iterations are distinct, and the nfa can then be built correctly.
 *
 * Character sets (aka character classes)
 *
 * Here we refer to character classes, like, e.g.: [a-z], which would be better called
 * "character subsets" (character classes in Posix are predefined subsets).
 * There is a need to handle them in an efficient way that avoids to represent them
 * as, e.g. (a|b|...|z), that would lead to the generation of huge amounts of triples.
 * To do that, we take al the terminals, and the character classes, and build a partition
 * of the input alphabet into disjoint subsets (subclasses).
 * Then, each terminal and character class can be represented as a set of such subsets.
 * E.g. in [a-e][d-g] we have the subsets {a,b,c}, {d,e} and {f,g} and [a-e] can be
 * represented as {a,b,c} U {d,e}, and [d-g] as {d,e} U {f,g}.
 * Since all subclasses are disjoint, it is possible to convert input characters into their
 * subclass and use it to make transitions.
 * Note that the use of character subclasses is not necessary to build a nfa: arcs can have
 * character classes, and transitions can be done testing sequentially which arcs is appropriate
 * for a char, taking all the ones (possibly several) that are so.
 * Representing the character classes on the arcs as sets of subclasses makes transitions
 * much faster because accessing a map we convert a character into a subclass, and a bit
 * test allows to test if the subclass is in the set of subclasses of the arc (representing
 * that set as a bitstring).
 * Another solution would be to have arcs for all the characters in a class, but that means
 * lots of arcs.
 * For a dfa there is no need to build triples  using character (sub)classes: it is sufficient
 * to take the subclasses of each arc and add an entry to the delta for each of them.
 * I.e. state S with arc A with s1,s2..sn on it would generate an entry for (S,s1) in delta,
 * another for (S,s2), etc.
 * We build a map from characters (all java Unicode) to subclasses. This map is an array
 * of blocks (planes), in which identical blocks are shared.
 *
 * It is possible to compute the character classes before building the ngrams, so that each
 * char class could be considered as a char for what concerns the ngrams, but since this is
 * an optimized way to represent subclasses, it can also be done after.
 * All the play with asts and n-grams is done with character classes.
 * In summary:
 *
 *    - asts:            have character classes
 *    - n-grams:         have character classes
 *    - triples:         have ast nodes
 *    - nfa:             have character classes on the arcs. A state has all arcs with
 *                       the same symbol (character class) on them. The reached states
 *                       then do not depend on the symbols on the arcs.
 *                       To make transitions we only check that the char belongs to the class. 
 *    - dfa:             have character subclasses on the arcs
 *    - dag:             columns have sets of states, represented as elements in tripleStarting
 *    - tripleStarting:  one for each character subclass, containing an array with all the triples
 *                       whose starting symbol contain that subclass.
 *                       N.B. they are not disjoint
 *
 * Note that we convert sets of states to bitstrings of tripleStarting only when storing them
 * in the dag.
 * An alternative is to have asts with characters subclasses. Then triples and n-grams would
 * have subclasses, and nfa arcs too. All becomes much bigger.
 *
 * It is possible to use U+FFFE, U+FFFF as bot and eof, but the best is to use integers that
 * are outsise the Unicode range, and assign to them dedicated subclasses.
 * We use then 0x1000000 and 0x2000000 for bot and eof.
 * To support Unicode, and avoid to have a huge map from characters to subclasses, we use block
 * arrays. I.e. a [256,256] array.
 * Then to have the subclass of ch:
 *
 *         int sub = 0;
 *         if (ch < 255){
 *             sub = classMap[ch];
 *         } else {
 *             sub = arr[ch>>>8] == null ? 0 : arr[ch>>>8][ch&0xff];
 *         }
 *
 * The subclasses of bot and eof are constants.
 * Notes:
 *
 *   - we allocate an entry in symClassTable for the class of BOT and another for EOT
 *     as null
 *   - subclasses 0, 1 and 2 are then reserved to denote nothing, bot and eof, and the
 *     other entries are for the other subclasses.
 *     This means that in classMap (as a whole) 0 denotes a no class, and since that is
 *     never used in transitions, it can be used to detect illegal input (as well as null
 *     for a block of classMap).
 *
 *
 * Algorithm
 *
 * First, a RE must be compiled. Compilation parses the RE and builds all the parse tables:
 *
 *        ast's
 *        nfa, dfa, revdfa
 *        triplesTable
 *        tagsTable
 *        tripleStarting
 *        startMap, classMaps, symClassTable
 *        tstable, base, check
 *        groupNumbers
 *
 * In the nfa states contain only one triple, and state numbers are the same as triple numbers:
 * triples are numbered from 1.
 * Linked triples can then be enumerated using the state transitions.
 *
 * With fewer numbered parentheses, do we have fewer states? The building of the nfa depends
 * only on the triples.
 * If the RE is ambiguous, we could have two triples with the same start and end, and different
 * parentheses, which would mean two states.
 * This, however, occurs only in REs like, e.g. a**, which are not common.
 *
 * - To have fewer parentheses, we could mark the asts that must not generate one, which can
 *   easily accomodate various numberings, and then computeAstDig can generate the normal
 *   digrams if the ast is not numbered, and instead put the parentheses if it is.
 *   With no asts numbered we should obtain a recognizer, providing that at least the terminals
 *   be numbered.
 *   The parentheses aroud terminals could be removed, they were so in pat, but they simplify
 *   getMatches, that can detect always parentheses when seeking sub-expressions, including
 *   terminals.
 *   Note that asts have unique seq numbers, which are normally the same as their pos fields,
 *   except for groups with bounds, that have cloned asts representing the bodies with pos
 *   fields equal to the origin one.
 *   This serves to getMatches to recognise all the occurrences of the bodies as derived from
 *   the same group.
 * - note that the nfa would have fewer states when the RE is ambiguous and the user asked to
 *   have fewer parentheses. This is not so common.
 *
 * The sequential parser
 *
 * The sequential parser makes a forward pass using the dfa and recording the dfa states
 * encountered. The states represent reachable nfa states.
 * To purge them removing the non post-reachable ones, a backwards pass is made, which removes
 * them making the intersection between the forward states and the reverse ones, and records
 * the result as dag values.
 * To speed up the sequential parser, the nfa and the reverse nfa are determinized making
 * sure to use the same states.
 * Note that when making reverse transitions there is no need to check the symbol.
 *
 * The parallel parser
 *
 * The development of the algorithm for the parallel parser has undergone a long history
 * of versions, starting with the first one in which only the NFAs were used.
 * This allowed to make the readers start the matching of their chunks using all the NFA
 * states determining the set of NFA states reached by each at the end of the chunk.
 * Sewing then allowed to prune all the states that did not lie on some accepting path.
 * The builders then could build a clean DAG.
 * Subsequent versions of the algorithm used DFAs, and this is the one in which the readers
 * make a forward recognizion only.
 * The parallel parser makes a first pass using a number of threads that run the "reachers".
 * Each one takes care of a chunk of the text.
 * It performs a recognizion for each starting dfa state (that corresponds exactly to one
 * nfa state) recording the ending dfa state.
 * This is so because a chunk is a substring, and we do not know what dfa state would be
 * the one reached by the sequential parser when processing the first character of the chunk,
 * so we must try all, except of course from the first chunk, that starts only from state 0.
 * Some of the recognizions done terminate quickly because they reach a state from which
 * no transitions can be done. This depends on the first character of the chunk, and changes
 * considerably the work that the reaches have to do. We then split the text in chunks, but
 * then adjust their starting points choosing the ones that have fewer states that can make
 * at least the first transition.
 * There are very many start states when the RE contains several identical sub-REs, especially
 * (.)*.
 * 
 * After all the reachers have terminated, a forward sewing is done, removing all the
 * recognizions that ought not to have been done if we knew the start dfa state of each
 * chunk. This terminates with the knowledge of the correct dfa start state of each chunk.
 * Then a backwards sewing is done, starting from the last chunk, taking its end states,
 * removing the ones that are not final, and removing its start states that do not reach
 * any final state. This is done then for all the other chunks, ending with the knowledge
 * of the set of the ending nfa states of each chunk.
 *
 * Then the dag is created running in parallel the "builders".
 * Each builder makes a forward pass, a recognizion using the dfa, recording the encountered
 * states. It does when a backwards pass starting with the end nfa states of the chunk and
 * removing the non pos-reachable states from the ones of the forward pass, recording then
 * the result as dag values.
 * Alternative solutions for the builders have been tried using for each chunk two workers:
 * one making the forward pass, and the other making the backwards one.
 *
 *    1. an additional worker could then be run that intersects the sets of nfa states
 *       of both passes
 *    2. the dag elements are atomic locations. The two workers met in the middle.
 *       Before meeting, each one writes the dag, after meeting, both intersect the dag.
 *    3. each intersects. The dag locations are initialized with the universal set.
 *       The Peterson's algorithm is used to act on dag locations as critical regions.
 *    4. each builder determines the set of its nfa start states that are also post-reachable
 *       (which in general does not correspond to any dfa state), and constructs a specific dfa
 *       starting with them, that it uses thereafter to process the chunk.
 *
 * All these alternatives turned out to be slower than making the two passes in a same
 * builder.
 * Ways to improve speed have long be considered.
 * It is hardly possible to reuse the computations of the reachers to optimize (or remove)
 * the forward pass of the builders: the reachers compute several recognizions in parallel.
 * Each recognizions is a sequence of dfa states reached. However, we should remember
 * them all, and use in the builders only the right one, but this requires too much memory.
 *
 * In the forward sewing we have dfa states. Can we have them also in the backwards sewing?
 * The last segment matches the end of the text. What if we had a dfa to recognize the
 * reverse text? Can we take its initial state and intersect it with the last dfa reached state?
 * Let's do the forward sewing, and record the dfa start state of each chunk, and then do the
 * backwards sewing, obtaining the end state of each chunk.
 * Then the forward pass of builders we can use the dfa start state and perform the transitions
 * recording states. The backward pass would peal off such states producing the dag.
 * The idea is that there is no need in the forward pass to use start states that are already
 * pealed off: that will anyway be done in the backwards pass even if they contain some non
 * post-reacheable state.
 * Let's see if it is possible to do the same thing also in the backwards pass.
 * This is possible for the sequential algorithm achieving 30% reduction in time.
 * It is not possible for the parallel algorithm if the reachers do not perform a backwards
 * recognizion.
 * The problem is that the ending states of chunks are not states of a reverse dfa, they would
 * be if we made a backwards recognizion.
 * Note that in the forward pass we can make transitions starting with the set of nfa states
 * reached by the previous chunk, which we now are (pre-)reachable and also post-reachable,
 * but making transitions we could still reach states that are not post-reachable, so we
 * can as well start with a dfa state (that represents nfa states that are reachable, but
 * in general not post-reachable).
 * The ones we have now are the reacheable ones, peeled off the ones that are not post-reacheable.
 * I tried to take a reverse dfa state that contains at least the desired final states, which
 * would make transitions on the reverse dfa that touch at least the same nfa states as making
 * reverse transitions on the nfa.
 * However, the reverse dfa could have several such states, and they could have transitions that
 * reach other reverse dfa states, some containing states that are not post-reacheable transitions.
 * E.g. RE ((a)?(a)?)((a)?(a)?)  text aaa.
 *
 *     The first chunk has only "a", and:
 *          start states: {4 7 12 14 15}
 *          end states:   {1 5 8}
 *     Now, there are two reverse dfa states that contain {1 5 8}:
 *          state 2: {1 2 4 5 7 8 9 10 12 14} --a--> 3 {1 4 5 7 8 12}
 *          state 3: {1 4 5 7 8 12}           --a--> 4 {1 4 7}
 *
 * Correct intersection: {4 7}.
 * The states they reach with "a" are 3 and 4, if we take 3, it containg state 12, that is not
 * post-reacheable with respect to the final state of the string.
 * If we choose instead the second one, we do the correct intersection.
 * But we are unable to choose the right one, unless we make transitions all the way from the
 * end down to the beginning.
 * The problem is that we cannot know the dfa state when processing a char at a given position
 * unless we make transitions all the way.
 * For some dfa's that, for a same character, have only one state reached, that is possible,
 * but not in general.
 * The latest version of the algoritm uses the ME-DFAs both normal and reversed, and
 * makes the reachers do a backwards recognizion, so that the builders know the reverse dfa
 * states at the borders of each reach, and then can make a backwards pass determining the
 * post-reacheable states, which they intersect with the ones they found in the forward
 * pass, obtaining the neat pre- and post- reacheable nfa states that are then stored in
 * the dag.
 * Note that the use of the multi-entry dfas (ME-DFAs) is done only to reduce the number of
 * the start states.
 *
 * We use memoization to speed up the builders' backwards pass. The same reverse transitions are
 * computed several times. We then use a hash table to hold them, and deliver the results quicly
 * without computing it anew.
 *
 * Notes: creaction of objects in java ("new") seems not to block threads waiting for others
 * to complete a creation they are doing. Thus, objects can be created inside reachers and
 * builders.
 *
 * An alternative algorithm is to make the reachers record only the forward reached states and
 * the backwards reached ones, and then have the builders build the only one intersection
 * possible. The reachers would still make a lot of forward and backwards scans, but at
 * least would avoid to make all the combinations of intersections.
 *
 * Optimizations
 *
 * The reachers make a number of parses, each parse over their chunk, because that is faster
 * than making all the parses at once over the chunk.
 *
 * We have added load balancing of the threads used for the readers and the builders.
 * This is done creating a number of chunks that is 4 times that of the threads, and
 * putting them in a queue (implemented as a counter holding the number of chunks), that
 * is served by all threads. Each thread takes chunks from the queue and processes them
 * until the queue becomes empty. In do doing, the work to do is spread more evenly on
 * threads.
 *
 * It is possible to do with only one pass: the decay in reachers is very fast, so perhaps
 * we do not need to consume much memory.
 * Each reacher would make a forward pass starting from one dfa-nfa state, making all transitions.
 * It would then make a backward pass starting from the end of the chunk using the reverse-dfa,
 * making all transitions.
 * It has then to intersect its results with the ones of the forward pass.
 * Since it does not know what are the correct starting states in both directions, it
 * must perform the intersections on all the combinations of forward and backwards passes.
 * Most of them would lead to empty intersections, and then be discarded, but in the unlucjy
 * case there could survive many.
 * Forward sewing would then start from the beginning and pick up only the intersections
 * that have the proper start state, and then start from the end and take only the ones
 * that have the proper end state, ending in one intersection for each chunk (if the text
 * is matched).
 * To produce all the intersections (i.e. dag pieces) in a chunk, it is possible to make a
 * forward scan starting from one state and remembering the states reached, then if successful
 * make one by one a reverse scan starting from each end state and if successful intersect it
 * along the way and recording the result only if the scan reaches the end (it does not when
 * an intersection is empty).
 * This would reduce the footprint, that can, however, remain high.
 *
 * Measurements
 *
 * We have three benchmarks:
 *
 *    1.  biometric data: a file that contains sequences of strings derived from a RE
 *        that represent instances of biometric data
 *    2.  traffic data: a json file that contains sequences of traffic data
 *    3.  bible: a html file that is seen as an unstructured text with buried in it
 *        instances of specific html tags
 *
 * We have measured the gain, i.e. the parse time of the parallel parser with 1 thread
 * divided by that of the parse with n threads for increasing threads and text length,
 * and done the same for recognizion only.
 * 
 * We have measured the phases of the parallel algorithm: only the reachears and builders
 * are relevant, all the others are take less than 1% of the total time.
 * The reachears are the longest ones because they have to do more or less the same operations
 * as the builders, but on all states.
 *
 * We have measured also the decay of the parses done by the reachers.
 * The results confirm that the decay is reached almost immediately at the first transition
 * done.
 * For each chunk we computed the number of the transitions done in total, i.e. the sum of the
 * ones processed by each parse done, and divided it by the length of chunk, it gives the
 * average parses, but we draw also the curve of the nr. of parses for each position, so as
 * to see how they reduce as parsing proceeds.
 * We measured percent position at which the parses are reduced by 1/e = 64%.
 * This is the lengths of the parses done, sorted them, and selected the one at 64% the total:
 * its length is the desired one.
 * We have measured the number of parses that survive the end of reachers: they are 3..5.
 *
 * The time spent by reachers is 25% and by builders 75%.
 *
 * Here are the number of states of nfa and dfa's
 *
 *     bigdata    nfa 8 dfa 5 revdfa 6
 *     fasta      nfa 60 dfa 68 revdfa 188
 *     traffic    nfa 166 dfa 101 revdfa 226
 *     bible      nfa 31 dfa 47 revdfa 48
 *
 *     fasta: https://open.oregonstate.education/computationalbiology/chapter/patterns-regular-expressions/
 *     traffic: https://zenodo.org/record/5789064#.ZCHHQ9LP0eM
 *     bible: https://www.gliscritti.it/dchiesa/bibbia_cei08/indice.htm
 *
 * Notes:
 * 
 * The parallel parser runs faster than the sequential one even with 2 cores (taking into
 * account that it must scan the input more and pays the overhead of creating threads).
 *    - traffic:  par 26  seq 42
 * A general parser, e.g. gbsp, in general is faster, especially when the input is made
 * of lexemes.
 * Grammars are also easier to write, and it is easier to figure out what they match,
 * A problem is .* that is greedy, and it matches everything that allows to match the
 * remaining part, which often is not what one wants.
 * To overcome this, some RE libraries provide thrifty versions of * and +.
 *
 * Compressing the dag
 *
 * It is possible to compress the dag taking into account that for each set of states
 * and next character, the next state is unique. We could then build a sort of dfa
 * that represents it. This is slow, but can help when one needs to store the dag for
 * later inspection.
 * We have measured the duplications in dag:
 *
 *        fasta     unique dag elements: 68 total 744226
 *        traffic   unique dag elements: 93 total 65452666
 *        bible     unique dag elements: 27 total 6148747
 *
 * Footprint
 *
 * The footprint is the occupation of the dag, which is the length of the text * 2,
 * plus the hash table of the dag, which is negligible.
 * 
 * To do
 *
 * The NFA has one triple in each state. This allows to handle triples and states as
 * the same thing. It allows also to build the set of states that begin with the same
 * symbol, which is used to optimize the representation of DAG columns with bitsets
 * representing subsets of such sets. When the parsing algorithms used transitions on
 * NFAs, having one triple in each state made states having all the incoming arcs labelled
 * with the same symbol, and also all outgoing arcs too. This allowed to optimize transition
 * making a unique test instead of picking only the arcs that matched the transition symbol.
 * It could be possible to store in states only the middle elements of triples, reducing
 * the number of states.
 *
 * It could be possible to improve the speed using SIMD vector instructions, which are
 * currently provided by jdk.incubator.vector. Note, however, that this package is a beta
 * feature that could be changed in some future release of Java.
 */

public class ReParallel {

//#define DEBUG;
//#define MEASURE;

//# Whether nullable bodies of groups produce empty iterations always
#define EXTRA_NULLABLEBODY;

//# Whether load balancing is enabled
#define LOAD_BALANCE;

//# Whether builders use the reverse dfa
#define BUILDER_REVDFA;

//# Whether reachers start with all the dfa states (instead of only the multi-entry states)
//#define ALL_STARTSTATES;

//# Whether the min-mefa reverts to dfa when it has more initial states
#define MEFA_TO_DFA;


    //---------------- Tracing ---------------------

    #define function TRACE(fl,frm,a){
        if (!this.DEBUG) return;
        if (fl[0] == "\'" || fl[0] == "\""){
            fl = fl.substring(1,fl.length-1).toUpperCase();
        }
        var fls = "";
        if (fl.length == 1){
            fls = "FL_" + fl;
        } else {
            for (var i = 0; i < fl.length; i++){
                if (fls.length > 0) fls += "|";
                fls += "FL_" + fl[i];
            }
            fls = "(" + fls + ")";
        }
        var str = "if ((" + fls + " & trc) != 0){" +
            "Trc.out.printf(" + frm;
        for (var i = 2; i < arguments.length; i++){
            str += "," + arguments[i];
        }
        str += ");}"
        return str;
    };

    // Definitions and iterators for dag elements

    /* Each dag element has the following format:
     *
     *   ---------------------------------------
     *   |f|  bitstring or hashtable index     |
     *   ---------------------------------------
     *
     *   f = 0    bitstring: each bit = 1 indicates the presence of the corresponding
     *            (by position) tripleStarting triple
     *   f = 1    index: index in the dagHash table that contains a bitstring as before,
     *            that is longer than the bits that a dag element can contain
     *
     *   An index in the dagHash table has the following format:
     *
     *   ---------------------------------------
     *   |  array index   |    bit index       |
     *   ---------------------------------------
     *
     *   The array index serves to access an array element in the hash table, and
     *   the bit index serves to access a bit in the element.
     */

    /** Max integer value of a dag element. */
    private static final long BS_MAX_VALUE = Long.MAX_VALUE;

    /** Shifts to get the hash table array index of a dag index field. */
    private static final int SHIFTS_BS = 6;

    /** Number of bits that a dag element can hold. */
    private static final int SIZE_BS = 1 << SHIFTS_BS;

    /** Number of bits that the bistring field can hold. */
    private static final int INLINE_BS = SIZE_BS-1;

    /** Mask of the bit index field. */
    private static final long MASK_BS = INLINE_BS;

    /** The mask of the highest bit (f above). */
    private static final long HIGH_BS = 1L << INLINE_BS;

    /** The mask to get the hashtable index field. */
    private static final long INLINE_MASK_BS = Integer.MAX_VALUE;

    #define function BS_BIT(b){
        return "(1L << (" + b + " & MASK_BS))";
    }
    #define function BS_B(b){
        return "(1L << " + b + " )";
    }
    #define function BS_LONG(el){
        return "(int)(" + el + "& INLINE_MASK_BS)";
    }

    // _j: index of triple in tripleStarting
    // _tn: triple number
    // nstate: same as _tn

    /** Iterators over the bits of a dag element. */
    #define function FOREACH_BS(elem,sym,d){
        return FOREACH(elem,sym,d,"");
    };
    #define function FOREACHNOT_BS(elem,sym,d){
        return FOREACH(elem,sym,d,"!");
    };
    #define function FOREACH(elem,sym,d,pr){
        var str = "{long _bs = (long)" + elem + ";";
        str += "int _idx = " + BS_LONG(elem) + ";";
        str += "long[] _arr = " + elem + " >= 0 ? null : " + d + ".table;";
        str += "int _ss = startSet(" + sym + ");";
        str += "int _len = tripleStarting[_ss].length;";
        str += "for (int _j = 0; _j < _len; _j++, _bs >>= 1){";
        str += "boolean _pres = " + elem + " >= 0 ? (_bs & 0x1) != 0 : "
            + "((_arr[_idx+2 + (_j>>>SHIFTS_BS)] & " + BS_BIT("_j") + ") != 0);";
        str += "if (" + pr + "_pres){";
        str += "int _tn = tripleStarting[_ss][_j];";
        str += "int nstate = _tn;";
        return str;
    };

    /**
     * Simulates the access of each bit in the specified dag element.
     *
     * @param      elem dag element
     * @param      sym symbol for the dag position
     * @param      d dag hash table
     * @param      show <code>true</code> to trace the access, <code>false</code> otherwise
     * @return     string with the number of bits present
     */

    String foreachbs(long elem, int sym, DagBuilder d, boolean show){
        if (show) Trc.out.printf("foreachbs elem %s sym %s\n",elem,sym);
        String res = "";
        long _bs = elem;
        int _idx = BS_LONG(elem);
        long[] _arr = elem >= 0 ? null : d.table;
        int _ss = startSet(sym);
        int _len = tripleStarting[_ss].length;
        if (show){
            Trc.out.printf("foreachbs _bs %s _idx %s _ss %s _len %s\n",_bs,_idx,_ss,_len);
            if (_arr != null){
                for (int z = _idx+2; z < (int)d.table[_idx+1]; z++){
                    Trc.out.printf("  arr[%s] %s\n",_arr[z]);
                }
            }
        }
        for (int _j = 0; _j < _len; _j++, _bs >>= 1){
            boolean _pres = elem >= 0 ? (_bs & 0x1) != 0 :
                ((_arr[_idx+2+(_j>>>SHIFTS_BS)] & BS_BIT(_j)) != 0);
            if (_pres){
                int _tn = tripleStarting[_ss][_j];
                int nstate = _tn;
                res += "  " + nstate;
            }
        }
        if (show) Trc.out.printf("foreachbs res %s\n:",res);
        return res;
    }

    #define function ENDFORBS(){
        return "}}}";
    };

    /**
     * Check the consistency of the specified dag element, and issue a message
     * and stops if the element is inconsistent.
     *
     * @param      elem dag element
     * @param      sym symbol for the dag position
     * @param      d dag hash table
     */

    void foreachbsCheck(long elem, int sym, DagBuilder d){
        boolean err = false;
        int idx = 0;
        doit: {
            if (elem >= 0){
            } else {
                idx = BS_LONG(elem);
                if (d == null || d.table == null){
                    Trc.out.printf("htb table null\n");
                    err = true;
                    break doit;
                }
                idx = idx+2;
                if (idx >= d.table.length){
                    Trc.out.printf("index %s in htb table too large, htb len %s (elem %x)\n",
                        idx,d.table.length,elem);
                    err = true;
                    break doit;
                }
            }
            int ss = startSet(sym);
            if (ss >= tripleStarting.length){
                Trc.out.printf("cbar %s >= tripleStarting length %s\n",
                    sym,tripleStarting.length);
                err = true;
                break doit;
            } else {
                if (tripleStarting[ss] == null){
                    Trc.out.printf("null tripleStarting for %s %s\n",sym,(char)sym);
                    err = true;
                    break doit;
                }
            }
            int len = tripleStarting[ss].length;
            if (elem < 0){
                int ix = BS_LONG(elem);
                int ln = (len + SIZE_BS - 1) / SIZE_BS;
                if (ln > d.table[ix+1]){
                    Trc.out.printf("bit array %s too short %s for len %s (%s)\n",
                        ix,d.table[ix+1],len,ln);
                    d.trace();
                    err = true;
                    break doit;
                }
            }
        } // doit
        if (err){
            new Throwable().printStackTrace(Trc.out);
            System.exit(1);
        }
    }


    /** The trace stream. */

    private static class Trc {
        public static PrintStream out = System.err;
    }

    /** The trace flags. */
    int trc;

    /*
     * Internal constants for trace flags
     */

    /**
     * The following trace flags are used:
     * <p><blockquote><pre>
     *    a   ast building, compile, tripleStarting
     *    b   getsym
     *    d   triple adding and starting, nfa building
     *    e   trace ast
     *    f   building char subclasses
     *    g   allowed n-grams, symclass
     *    h   minimization
     *    m   match, dagBuilder
     *    n   n-grams, building nfa
     *    p   intSetToDag, match
     *    q   match
     *    t   getMatches
     * </pre></blockquote><p>
     */

    static final int FL_A = 1 << ('a'-0x60);
    static final int FL_B = 1 << ('b'-0x60);
    static final int FL_D = 1 << ('d'-0x60);
    static final int FL_E = 1 << ('e'-0x60);
    static final int FL_F = 1 << ('f'-0x60);
    static final int FL_G = 1 << ('g'-0x60);
    static final int FL_H = 1 << ('h'-0x60);
    static final int FL_M = 1 << ('m'-0x60);
    static final int FL_N = 1 << ('n'-0x60);
    static final int FL_P = 1 << ('p'-0x60);
    static final int FL_Q = 1 << ('q'-0x60);
    static final int FL_T = 1 << ('t'-0x60);

    /**
     * Set the trace flags which are specified in the argument.
     * The string must contain only lowercase letters.
     * Upon return <code>trc</code> is the powerset of flags augmented
     * with the ones specified.
     *
     * @param      s string of flags
     */

    public void settrc(String s){
        #ifdef DEBUG
            this.trc = 0;
            for (int i = 0; i < s.length(); i++){
                this.trc |= 1 << (s.charAt(i) - 0x60);
            }
        #else
            Trc.out.printf("debug not enabled\n");
        #endif
    }

    //---------- Syntax analysis of a RE -----------------

    /* Syntax
     *
     *  - the syntax of RE as reported in papers is not a good one for applications.
     *    E.g. where a RE is allowed, a single terminal or a concatenations can occur.
     *    An application must instead have only one thing, which can contain one or several
     *    elements. Something like, e.g.:
     *
     *           r -> alt {| alt}
     *           alt -> {factor}+
     *           factor -> terminal | (r) | (r)? | (r)+ | (r)* | (r){m [,[n]] | m,} | set | escape
     *           set -> "." | "[" {terminal | terminal "-" terminal}+ "]"
     *           escape -> \ char
     *
     *  - terminal is any character that is not a reserved one: |()+*?{}[]^-.\\ \u03b5 \u03a6
     *    (the latter: epsilon and phi)
     *  - spaces can be used for readability, to introduce them as terminals, use escape
     *  - when a RE is a single character, ?, +, * and {} can occur without parentheses.
     *  - conditions:
     *       {n}:    n > 0
     *       {n,m}:  n > m
     */

    /** The reference to the current node. */
    private AstNode curNode; 

    /** The reference to the root of the AST. */
    AstNode astRoot;

    /** The index in RE (as a string). */
    int cursor;

    /** The index of the start of a token in RE (as a string). */
    private int startToken;

    /** The RE to be analysed. */
    private String re;

    /**
     * Build the AST from the specified string containing the RE.
     *
     * @return     reference to the root of the AST
     */

    private AstNode buildAst(){
        TRACE(E,"buildAst %s\n",Str.strQuoted(re));
        this.astSeq = 0;
        this.error = false;

        this.cursor = 0;
        this.startToken = 0;
        this.curNode = null;
        expression();
        if (this.error || getsym() != -1){    // error or whole re not consumed
            return null;
        }
        #ifdef DEBUG
        if ((FL_E & this.trc) != 0){
            TRACE(E,"buildAst expression end\n");
            traceAst(this.curNode);
        }
        #endif

        AstNode ast = this.curNode;
        this.eofAst = newAstNode(A_LEA);
        this.eofAst.sym = newSymbolChar(EOF);         // eof
        this.eofAst.pos = this.eofAst.seq;

        this.botAst = newAstNode(A_LEA);
        this.botAst.sym = newSymbolChar(BOT);         // bot
        this.botAst.pos = this.botAst.seq;

        this.astMap = new AstNode[this.astSeq];
        int saveseq = this.astSeq;
        this.astSeq = 0;
        setPosAst(ast,null);
        this.astMap[this.eofAst.seq] = this.eofAst;
        this.astMap[this.botAst.seq] = this.botAst;
        this.astSeq = saveseq;
        #ifdef DEBUG
        if ((FL_E & this.trc) != 0){
            TRACE(E,"buildAst ast\n");
            traceAst(ast);
            traceAstMap();
        }
        #endif
        this.astRoot = ast;

        /*
        for (int i = 0; i < this.astMap.length; i++){
            if (this.astMap[i] == null) break;
            Trc.out.printf("ast %s\n",this.astMap[i]);
        }
        */
        return this.astRoot;
    }

    /** The AST representing the end of text. */
    AstNode eofAst;

    /** The char representing the end of text. */
    static final int EOF = 0x2000000;

    /** The AST representing the beginning of text. */
    AstNode botAst;

    /** The char representing the beginning of text. */
    static final int BOT = 0x1000000;

    /** Whether an error has occurred. */
    private boolean error;

    /**
     * Parse an expression.
     */

    private void expression(){
        TRACE(A,"expression start at: %s\n",this.cursor);
        this.curNode = null;
        AstNode r = null;
        AstNode altnode = null;
        doit: {
            subexpression();                         // allow also nothing
            if (this.error) return;
            if (this.curNode == null){
                this.curNode = newAstNode(A_EMP);    // return empty
                this.curNode.sym = newSymbolChar('\u03b5');
            }
            r = this.curNode;
            int n = 1;
            l: for (;;){
                gsep();
                int symv = getsym();
                char sym = (char)symv;
                if (symv < 0) break;
                if (sym != '|'){
                    this.cursor--;
                    break;
                }
                if (altnode == null){
                    altnode = newAstNode(A_ALT);
                    altnode.son = r;
                    r.altnr = n;
                }
                n++;
                TRACE(A,"expression inner at: %s\n",this.cursor);
                subexpression();                           // alternative, require a term
                if (this.error) return;
                if (this.curNode == null){
                    this.curNode = newAstNode(A_EMP);      // return empty
                    this.curNode.sym = newSymbolChar('\u03b5');
                }
                r.bro = this.curNode;                      // store anyway
                r = this.curNode;
                r.altnr = n;
            } // l;
        } // doit
        if (altnode != null){
            this.curNode = altnode;
        }
        TRACE(A,"expression end at: %s %s re %s\n",
            this.cursor,this.curNode,this.curNode == null ? "" : this.curNode.toRE());
    }

    /**
     * Parse a subexpression.
     */

    private void subexpression(){
        TRACE(A,"subexpression start at: %s\n",this.cursor);
        this.curNode = null;
        factor();
        if (this.error) return;
        AstNode concnode = null;
        if (this.curNode != null){
            AstNode q = this.curNode;
            int n = 1;
            l: for (;;){
                AstNode p = this.curNode;
                n++;
                TRACE(A,"subexpression inner at: %s\n",this.cursor);
                factor();
                if (this.error) return;
                if (this.curNode != null){    // several terms
                    if (concnode == null){
                        concnode = newAstNode(A_CON);
                        concnode.son = p;
                        q = p;
                    }
                } else {
                    this.curNode = p;
                    break;
                }
                q.bro = this.curNode;
                q = this.curNode;
            } // l
        }
        if (concnode != null){
            this.curNode = concnode;
        }
        TRACE(A,"subexpression end at: %s %s re %s\n",
            this.cursor,this.curNode,this.curNode == null ? "" : this.curNode.toRE());
    }

    /**
     * Parse a factor.
     */

    private void factor(){
        TRACE(A,"factor start at: %s\n",this.cursor);
        this.curNode = null;
        gsep();
        int symv = getsym();
        char sym = (char)symv;
        AstNode groupnode = null;
        TRACE(A,"factor symv %s sym %s\n",symv,sym);
        doit: if (symv == -1){
            TRACE(A,"factor return %s\n",this.error);
            return;
        } else if (sym == '\\'){        // escape
            symv = getchar();
            if (symv != -1){            // not at the end, otherwise \
                sym = (char)symv;
            }
            this.curNode = newAstNode(A_LEA);
            this.curNode.sym = new Symbol();
            this.curNode.sym.kind = S_CHAR;
            this.curNode.sym.sym = sym;
            TRACE(A,"factor escape %s\n",this.curNode.sym);
        } else if (sym == '|' || sym == ')'){
            this.cursor--;
        } else if (sym == '('){
            TRACE(A,"factor group start\n");
            expression();
            if (this.error) return;
            groupnode = newAstNode(A_GRO);
            groupnode.groupKind = G_GRO;
            groupnode.son = this.curNode;
            if (getsym() != ')'){
                this.error = true;
                return;
            }
            symv = getsym();
            sym = (char)symv;
            TRACE(A,"factor group end %s\n",sym);
            if (sym == '*'){
                groupnode.groupKind = G_RE0;
            } else if (sym == '+'){
                groupnode.groupKind = G_RE1;
            } else if (sym == '?'){
                groupnode.groupKind = G_OPT;
            } else if (sym == '{'){
                getbounds(groupnode);
                if (this.error){
                    return;
                }
            } else if (symv != -1){
                this.cursor--;
            }
        } else if (sym == '['){                    // set
            TRACE(A,"factor set start\n");
            this.curNode = newAstNode(A_LEA);
            this.curNode.sym = new Symbol();
            this.curNode.sym.kind = S_SET;
            this.curNode.sym.symset = new IntSet();

            boolean first = true;
            int prev = -1;
            for (;;){
                symv = getsym();
                if (symv < 0){
                    this.error = true;
                    return;
                }
                sym = (char)symv;
                if (sym == ']') break;
                if (first){
                    if (sym == '^'){
                        this.curNode.sym.kind = S_NSET;
                        continue;
                    }
                    first = false;
                }
                if (sym == '\\'){        // escape
                    symv = getchar();
                    if (symv < 0){
                        this.error = true;
                        return;
                    }
                    sym = (char)symv;
                }
                if (sym == '-'){  // range
                    symv = getsym();
                    if (symv < 0){
                        this.error = true;
                        return;
                    }
                    sym = (char)symv;
                    if (sym == '-' || sym == ']'){
                        this.error = true;
                        return;
                    }
                    if (sym == '\\'){        // escape
                        symv = getchar();
                        if (symv < 0){
                            this.error = true;
                            return;
                        }
                    }
                    this.curNode.sym.symset.add(prev+1,symv);
                } else {
                    this.curNode.sym.symset.add(symv);
                }
                if (sym != '-') prev = symv;
            }
            if (prev < 0){            // []
                this.error = true;
                return;
            }
            TRACE(A,"factor set symset %s %s\n",
                symSetToString(this.curNode.sym.symset,true),
                this.curNode.sym.kind == S_SET);
            if (this.curNode.sym.kind == S_NSET){
                IntSet s = this.curNode.sym.symset;
                this.curNode.sym.symset = new IntSet();
                this.curNode.sym.symset.assign(0,Character.MAX_VALUE);
                this.curNode.sym.symset.sub(s);
            }
        } else if (sym == '.'){                       // dot
            this.curNode = newAstNode(A_LEA);
            this.curNode.sym = new Symbol();
            this.curNode.sym.kind = S_DOT;
            this.curNode.sym.sym = sym;
        } else {
            if (sym == '\u03b5'){
                this.curNode = newAstNode(A_EMP);      // return empty
                this.curNode.sym = new Symbol();
                this.curNode.sym.kind = S_CHAR;
                this.curNode.sym.sym = sym;
                break doit;
            }
            if (sym == '\u03a6'){
                this.curNode = newAstNode(A_NUL);      // return empty set
                this.curNode.sym = new Symbol();
                this.curNode.sym.kind = S_CHAR;
                this.curNode.sym.sym = sym;
                break doit;
            }
            if (sym == BOT || sym == EOF || sym > '\u007f'){
                this.error = true;
                break doit;
            }
            this.curNode = newAstNode(A_LEA);
            this.curNode.sym = new Symbol();
            this.curNode.sym.kind = S_CHAR;
            this.curNode.sym.sym = sym;
        } // doit
        if (groupnode != null){
            this.curNode = groupnode;
        }
        for (;;){
            gsep();
            symv = getsym();
            sym = (char)symv;
            if (sym == '*'){
                groupnode = newAstNode(A_GRO);
                groupnode.groupKind = G_RE0;
                groupnode.son = curNode;
            } else if (sym == '+'){
                groupnode = newAstNode(A_GRO);
                groupnode.groupKind = G_RE1;
                groupnode.son = this.curNode;
            } else if (sym == '?'){
                groupnode = newAstNode(A_GRO);
                groupnode.groupKind = G_OPT;
                groupnode.son = this.curNode;
            } else if (sym == '{'){                  // parse {n,m}
                groupnode = newAstNode(A_GRO);
                getbounds(groupnode);
                if (this.error){
                    return;
                }
            } else if (symv != -1){
                this.cursor--;
                break;
            } else {
                break;
            }
            this.curNode = groupnode;
        } // doit
        TRACE(A,"factor end at: %s %s re %s\n",
            this.cursor,this.curNode,this.curNode == null ? "" : this.curNode.toRE());
    }

    /**
     * Get the bounds of a bounded group.
     */

    private AstNode getbounds(AstNode groupnode){
        TRACE(A,"getbounds start at: %s\n",this.cursor);
        groupnode.groupKind = G_RE2;
        groupnode.son = this.curNode;
        int lo = -1;
        int hi = -1;
        // get the lower bound
        int bound = getint();
        if (bound >= 0){
            lo = bound;
        }
        int symv = getsym();
        if (symv == -1){
            this.error = true;
            TRACE(A,"getbounds error 1\n");
            return null;
        }
        char sym = (char)symv;
        if (sym == ','){
            // get the upper bound
            bound = getint();
            if (bound >= 0){
                hi = bound;
                if (lo < 0) lo = 0;
            } else if (lo < 0){              // both bounds missing
                this.error = true;
                TRACE(A,"getbounds error 2\n");
                return null;
            }
        } else {
            this.cursor--;
            hi = lo;
        }
        symv = getsym();
        if (symv == -1){
            this.error = true;
            TRACE(A,"getbounds error 3\n");
            return null;
        }
        sym = (char)symv;
        if (sym == '}'){                     // {n}
            if (hi >= 0){
                if ((hi < lo) || (hi == 0)){
                    this.error = true;
                    TRACE(A,"getbounds error 4\n");
                    return null;
                }
            }
            groupnode.lowerbound = lo;
            groupnode.upperbound = hi;
            if (groupnode.lowerbound == 0){
                if (groupnode.upperbound == 1){
                    groupnode.groupKind = G_OPT;
                } else if (groupnode.upperbound < 0){
                    groupnode.groupKind = G_RE0;
                }
            } else if (groupnode.lowerbound == 1){
                if (groupnode.upperbound == 1){
                    groupnode.groupKind = G_GRO;
                } else if (groupnode.upperbound < 0){
                    groupnode.groupKind = G_RE1;
                }
            }
            TRACE(A,"getbounds lowerbound %s upperbound %s kind %s\n",
                groupnode.lowerbound,groupnode.upperbound,groupKindStr[groupnode.groupKind]);
        } else {
            this.error = true;
            TRACE(A,"getbounds error 5\n");
            return null;
        }
        TRACE(A,"getbounds end at: %s\n",this.cursor);
        return groupnode;
    }

    /**
     * Get an integer >= 0.
     *
     * @return     value, -1 if not present
     */

    private int getint(){
        TRACE(A,"getint start at: %d\n",this.cursor);
        int res = 0;
        boolean found = false;
        for (;;){
            int cur = this.cursor;
            int symv = getsym();
            if (symv < 0) break;               // end of data
            if (this.cursor-cur > 1){          // number ended by spaces
                this.cursor--;
                break;
            }
            char c = (char)symv;
            if ((c < '0') || ('9' < c)){
                this.cursor--;
                break;
            }
            res *= 10;
            if (res > 0){
                found = false;
                break;
            }
            int digit = (int)c - '0';
            res -= digit;                     // use negative accumulators, ..
            if (res > 0){                     // .. which is larger than a ..
                found = false;                // .. positive one
                break;
            }
            found = true;
        }
        if (found){
            res = -res;
            if (res < 0){
                found = false;
            }
        }
        if (!found) res = -1;
        TRACE(A,"getint res: %d\n",res);
        return res;
    }

    /**
     * Get the next character from the RE skipping blanks.
     *
     * @return     character, or -1 if no more available
     */

    private int getsym(){
        TRACE(B,"getsym cursor: %s re %s\n",this.cursor,this.re);
        int res;
        for (; this.cursor < this.re.length(); this.cursor++){
             if (this.re.charAt(this.cursor) != ' ') break;
        }
        if (this.cursor >= this.re.length()){   // eof
            res = -1;
        } else {
            if (!checkDig()){
                return -1;
            }
            res = this.re.charAt(this.cursor++);
        }
        TRACE(B,"getsym ret cursor: %s re %s res %s %s\n",this.cursor,this.re,res,(char)res);
        return res;
    }

    /**
     * Get the next character from the RE.
     *
     * @return     character, or -1 if no more available
     */

    private int getchar(){
        TRACE(B,"getchar cursor: %s re %s\n",this.cursor,this.re);
        int res;
        if (this.cursor >= this.re.length()){   // eof
            res = -1;
        } else {
            if (!checkDig()){
                return -1;
            }
            res = this.re.charAt(this.cursor++);
        }
        TRACE(B,"getchar ret cursor: %s re %s res %s %s\n",this.cursor,this.re,res,(char)res);
        return res;
    }

    /**
     * Check that a special character is legally preceded by another.
     *
     * @return     <code>true</code> if it is, <code>false</code> otherwise
     */

    /* These are the sequences of special symbols that are not allowed:
     *
     *    char  preceded by
     *      |   { [ ^ -
     *      (   { [ ^ -
     *      )   { [ ^ -
     *      +   | ( ? { [ ^ -
     *      *   | ( ? { [ ^ -
     *      ?   | ( ? { [ ^ -
     *      {   | { + * } [ { } ^ - .
     *      }   | ( + * ? [ ] { } ^ - .
     *      [   { [ ^ -
     *      ]   | ( ) + * ? { } [ ] ^ - .  special
     *      ^   | ( ) + * ? { } ]  ^ - .
     *      -   | ( ) + * ? { } ]  ^ - .
     *      .   { [ ^ -
     */

    boolean checkDig(){
        TRACE(B,"checkDig cursor: %s re %s\n",this.cursor,this.re);
        if (this.cursor == 0) return true;
        char ch = this.re.charAt(this.cursor);
        if (this.cursor >= 2){
            if (this.re.charAt(this.cursor-2) == '\\') return true;   // prev escaped
            if (this.re.charAt(this.cursor-1) == '\\') return true;   // current escaped
        }
        char prev = ' ';
        for (int cur = this.cursor-1; cur >= 0; cur--){
            if (this.re.charAt(cur) != ' '){
                prev = this.re.charAt(cur);
                break;
            }
        }
        if (prev == ' ') return true;
        TRACE(B,"checkDig prev %s ch %s\n",prev,ch);
        ck: {
            switch (ch){
            case '|': case '(': case '.':
                if ("{[^-".indexOf(prev) >= 0) break;
                break ck;
            case ')':
                if ("{[^-".indexOf(prev) >= 0) break;
                break ck;
            case '*': case '+': case '?':
                if ("|(?{[^-".indexOf(prev) >= 0) break;
                break ck;
            case '{':
                if ("|{+*}[{}^-.".indexOf(prev) >= 0) break;
                break ck;
            case '}':
                if ("|(+*?[]{}^-.".indexOf(prev) >= 0) break;
                break ck;
            case '[':
                if ("{[^-".indexOf(prev) >= 0) break;
                break ck;
            case ']':
                if ("|()+*?{}[]^-.".indexOf(prev) >= 0) break;
                break ck;
            case '^': case '-':
                if ("|()+*?{}]^-.".indexOf(prev) >= 0) break;
                break ck;
            default:
                break ck;
            }
            TRACE(B,"checkDig error %s %s\n",prev,ch);
            this.error = true;
            return false;
        } // ck
        return true;
    }

    /**
     * Skip whitespaces.
     *
     * @return     character, or -1 if no more available
     */

    private void gsep(){
        for (; this.cursor < this.re.length(); this.cursor++){
             if (this.re.charAt(this.cursor) != ' ') break;
        }
        this.startToken = this.cursor;
    }

    //---------- Symbols -----------------

    // Kinds of Symbols

    /* The symbols with kind >= S_CHAR denote characters; and may have a symset and optionally
     * a cset.
     */

    /** The kind of symbol for no symbol. */
    private static final int S_NONE = 0;

    /** The kind of symbol for a single character. */
    private static final int S_CHAR = 1;

    /** The kind of symbol for the character set denoted by dot. */
    private static final int S_DOT = 2;

    /** The kind of symbol for a character set. */
    private static final int S_SET = 3;

    /** The kind of symbol for a negated character set. */
    private static final int S_NSET = 4;

    /** A representation of the symbol kinds. */
    private static final String[] SYM_KINDS = new String[]{"","",".","",""};

    /** The reserved characters. */
    private static final String RESERVED = "|()+*?{}[]^-.\\\u03b5\u03a6";

    /** The characters that have a special rendering in strings. */
    private static final String SPECIAL = "\b\t\n\f\r\\\'\" ";
    private static final String SPECIAL_CHAR = "btnfr\\\'\" ";

    /** A symbol. */

    class Symbol {

        /** The kind of symbol. */
        int kind = S_NONE;

        /** The symbol if the kind is character. */
        int sym;

        /** The set of symbols, if the symbol is a set. */
        IntSet symset;

        /** The set of subclasses, if the symbol is a set of subclasses. */
        /* If element i-th of cset is true, then symClassTable[i] is an IntSet of the chars in subclass. */
        long cset;

        /**
         * Construct a symbol.
         */

        Symbol(){
        }

        /**
         * Deliver a string representing this symbol.
         *
         * @return     String
         */

        public String toString(){
            String str = "";
            int kind = this.kind;
            switch (kind){
            case S_NONE:
                break;
            case S_CHAR:
                str += symString(sym);
                break;
            case S_DOT:
                str += '.';
                break;
            case S_SET:
            case S_NSET:
                str += '[';
                boolean pos = true;
                if (this.kind == S_NSET){
                    str += "^";
                    pos = false;
                }
                str += symSetToString(this.symset,pos);
                str += ']';
                break;
            }
            return str;
        }

        /**
         * Tell if the specified symbol is equal to this one.
         *
         * @param      other symbol
         */

        public boolean equals(Symbol other){
            if (other == null) return false;
            return this.kind == other.kind && this.sym == other.sym &&
                this.symset.equals(other.symset);
        }
    }

    /**
     * Deliver a string representing the elements of the specified set of characters subclasses.
     *
     * @param      cset set
     * @return     string
     */

    String csetToString(long cset){
        String str = "";
        boolean first = true;
        for (int i = 0; i < 64; i++){
            if ((cset & 1L << i) == 0) continue;
            if (!first) str += ",";
            first = false;
            str += subclassToString(i);
        }
        if (str.length() > 1){
            str = '[' + str + ']';
        }
        return str;
    }

    /**
     * Deliver a string representing the specified characters subclass.
     *
     * @param      s subclass
     * @return     string
     */

    String subclassToString(int s){
        String str = "";
        if (s == BOT_SCLASS){
            str += "^";
        } else if (s == EOF_SCLASS){
            str += "$";
        } else {
            str += symSetToString(this.symClassTable[s]);
        }
        return str;
    }

    /**
     * Deliver a new <code>Symbol</code> representing the specified character.
     *
     * @param      c character
     * @return     symbol
     */

    Symbol newSymbolChar(int c){
        Symbol res = new Symbol();
        res.kind = S_CHAR;
        res.sym = c;
        return res;
    }

    //---------- Parenthetized expressions -----------------

    /**
     * Symbol part in FA's items: made of a sequence of integers, that behaves much
     * the same as a string. Each element represents the entering or leaving of a node in a path
     * thru the AST. The elements are indexes of AST nodes with flags attached telling the
     * entering or leaving (see below).
     * Aka "finished string", "tag", "parenthetized expression".
     */

    public class BSsymbol {

        /** An array of indexes of ast nodes. */
        public int[] arr;

        /**
         * Deliver a string representing this symbol using the specified map of indexes of
         * nodes.
         *
         * @return     string
         */

        public String toString(){
            return toString(this.arr.length);
        }

        /**
         * Deliver a string long at most the specified length, representing this symbol using
         * the specified map of indexes of nodes.
         *
         * @param      length maximum length
         * @return     string
         */

        public String toString(int len){
            String str = "";
            if (this.arr != null){
                for (int i = 0; i < len; i++){
                    str += BSeleToString(this.arr[i]);
                }
            }
            return str;
        }

        public String toRaw(){
            String str = "";
            if (this.arr != null){
                for (int i = 0; i < this.arr.length; i++){
                    if (i > 0) str += ".";
                    str += Integer.toString(arr[i]);
                }
            }
            return str;
        }

        /**
         * Tell if this symbol is equal to the specified one.
         *
         * @param      other other symbol
         * @return     <code>true</code> if it is equal, <code>false</code> otherwise
         */

        public boolean equals(BSsymbol other){
            return Arrays.equals(this.arr,other.arr);
        }

        /**
         * Tell if this symbol is equal to the specified one.
         *
         * @see        #equals(BSsymbol)
         */

        public boolean equals(Object other){
            return equals((BSsymbol) other);
        }

        /**
         * Return the hashcode for this symbol.
         *
         * @return     hash code value
         */

        public int hashCode(){
            int res = 0;
            for (int i = 0; i < this.arr.length; i++){
                res += arr[i];
            }
            return res;
        }

        /**
         * Compare this symbol with the specified one. It is fit only for sorting because
         * it sorts elements on their encodings.
         *
         * @param      other the symbol to compare
         * @return     &lt; = or &gt; 0 if this symbol precedes, is equal or follows the other
         */

        public int compareTo(BSsymbol other){
            int n = this.arr.length;
            if (other.arr.length < n) n = other.arr.length;
            int i = 0;
            int j = 0;
            while (n-- != 0){
                int c1 = this.arr[i++];
                int c2 = other.arr[j++];
                if (c1 != c2) return c1 - c2;
            }
            return this.arr.length - other.arr.length;
        }

        /**
         * Deliver a new symbol with the specified substring of this one.
         *
         * @param      begin start index of the string (inclusive)
         * @param      end index (exclusive)
         * @return     symbol
         */

        public BSsymbol substring(int begin, int end){
            BSsymbol sym = new BSsymbol();
            if (end < 0) end = this.arr.length + end;
            sym.arr = Arrays.copyOfRange(this.arr,begin,end);
            return sym;
        }

        /**
         * Deliver the length of this symbol.
         *
         * @return     length
         */

        public int length(){
            return this.arr.length;
        }

        /**
         * Deliver the element at the specified index.
         *
         * @param      i index
         * @return     element
         */

        public int eleAt(int i){
            if (i < 0) return this.arr[this.arr.length+i];
            return this.arr[i];
        }

        /**
         * Append the elements of the specified symbol to this one.
         *
         * @param      other the other symbol
         */

        public void concat(BSsymbol other){
            if (this.arr == null) this.arr = new int[0];
            int len = this.arr.length;
            this.arr = Arrays.copyOf(this.arr,this.arr.length+other.arr.length);
            System.arraycopy(other.arr,0,this.arr,len,other.arr.length);
        }

        /**
         * Tell if this symbol starts with the specified one.
         *
         * @param      other the other symbol
         * @return     <code>true</code> if it does, <code>false</code> otherwise
         */

        public boolean startsWith(BSsymbol other){
            if (other.arr.length > this.arr.length) return false;
            int i = other.arr.length;
            while (i-- != 0){
                if (this.arr[i] != other.arr[i]) return false;
            }
            return true;
        }

        /**
         * Tell if this symbol ends with the specified one.
         *
         * @param      other the other symbol
         * @return     <code>true</code> if it does, <code>false</code> otherwise
         */

        public boolean endsWith(BSsymbol other){
            if (other.arr.length > this.arr.length) return false;
            int i = other.arr.length;
            int l = this.arr.length;
            while (i-- != 0){
                if (this.arr[--l] != other.arr[i]) return false;
            }
            return true;
        }

        /**
         * Trace this symbol.
         */

        public void trace(){
            for (int i = 0; i < this.arr.length; i++){
                int ele = this.arr[i];
                int kind = BSeleKind(ele);
                Trc.out.printf("%s %s %s |%s| ast %s\n",
                    i,ele,BSeleKindToString(kind),BSeleToString(ele),BSeleToAstNum(ele));
            }
        }
    }

    /* BSsymbol elements
     *
     * b0..b27:   number of ast
     * b28..b29:  kind field
     *            b28:  entering
     *            b29:  leaving
     *            these denote the entering and leaving of ast nodes in bssymbols.
     *            This allows to have parentheses that represent the entering and leaving
     *            of leaves without introducing extra nodes in the ASTs.
     */

    /** Number of shifts for the kind field. */
    public static final int ELEKINDSHIFT = 28;

    /** Mask for the kind field. */
    public static final int ELEKIND = 1 << ELEKINDSHIFT;

    /** Value of the kind field denoting entering. */
    public static final int ELEOPEN = 1;

    /** Value of the kind field denoting leaving. */
    public static final int ELECLOSE = 2;

    /** Mask for the AST nr field. */
    public static final int ELEMASK = (1 << ELEKINDSHIFT)-1;

    /** Entering flag. */
    public static final int ELEOPENB = 1 << ELEKINDSHIFT;

    /** Leaving flag. */
    public static final int ELECLOSEB = 1 << (ELEKINDSHIFT+1);

    /** Mask denoting the kind field. */
    public static final int ELEKMASK = ELEOPENB | ELECLOSEB;

    /**
     * Deliver a string representing the direction of the path (entering, leaving, passing).
     *
     * @param      kind value of the kind field
     * @return     String
     */

    public String BSeleKindToString(int kind){
        return new String[]{"leaf","open","close"}[kind];
    }

    /**
     * Deliver the reference to the AST node of the specified element.
     *
     * @param      ele element
     * @return     reference to the AST node
     */

    AstNode BSeleToAst(int ele){
        return this.astMap[ele & ELEMASK];
    }

    /**
     * Deliver the number of the AST node of the specified element.
     *
     * @param      ele element
     * @return     number of the AST
     */

    public int BSeleToAstNum(int ele){
        return ele & ELEMASK;
    }

    /**
     * Deliver the kind of the specified element (direction of the path).
     *
     * @param      ele element
     * @return     find field
     */

    public int BSeleKind(int ele){
        return ele >> ELEKINDSHIFT;
    }

    /**
     * Deliver the element denoting the specified AST and kind.
     *
     * @param      ast reference to the AST
     * @param      kind kind field
     * @return     element
     */

    public int astToBSele(AstNode ast, int kind){
        return ast.seq + (kind << ELEKINDSHIFT);
    }

    /**
     * Tell if the specified element is a terminal (different from an epsilon).
     *
     * @param      ele element
     * @return     <code>true</code> if it is, <code>false</code> otherwise
     */

    public boolean isBSeleTerminal(int ele){
        return (ele & ELEKMASK) == 0 && this.astMap[ele].kind == A_LEA;
    }

    /**
     * Deliver a string representing the specified element using the specified map between
     * AST numbers and nodes.
     *
     * @param      ele element
     * @return     String
     */

    private String BSeleToString(int ele){
        String str = "";
        int eleKind = BSeleKind(ele);
        AstNode ast = this.astMap[ele & ELEMASK];
        if (eleKind == ELEOPEN){               // node entry
            str += "(";
        } else if (eleKind == ELECLOSE){       // node exit
            str += ")";
        } else {
            if (ast.kind == A_LEA){            // terminal
                str += ast.sym;
            } else if (ast.kind == A_ALT){
                str += "|";
            } else if (ast.kind == A_CON){
                str += "\u00b7";
            } else if (ast.kind == A_EMP){
                str += "\u03b5";
            } else if (ast.kind == A_NUL){
                str += "\u03a6";
            } else {
                str += "\u03b5";               // a group without open or close flags acts as empty
            }
        }
        str += ast.pos;
        if (ast.seq != ast.pos){
           str += "." + ast.seq;
        }
        return str;
    }

    /**
     * Deliver a new BSsymbol whose elements are obtained by concatenating the ones contained
     * in the arguments.
     *
     * @param      args BSsymbols, arrays of elements, or elements
     * @return     BSsymbol
     */

    private BSsymbol newBSsymbol(Object... args){
        BSsymbol sym = new BSsymbol();
        sym.arr = new int[0];
        for (Object arg : args){
            if (arg instanceof BSsymbol){
                BSsymbol bs = (BSsymbol)arg;
                int len = sym.arr.length;
                sym.arr = Arrays.copyOf(sym.arr,sym.arr.length+bs.arr.length);
                System.arraycopy(bs.arr,0,sym.arr,len,bs.arr.length);
            } else if (arg instanceof int[]){   // array
                int len = sym.arr.length;
                int[] arr = (int[])arg;
                sym.arr = Arrays.copyOf(sym.arr,sym.arr.length+arr.length);
                System.arraycopy(arr,0,sym.arr,len,arr.length);
            } else {
                sym.arr = Arrays.copyOf(sym.arr,sym.arr.length+1);
                sym.arr[sym.arr.length-1] = (int)arg;
            }
        }
        return sym;
    }

    /**
     * Deliver a new BSsymbol whose elements are the ones contained in the argument.
     *
     * @param      arr array of elements
     * @param      len number of elements
     * @return     BSsymbol
     */

    private BSsymbol newBSsymbol(int[] arr, int len){
        BSsymbol sym = new BSsymbol();
        sym.arr = Arrays.copyOf(arr,len);
        return sym;
    }

    /**
     * Deliver a new BSsymbol whose elements are the ones of the first symbol concatenated
     * with the ones of the second element.
     *
     * @param      bs1 first symbol
     * @param      bs2 second symbol
     * @return     BSsymbol
     */

    private BSsymbol newBSsymbolConc(BSsymbol bs1, BSsymbol bs2){
        BSsymbol sym = new BSsymbol();
        sym.arr = Arrays.copyOf(bs1.arr,bs1.arr.length+bs2.arr.length-1);
        System.arraycopy(bs2.arr,0,sym.arr,bs1.arr.length-1,bs2.arr.length);
        return sym;
    }

    //---------- AST's -----------------

    // kinds of AST nodes

    /** The kind of an AST node for a leaf. */
    private static final int A_LEA = 0;

    /** The kind of an AST node for an alternative. */
    private static final int A_ALT = 1;

    /** The kind of an AST node for a concatenation. */
    private static final int A_CON = 2;

    /** The kind of an AST node for a group. */
    private static final int A_GRO = 3;

    /** The kind of an AST node for the empty string. */
    private static final int A_EMP = 4;

    /** The kind of an AST node for the empty set. */
    private static final int A_NUL = 5;

    /** The strings representing the kinds of AST node. */
    private static final String[] astIcon = new String[]{
        "term",    // "\u03a3",  // sigma
        "|",       // alt
        "conc",    // "\u2219",  // bullet
        "()",      // group
        "eps",     // "\u03b5",  epsilon
        "phi"};    // "\u03a6"}; // phi

    // kinds for groups

    /** The group kind of an AST node for the normal () group. */
    private static final int G_GRO = 0;

    /** The group kind of an AST node for the optional ()? group. */
    private static final int G_OPT = 1;

    /** The group kind of an AST node for the Kleene ()* group. */
    private static final int G_RE0 = 2;

    /** The group kind of an AST node for the positive ()+ group. */
    private static final int G_RE1 = 3;

    /** The group kind of an AST node for the interval (aka bounded) groups. */
    private static final int G_RE2 = 4;

    /** String representing group kinds. */
    private static final String[] groupKindStr = new String[]{
        "GRO","OPT","RE0","RE1","RE2"};

    /** Strings representing group symbols in RE strings. */
    private static final String[] groupSym = new String[]{
        "","?","*","+",""};

    /** String representing of capturing groups. */
    private static final String[] groupIconC = new String[]{
        "()","()?","()*","()+","(){}"};

    /**
     * Deliver a string representing the group of the specified AST in compact form.
     *
     * @param      ast reference to the AST
     * @return     String
     */

    private String groupIcon(AstNode ast){
        return groupIconC[ast.groupKind];
    }

    /**
     * Deliver a string representing the kind of the specified AST in compact form.
     *
     * @param      ast reference to the AST
     * @return     String
     */

    private String astKindString(AstNode ast){
        String str = astIcon[ast.kind];
        if (ast.kind == A_GRO){
            str = groupIcon(ast);
        }
        if (ast.altnr != 0) str += " #|" + ast.altnr;
        return str;
    }

    /** An AST node, representing a subexpression. */

    class AstNode implements Cloneable {

        /** The serial number. */
        int seq;

        /** The reference to the brother. */
        AstNode bro;

        /** The reference to the son. */
        AstNode son;

        /** The reference to the father. */
        AstNode fat;

        /** The kind of node. */
        int kind;

        /** The symbol if the kind is leaf. */
        Symbol sym;

        /** The kind of group (if group). */
        int groupKind;

        /** The lower bound of the bounded group. */
        int lowerbound;

        /** The upper bound of the bounded group (-1 = infinite, 0 = none). */
        int upperbound;

        /** The position: sequence of indexes of level numbering. To show the LST only. */
        int pos;

        /** The index in the RE as string. */
        int cursor;

        /** The number of alternative (when this node is an alternative). */
        int altnr;
        
        /** Whether the node generates the empty string. */
        boolean isNull;

        /** The init set. */
        Set<BSsymbol> ini = new HashSet<BSsymbol>();

        /** The finish set. */
        Set<BSsymbol> fin = new HashSet<BSsymbol>();

        /** The digrams set. */
        Set<BSsymbol> dig = new HashSet<BSsymbol>();

        /**
         * Construct an AST node.
         *
         * @param      kind of memory
         */

        AstNode(){
        }

        /**
         * Deliver a shallow copy of this object.
         *
         * @return     copy
         */

        public Object clone() throws CloneNotSupportedException {
            return super.clone();
        }

        /**
         * Deliver a string representing this node.
         *
         * @return     String
         */

        public String toString(){
            String str = "ast seq: " + this.seq;
            str += " pos:";
            str += this.pos;
            str += " ";
            if (this.altnr != 0) str += " |" + this.altnr + " ";
            str += (this.kind == A_GRO ? groupIcon(this) : astIcon[this.kind]);
            if (this.sym != null && this.kind == A_LEA){
                str += " " + SYM_KINDS[this.sym.kind] + this.sym.toString();
            }
            str += " at: ";
            str += this.cursor;
            if (this.bro != null){
                str += " bro: ";
                str += this.bro.seq;
            }
            if (this.son != null){
                str += " son: ";
                str += this.son.seq;
            }
            if (this.fat != null){
                str += " fat: ";
                str += this.fat.seq;
            }
            str += " Null: " + this.isNull;
            str += " Ini: ";
            str += bsSetToString(this.ini);
            str += " Fin: ";
            str += bsSetToString(this.fin);
            str += " Dig: ";
            str += bsSetToString(this.dig);
            return str;
        }

        /**
         * Deliver a string representing the tree of this node.
         *
         * @return     String
         */

        public String toTree(){
            StringBuilder sb = new StringBuilder();
            toTree(sb,this);
            return sb.toString();
        }
        public void toTree(StringBuilder sb, AstNode ast){
            sb.append("<");
            switch (ast.kind){
            case A_LEA: sb.append(ast.sym.toString()); break;
            case A_ALT: sb.append("|"); break;
            case A_CON: sb.append("∙"); break;
            case A_GRO: sb.append(groupIcon(ast)); break;
            case A_EMP: sb.append("ε"); break;
            case A_NUL: sb.append("Φ"); break;
            }
            for (AstNode a = ast.son; a != null; a = a.bro){
                if (a != ast.son) sb.append(",");
                toTree(sb,a);
            }
            sb.append(">");
        }

        /**
         * Deliver a string representing the RE rooted in this node.
         *
         * @return     String
         */

        public String toRE(){
            StringBuilder sb = new StringBuilder();
            toRE(sb,false);
            return sb.toString();
        }

        /**
         * Deliver a string representing the numbered RE rooted in this node.
         *
         * @return     String
         */

        public String toNumRE(){
            StringBuilder sb = new StringBuilder();
            toRE(sb,true);
            return sb.toString();
        }

        /**
         * Append to the specified string builder a string representing the RE rooted
         * in this node.
         *
         * @param      sb string builder
         * @param      numb <code>true<code> to add numbers, <code>false</code> otherwise.
         */

        private void toRE(StringBuilder sb, boolean numb){
            toRE(sb,numb,0);
        }
        private void toRE(StringBuilder sb, boolean numb, int lev){
            if (this.kind == A_LEA){          // leaf
                if (numb){
                    sb.append("(");
                    sb.append(this.pos);
                }
                sb.append(this.sym.toString());
                if (numb){
                    sb.append(this.pos);
                    sb.append(")");
                    sb.append(this.pos);
                }
            } else if (this.kind == A_ALT){   // alt
                if (this.son.kind == A_ALT || numb){
                    sb.append("(");
                    if (numb) sb.append(this.pos);
                }
                for (AstNode i = this.son; i != null; i = i.bro){
                    if (i != this.son) sb.append("|");
                    i.toRE(sb,numb,lev+1);
                }
                if (this.son.kind == A_ALT || numb){
                    sb.append(")");
                    if (numb) sb.append(this.pos);
                }
            } else if (this.kind == A_CON){   // conc
                if (this.son.kind == A_ALT || numb){
                    sb.append("(");
                    if (numb) sb.append(this.pos);
                }
                for (AstNode i = this.son; i != null; i = i.bro){
                    i.toRE(sb,numb,lev+1);
                }
                if (this.son.kind == A_ALT || numb){
                    sb.append(")");
                    if (numb) sb.append(this.pos);
                }
            } else if (this.kind == A_EMP){   // empty
                sb.append("\u03b5");
                if (numb) sb.append(this.pos);
            } else if (this.kind == A_NUL){   // empty set
                sb.append("\u03a6");
                if (numb) sb.append(this.pos);
            } else {                          // group
                sb.append("(");
                if (numb) sb.append(this.pos);
                if (this.son != null){
                    this.son.toRE(sb,numb,lev+1);
                    sb.append(")");
                    if (numb) sb.append(this.pos);
                }
                sb.append(groupSym[this.groupKind]);
                if (this.groupKind == G_RE2){
                    sb.append("{");
                    if (this.lowerbound > 0){
                        sb.append(this.lowerbound);
                    }
                    if (this.upperbound > 0){
                        if (this.upperbound != this.lowerbound){
                            sb.append(",");
                            sb.append(this.upperbound);
                        }
                    } else {
                        sb.append(",");
                    }
                    sb.append("}");
                }
            }
        }
        
        /**
         * Append a space if the last character of the specified string is numeric.
         *
         * @param      sb string
         */

        private void addSpace(StringBuilder sb){
            if (sb.length() == 0) return;
            char c = sb.charAt(sb.length()-1);
            if ('0' <= c && c <= '9') sb.append(" ");
        }
        
        /**
         * Append the specified son as a son of this node.
         *
         * @param      son son
         */
         
        AstNode addSon(AstNode son){
            son.fat = this;
            if (this.son == null){
                this.son = son;
            } else {
                // find last brother and append the new one to it
                AstNode prev = null;
                for (AstNode t = this.son; t != null; t = t.bro){
                    prev = t;
                }
                prev.bro = son;
            }
            return son;
        }
        
        /**
         * Deliver a clone of the subtree rooted in this one. The attributes are
         * empty.
         *
         * @return  root of clone
         */

        AstNode treeClone(){
            AstNode res = new AstNode();
            res.seq = astSeq++;
            res.pos = this.pos;
            res.kind = this.kind;
            res.sym = this.sym;
            res.groupKind = this.groupKind;
            res.lowerbound = this.lowerbound;
            res.upperbound = this.upperbound;
            res.cursor = this.cursor;
            res.altnr = this.altnr;
            if (res.seq >= astMap.length){
                astMap = Arrays.copyOf(astMap,astMap.length+10);
            }
            // add it to astmap
            astMap[res.seq] = res;
            for (AstNode n = this.son; n != null; n = n.bro){
                AstNode c = n.treeClone();
                res.addSon(c);
            }
            return res;
        }
    }

    /**
     * Deliver a string containing as many blanks as the specified level times 2.
     *
     * @param      lev level of indentation
     * @return     string
     */

    String indent(int lev){
        String res = "";
        for (int i = 0; i < lev; i++){
            res += "  ";
        }
        return res;
    }

    /**
     * Deliver a string representing the specified character set using the bracketed
     * representation if it is a set.
     *
     * @param      set character set
     * @param      pos <code>true</code> if the elements that are true in the array
     *             represent characters that are in the set, <code>false</code> if such
     *             elements represent character that are not in the set
     */

    static String symSetToString(IntSet set){
        return symSetToString(set,true);
    }
    private static String symSetToString(IntSet set, boolean pos){
        if (set == null) return "null";
        StringBuilder sb = new StringBuilder();
        if (!pos){
            IntSet compl = new IntSet(0,Character.MAX_VALUE);
            compl.sub(set);
            set = compl;
        }            
        int n = set.toRanges(null);
        int[] arr = new int[n];
        set.toRanges(arr);
        for (int i = 0; i < arr.length; i += 2){
            sb.append(symString(arr[i]));
            if (arr[i+1] != arr[i]+1 && arr[i+1] != arr[i]){      // range
                sb.append("-");
                sb.append(symString(arr[i+1]));
            } else if (arr[i+1] != arr[i]){
                sb.append(symString(arr[i+1]));
            }
        }
        return sb.toString();
    }

    /**
     * Deliver a string representing the specified character, with a printable
     * representation when the character is not printable.
     *
     * @param      sym character
     * @return     string
     */

    private static String symString(int sym){
        String res = null;
        if (RESERVED.indexOf(sym) >= 0){            // reserved
            res = "\\" + (char)sym;
        } else if (SPECIAL.indexOf(sym) >= 0){      // special
            int idx = SPECIAL.indexOf(sym);
            res = "\\" + SPECIAL_CHAR.charAt(idx);
        } else if (sym == BOT){
            res = "^";
        } else if (sym == EOF){
            res = "$";
        } else if ((sym < ' ') || (sym > '~')){     // not printable
            res = "\\u";
            int rem;
            for (int z = 0; z < 4; z++){
                rem = (sym>>>((4-z-1)*4)) & 0xf;
                res += (char)(rem + ((rem <= 9) ? '0' : 'a' - 10));
            }
        } else {
            res = String.valueOf((char)sym);
        }
        return res;
    }
    
    /**
     * Deliver a string representing the specified set of BSsymbols.
     *
     * @param      set set of BSsymbols
     * @return     string
     */

    private String bsSetToString(Set<BSsymbol> set){
        String str = "";
        str += "{";
        if (set == null){
            str += "null";
        } else {
            BSsymbol[] arr = set.toArray(new BSsymbol[0]);
            Arrays.sort(arr,new Comparator<BSsymbol>(){
                public int compare(BSsymbol s1, BSsymbol s2){
                    return s1.compareTo(s2);
                }});
            boolean first = true;
            for (int i = 0; i < arr.length; i++){
                if (first){
                    first = false;
                } else {
                    str += ", ";
                }
                str += arr[i].toString();
                // str += arr[i].toRaw();
            }
        }
        str += "}";
        return str;
    }
    
    /** Sequence number of ast nodes. */
    private int astSeq;

    /** Map from integers to ast nodes. */
    AstNode[] astMap;

    /**
     * Deliver a new AST node with the specified kind.
     *
     * @param      kind kind
     * @return     reference to the node
     */

    private AstNode newAstNode(int kind){
        AstNode node = new AstNode();
        node.kind = kind;
        node.cursor = this.startToken;
        node.seq = this.astSeq++;
        TRACE(A,"newAstNode %s %s\n",node.seq,astKindString(node));
        return node;
    }

    /**
     * Trace the subtree rooted in the specified ast.
     *
     * @param      ast reference to the AST node
     * @param      lev dept of the node
     */

    public void traceAst(){
        traceAst(this.astRoot,0);
    }
    public void traceAst(AstNode ast){
        traceAst(ast,0);
    }
    public void traceAst(AstNode ast, int lev){
        for (AstNode a = ast; a != null; a = a.bro){
            String str = "" + a.seq + " p" + a.pos;
            if (a.altnr != 0) str += " |" + a.altnr + " ";
            str += " " + (a.kind == A_GRO ? groupIcon(a) : astIcon[a.kind]);
            if (a.sym != null && a.kind == A_LEA){
                str += " " + SYM_KINDS[a.sym.kind] + a.sym.toString();
            }
            if (this.groupNumbers != null){
                for (int i = 0; i < this.groupNumbers.length; i++){
                    if (BSeleToAstNum(this.groupNumbers[i]) == a.seq){
                        str += " group " + i;
                        break;
                    }
                }
            }
            str += " " + a.toRE();
            Trc.out.printf("%s%s\n",indent(lev),str);
            traceAst(a.son,lev+1);
        }
    }

    /**
     * Trace the map of ast nodes
     */

    public void traceAstMap(){
        for (int i = 0; i < this.astMap.length; i++){
            if (this.astMap[i] == null) break;
            Trc.out.printf("astMap[%s] = %s\n",i,this.astMap[i]);
        }
    }

    /**
     * Deliver a string representing the numbered RE.
     *
     * @return     string
     */

    public String toNumRE(){
        return this.astRoot.toNumRE();
    }

    /**
     * Visit all the nodes rooted in the specified one and set in them their position,
     * father and sequence number, ordered as the positions.
     *
     * @param      ast reference to the AST node
     * @param      pos reference to the position
     * @param      fat reference to the AST node father
     */

    private void setPosAst(AstNode ast, AstNode fat){
        if (ast == null) return;
        ast.fat = fat;
        ast.seq = this.astSeq++;
        ast.pos = ast.seq;
        this.astMap[ast.seq] = ast;
        int n = 1;
        for (AstNode a = ast.son; a != null; a = a.bro){
            setPosAst(a,ast);
            n++;
        }
    }

    /**
     * Compute the ini, fin and dig attributes for the subtree rooted in the specified AST node
     * in which only terminal symbols are numbered.
     *
     * @param      ast reference to the AST node
     */

    /* Ini tells the numbered terminal that starts the strings generated by the ast,
     * if any, Fin the same, but that ends strings, Dig all the couples of numbered
     * terminal, isNull whether the string can be the empty one.
     *
     * For all kinds of asts this is quite straightforward, except for bounded
     * groups, for which there is a need first to generate as many clones of the
     * body as the uppoer bound of the group, or the lower bound if {n,}.
     * Then, the predicates are computed taking into account that each group has
     * a number of mandatory bodies lo (possibly 0), and an optional number of
     * additional bodies hi (possibly 0 and infinite), and a maximum number nbodies
     * of bodies, which is lo+hi. Note that when the body is nullable, lo = 0.
     * Let be firsth the number of the first optional body.
     * The predicates are
     *
     *    ini  the ini of the first cloned son
     *    fin  the fin of the first cloned son U_i=[firsth:nbodies) fin(i)
     *    dig  U_i=[0:nbodies) dig(i)
     *
     * When nbodies = infinite, dig also contains fin(last)ini(first).
     */

    private void computeAstBS(AstNode ast){
        computeAstBS(ast,0);
    }
    private void computeAstBS(AstNode ast, int lev){
        TRACE(E,"%scomputeAstBS: %s sub-re: %s\n",indent(lev),ast,ast.toRE());
        switch (ast.kind){
        case A_LEA:                           // terminal
            ast.isNull = false;
            ast.ini = new HashSet<BSsymbol>();
            ast.ini.add(newBSsymbol(ast.seq));
            ast.fin = new HashSet<BSsymbol>();
            ast.fin.add(newBSsymbol(ast.seq));
            ast.dig = new HashSet<BSsymbol>();
            break;
        case A_EMP:                           // empty
            ast.isNull = true;
            ast.ini = new HashSet<BSsymbol>();
            ast.fin = new HashSet<BSsymbol>();
            ast.dig = new HashSet<BSsymbol>();
            break;
        default:
            ast.ini = new HashSet<BSsymbol>();
            ast.fin = new HashSet<BSsymbol>();
            ast.dig = new HashSet<BSsymbol>();
            if (ast.kind != A_GRO || ast.groupKind != G_RE2){
                for (AstNode a = ast.son; a != null; a = a.bro){
                    computeAstBS(a,lev+1);
                }
            }
        }
        switch (ast.kind){
        case A_ALT:                                    // alternative
            TRACE(E,"%scomputeAstBS: alt start %s\n",indent(lev),ast);
            ast.isNull = false;
            if (ast.son == null) ast.isNull = true;
            for (AstNode a = ast.son; a != null; a = a.bro){
                if (a.isNull) ast.isNull = true;
                ast.ini.addAll(a.ini);
                ast.fin.addAll(a.fin);
                ast.dig.addAll(a.dig);
            }
            TRACE(E,"%scomputeAstBS: alt end %s\n",indent(lev),ast);
            break;
        case A_CON:                                // concatenation
            TRACE(E,"%scomputeAstBS: conc start %s\n",indent(lev),ast);
            boolean iniDone = false;
            AstNode lastNotNull = ast.son;         // in case all are null
            HashSet<BSsymbol> digfin = new HashSet<BSsymbol>();
            ast.isNull = true;
            for (AstNode a = ast.son; a != null; a = a.bro){
                TRACE(E,"%scomputeAstBS: conc ele %s\n",indent(lev),a);
                if (!a.isNull) lastNotNull = a;
                if (!a.isNull) ast.isNull = false;
                if (!iniDone){
                    ast.ini.addAll(a.ini);
                    if (!a.isNull){
                        iniDone = true;
                    }
                }
                ast.dig.addAll(a.dig);
                if (a != ast.son){                // not first
                    BSsymbol[] iniarr = a.ini.toArray(new BSsymbol[0]);
                    BSsymbol[] finarr = digfin.toArray(new BSsymbol[0]);
                    for (int i = 0; i < finarr.length; i++){
                        for (int j = 0; j < iniarr.length; j++){
                            ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                        }
                    }
                }

                // compute the fin of all elements up to and including the current one
                digfin.clear();
                for (AstNode aa = lastNotNull; aa != null; aa = aa.bro){
                    digfin.addAll(aa.fin);
                    if (aa == a) break;
                }
            }
            for (AstNode a = lastNotNull; a != null; a = a.bro){
                ast.fin.addAll(a.fin);       // union of all those of the null tail + last not null
            }
            TRACE(E,"%scomputeAstBS: conc end\n",indent(lev));
            break;
        case A_GRO:                               // sub-re
            TRACE(E,"%scomputeAstBS: group start %s body %s\n",indent(lev),ast,ast.son);
            if (ast.groupKind == G_RE1 || ast.groupKind == G_GRO || ast.groupKind == G_RE2){
                ast.isNull = ast.son.isNull;
                if (ast.groupKind == G_RE2 && ast.lowerbound == 0){
                    ast.isNull = true;
                }
            } else {
                ast.isNull = true;
            }
            BSsymbol[] iniarr = null;
            BSsymbol[] finarr = null;
            if (ast.groupKind != G_RE2){
                ast.ini.clear();
                ast.ini.addAll(ast.son.ini);
                ast.dig.addAll(ast.son.dig);
                ast.fin.clear();
                ast.fin.addAll(ast.son.fin);
                TRACE(E,"%scomputeAstBS: group adding son dig %s\n",
                    indent(lev),bsSetToString(ast.son.dig));
                ast.dig.addAll(ast.son.dig);
            }

            if (ast.groupKind == G_RE0 || ast.groupKind == G_RE1){
                iniarr = ast.son.ini.toArray(new BSsymbol[0]);
                finarr = ast.son.fin.toArray(new BSsymbol[0]);
                for (int i = 0; i < finarr.length; i++){
                    for (int j = 0; j < iniarr.length; j++){
                        BSsymbol step = newBSsymbol(finarr[i],iniarr[j]);
                        TRACE(E,"%scomputeAstBS: group step dig %s\n",indent(lev),step);
                        ast.dig.add(step);
                    }
                }
            }

            if (ast.groupKind == G_RE2){
                // deep clone the ast tree of the son as many times as needed
                // and also compute the ini, fin, dig sets for them
                // this is because BSsymbols contain ast seq, which here
                // must be different, but they are also used to number symbols,
                // and here they must keep the original ones (stored in pos)
                // We have a fixed part of lowerbound bodies and an optional part
                // of hipart bodies (if hipart > 0).
                // The optional ones have a bypass.
                // If hipart < 0, the last body can be repeated.
                //     {n}   lo = n, hi = n
                //     {n,m} lo = n, hi = m
                //     {n,}  lo = n, hi = -1
                //     {,n}  lo = 0, hi = n
                int nbodies = ast.upperbound;
                if (ast.upperbound < 0){
                    nbodies = ast.lowerbound;
                }
                int firsth = ast.lowerbound;
                TRACE(E,"%scomputeAstBS: re2 lo %s hi %s first hi %s\n",indent(lev),
                    ast.lowerbound,nbodies,firsth);
                AstNode[] arr = new AstNode[nbodies];
                TRACE(E,"%scomputeAstBS: re2 cloning bodies\n",indent(lev));
                for (int j = 0; j < arr.length; j++){
                    arr[j] = ast.son.treeClone();
                    TRACE(E,"%scomputeAstBS: re2 %s cloned %s\n",indent(lev),ast.son,arr[j]);
                    #ifdef DEBUG
                    if ((FL_E & this.trc) != 0){
                        traceAst(arr[j]);
                    }
                    #endif
                    computeAstBS(arr[j],lev+1);
                    TRACE(E,"%scomputeAstBS: re2 computed %s\n",indent(lev),arr[j]);
                    TRACE(E,"%scomputeAstBS: re2 adding son dig %s\n",
                        indent(lev),bsSetToString(arr[j].dig));
                }
                #ifdef DEBUG
                if ((FL_E & this.trc) != 0){
                    Trc.out.printf("%sbodies\n",indent(lev));
                    for (int j = 0; j < arr.length; j++){
                        Trc.out.printf("%s   %s: %s\n",indent(lev),j,arr[j]);
                    }
                }
                #endif
                TRACE(E,"%scomputeAstBS: re2 end cloning bodies\n",indent(lev));
                if (arr.length == 0 || arr[0].isNull || ast.lowerbound == 0){
                    firsth = 0;
                    ast.isNull = true;
                }

                TRACE(E,"%scomputeAstBS: re2 ini %s\n",indent(lev),arr[0].ini);
                ast.ini.addAll(arr[0].ini);
                // then produce the digrams
                TRACE(E,"%scomputeAstBS: re2 digrams\n",indent(lev));
                for (int j = 0; j < arr.length; j++){
                    AstNode a = arr[j];
                    ast.dig.addAll(a.dig);
                    if (j < arr.length-1){                // not last
                        TRACE(E,"%scomputeAstBS: re2 dig %s - %s\n",indent(lev),a,arr[j+1]);
                        iniarr = arr[j+1].ini.toArray(new BSsymbol[0]);
                        finarr = a.fin.toArray(new BSsymbol[0]);
                        for (int i = 0; i < finarr.length; i++){
                            for (int k = 0; k < iniarr.length; k++){
                                BSsymbol d = newBSsymbol(finarr[i],iniarr[k]);
                                TRACE(E,"%s   dig %s\n",indent(lev),d);
                                ast.dig.add(d);
                            }
                        }
                    }
                }
                if (arr.length > 0 && ast.upperbound < 0){        // {n,} add loop
                    iniarr = arr[arr.length-1].ini.toArray(new BSsymbol[0]);
                    finarr = arr[arr.length-1].fin.toArray(new BSsymbol[0]);
                    for (int i = 0; i < finarr.length; i++){
                        for (int k = 0; k < iniarr.length; k++){
                            BSsymbol d = newBSsymbol(finarr[i],iniarr[k]);
                            TRACE(E,"%s   dig %s\n",indent(lev),d);
                            ast.dig.add(d);
                        }
                    }
                }
                if (firsth > 0){
                    firsth--;
                }
                TRACE(E,"%scomputeAstBS: re2 finals from %s\n",indent(lev),firsth);
                for (int j = firsth; j < arr.length; j++){
                    AstNode a = arr[j];
                    TRACE(E,"%scomputeAstBS: re2 fin %s\n",indent(lev),a);
                    ast.fin.addAll(a.fin);
                }
            }
            TRACE(E,"%scomputeAstBS: group end\n",indent(lev));
            break;
        }
        if (ast.pos == 0){           // top node
            AstNode e = this.eofAst;
            if (ast.isNull){
                ast.ini.add(newBSsymbol(e.seq));
            }
            BSsymbol[] finarr = ast.fin.toArray(new BSsymbol[0]);
            for (int i = 0; i < finarr.length; i++){
                ast.dig.add(newBSsymbol(finarr[i],e.seq));
            }
        }
        TRACE(E,"%scomputeAstBS done: %s\n",indent(lev),ast);
    }

    /**
     * Compute the ini, fin and dig attributes for the subtree rooted in the specified AST node
     * in which all symbols and metasymbols are numbered.
     *
     * @param      ast reference to the AST node
     */

    /*
     * Null(eps_p) = true
     * Ini(eps_p) = {(_p}
     * Fin(eps_p) = {)_p}
     * Dig(eps_p) = {(_p)_p}
     *
     * Null(a_p) = false
     * Ini(a_p) = {(_p a_p}
     * Fin(a_p) = {a_p)_p}
     * Dig(a_p) = {Ini(a_p) U Fin(a_p)}
     *
     * Null(e_h = e_k|...|el) = Null(e_k) \/ ... \/ Null(e_l)
     * Ini(e_h = e_k|...|e_l) = Ini(e_k) U ... U Ini(e_l)
     * Fin(e_h = e_k|...|e_l) = Fin(e_k) U ... U Fin(e_l)
     * Dig(e_h = e_k|...|e_l) = ( (_h .(Ini(e_k) U ... U Ini(e_l)) ) U
     *     ( (Fin(e_k) U ... U Fin(e_l)) .)_h )
     *
     * Null(e_h = e_k ... e_l) = Null(e_k) /\ ... /\ Null(e_l)
     * Ini(e_h = e_k ... e_l) = {(_h}
     * Fin(e_h = e_k ... e_l) = {)_h}
     * Dig(e_h = e_k ... e_l) = Dig(e_k) U ... U Dig(e_l) U Fin(e_k)Ini(e_k+1) U ... U
     *     Fin(e_k_l-1)Ini(e_l) U ((_h .Ini(e_k)) U (Fin(e_l) .)_h)
     *
     * Null(e_h = (e_k)*) = true
     * Ini(e_h = (e_k)*) = {(_h}
     * Fin(e_h = (e_k)*) = {)_h}
     * Dig(e_h = (e_k)*) = Dig(e_k) U ((_h .Ini(e_k)) U (Fin(e_k) .)_h) U Fin(e_k)Ini(e_k) U {(_heps_h)_h}
     *
     * Null(e_h = (e_k)+) = Null(e_k)
     * Ini(e_h = (e_k)+) = {(_h}
     * Fin(e_h = (e_k)+) = {)_h}
     * Dig(e_h = (e_k)+) = Dig(e_k) U ((_h .Ini(e_k)) U (Fin(e_l) .)_h) U Fin(e_k)Ini(e_k)
     *
     * Null(e_h = (e_k)) = Null(e_k)
     * Ini(e_h = (e_k)) = {(_h}
     * Fin(e_h = (e_k)) = {)_h}
     * Dig(e_h = (e_k)) = Dig(e_k) U ((_h .Ini(e_k)) U (Fin(e_l) .)_h)
     *
     * Null(e_h = (e_k)?) = true
     * Ini(e_h = (e_k)?) = {(_h}
     * Fin(e_h = (e_k)?) = {)_h}
     * Dig(e_h = (e_k)?) = Dig(e_k) U ((_h .Ini(e_k)) U (Fin(e_l) .)_h) U {(_h eps_h)_h}
     *
     * Bounded groups
     * They have a number of iterations (bodies) q, which is m, if specified, otherwise n.
     * Of q, n are always present (n = 0 if not specified), and the remaining ones are optional.
     * The predicates are:
     *   
     *    Null(e_h = (e_k){n,m}) = Null(e_k) \/
     *         true                                    if (n,)
     *     Ini(e_h = (e_k){n,m}) = {(_h}
     *     Fin(e_h = (e_k){n,m}) = {)_h}
     *     Dig(e_h = (e_k){n,m}) = 
     *         Dig(e_h_1 ... e_h_q) U                  where e_h_1, ... e_h_q, are deep clones of e_h
     *         (Fin(e_n) .)_h) U ... (Fin(e_q) .)_h) U
     *         (Fin(e_n) . Ini(e_n))                   if (n,)
     */

    private void computeAstDig(AstNode ast){
        TRACE(E,"computeAstDig: %s sub-re: %s\n",ast,ast.toRE());
        switch (ast.kind){
        case A_LEA:                               // terminal
            ast.isNull = false;
            ast.ini = new HashSet<BSsymbol>();
            ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN),ast.seq));
            ast.fin = new HashSet<BSsymbol>();
            ast.fin.add(newBSsymbol(ast.seq,astToBSele(ast,ELECLOSE)));
            ast.dig = new HashSet<BSsymbol>();
            ast.dig.addAll(ast.ini);
            ast.dig.addAll(ast.fin);
            break;
        case A_EMP:                               // empty
            ast.isNull = true;                    // empty
            ast.ini = new HashSet<BSsymbol>();
            ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
            ast.fin = new HashSet<BSsymbol>();
            ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
            ast.dig = new HashSet<BSsymbol>();
            ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE)));
            break;
        default:
            ast.ini = new HashSet<BSsymbol>();
            ast.fin = new HashSet<BSsymbol>();
            ast.dig = new HashSet<BSsymbol>();
            if (ast.kind != A_GRO || ast.groupKind != G_RE2){
                for (AstNode a = ast.son; a != null; a = a.bro){
                    computeAstDig(a);
                }
            }
        }
        switch (ast.kind){
        case A_ALT:                       // alternative
            TRACE(E,"computeAstDig: alt start %s\n",ast);
            ast.isNull = false;
            ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
            ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
            Set<BSsymbol> ini = new HashSet<BSsymbol>();
            Set<BSsymbol> fin = new HashSet<BSsymbol>();
            if (ast.son == null) ast.isNull = true;
            for (AstNode a = ast.son; a != null; a = a.bro){
                ast.isNull |= a.isNull;
                ini.addAll(a.ini);
                fin.addAll(a.fin);
                ast.dig.addAll(a.dig);
            }
            BSsymbol[] iniarr = ini.toArray(new BSsymbol[0]);
            for (int i = 0; i < iniarr.length; i++){
                ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]));   // enter subexpression
            }
            BSsymbol[] finarr = fin.toArray(new BSsymbol[0]);
            for (int i = 0; i < finarr.length; i++){
                ast.dig.add(newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE)));  // leave subexpression
            }
            TRACE(E,"computeAstDig: alt end %s\n",ast);
            break;
        case A_CON:                       // concatenation
            TRACE(E,"computeAstDig: conc start %s\n",ast);
            ast.isNull = true;
            ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
            ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
            AstNode prev = null;
            for (AstNode a = ast.son; a != null; a = a.bro){
                TRACE(E,"computeAstDig: conc ele %s\n",a);
                ast.isNull &= a.isNull;
                ast.dig.addAll(a.dig);
                if (a != ast.son){                // not first
                    iniarr = a.ini.toArray(new BSsymbol[0]);
                    finarr = prev.fin.toArray(new BSsymbol[0]);
                    for (int i = 0; i < finarr.length; i++){
                        for (int j = 0; j < iniarr.length; j++){
                            ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                        }
                    }
                }
                prev = a;
            }
            iniarr = ast.son.ini.toArray(new BSsymbol[0]);
            for (int i = 0; i < iniarr.length; i++){
                ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]));   // enter subexpression
            }
            finarr = prev.fin.toArray(new BSsymbol[0]);
            for (int i = 0; i < finarr.length; i++){
                ast.dig.add(newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE)));    // leave subexpression
            }
            break;
        case A_GRO:                               // sub-re
            TRACE(E,"computeAstDig: group start %s body %s kind %s\n",
                ast,ast.son,groupKindStr[ast.groupKind]);
            if (ast.groupKind == G_RE1 || ast.groupKind == G_GRO ||
                ast.groupKind == G_RE2){
                ast.isNull = ast.son.isNull;
                if (ast.groupKind == G_RE2 && ast.lowerbound == 0){
                    ast.isNull = true;
                }
            } else {
                ast.isNull = true;
            }
            BSsymbol op = newBSsymbol(astToBSele(ast,ELEOPEN));
            TRACE(E,"computeAstDig: group open dig %s\n",op);
            ast.ini.add(op);
            BSsymbol cl = newBSsymbol(astToBSele(ast,ELECLOSE));
            TRACE(E,"computeAstDig: group close dig %s\n",cl);
            ast.fin.add(cl);
            if (ast.groupKind != G_RE2){
                TRACE(E,"computeAstDig: group adding son dig %s\n",
                    bsSetToString(ast.son.dig));
                ast.dig.addAll(ast.son.dig);
                iniarr = ast.son.ini.toArray(new BSsymbol[0]);
                for (int i = 0; i < iniarr.length; i++){
                    BSsymbol ent = newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]);
                    TRACE(E,"computeAstDig: group enter dig %s\n",ent);
                    ast.dig.add(ent);   // enter subexpression
                }
                finarr = ast.son.fin.toArray(new BSsymbol[0]);
                for (int i = 0; i < finarr.length; i++){
                    BSsymbol exi = newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE));
                    TRACE(E,"computeAstDig: group exit dig %s\n",exi);
                    ast.dig.add(exi);  // leave subexpression
                }
            }
            if (ast.groupKind == G_RE0 || ast.groupKind == G_RE1){
                iniarr = ast.son.ini.toArray(new BSsymbol[0]);
                finarr = ast.son.fin.toArray(new BSsymbol[0]);
                for (int i = 0; i < finarr.length; i++){
                    for (int j = 0; j < iniarr.length; j++){
                        BSsymbol step = newBSsymbol(finarr[i],iniarr[j]);
                        TRACE(E,"computeAstDig: group step dig %s\n",step);
                        ast.dig.add(step);
                    }
                }
            }
            if (ast.groupKind == G_RE0 || ast.groupKind == G_OPT){
                BSsymbol bypass = newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE));
                ast.dig.add(bypass); // ( e )
                TRACE(E,"computeAstDig: group bypass %s\n",bypass);
            }

            if (ast.groupKind == G_RE2){
                // deep clone the ast tree of the son as many times as needed
                // and also compute the ini, fin, dig sets for them
                // this is because BSsymbols contain ast seq, which here
                // must be different, but they are also used to number symbols,
                // and here they must keep the original ones (stored in pos)
                // We have a fixed part of lowerbound bodies and an optional part
                // of hipart bodies (if hipart > 0).
                // The optional ones have a bypass.
                // If hipart < 0, the last body can be repeated.
                //     {n}   lo = n, hi = n
                //     {n,m} lo = n, hi = m
                //     {n,}  lo = n, hi = -1
                //     {,n}  lo = 0, hi = n
                int hipart = ast.upperbound - ast.lowerbound;
                int nbodies = ast.upperbound;
                if (ast.upperbound < 0){
                    nbodies = ast.lowerbound;
                }
                TRACE(E,"computeAstDig: re2 bodies %s\n",nbodies);
                AstNode[] arr = new AstNode[nbodies];
                for (int j = 0; j < arr.length; j++){
                    arr[j] = ast.son.treeClone();
                    TRACE(E,"computeAstDig: re2 cloned %s\n",arr[j]);
                    computeAstDig(arr[j]);
                    TRACE(E,"computeAstDig: re2 computed %s\n",arr[j]);
                    TRACE(E,"computeAstDig: re2 adding son dig %s\n",
                        bsSetToString(arr[j].dig));
                    ast.dig.addAll(arr[j].dig);
                }
                // then produce the digrams
                for (int j = 0; j < arr.length; j++){
                    if (j == 0){                         // first
                        iniarr = arr[j].ini.toArray(new BSsymbol[0]);
                        for (int i = 0; i < iniarr.length; i++){
                            BSsymbol ent = newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]);
                            TRACE(E,"computeAstDig: re2 enter dig %s\n",ent);
                            ast.dig.add(ent);   // (group first body
                        }
                    }
                    if (j < arr.length-1){    // intermediate
                        iniarr = arr[j+1].ini.toArray(new BSsymbol[0]);
                        finarr = arr[j].fin.toArray(new BSsymbol[0]);
                        for (int i = 0; i < finarr.length; i++){
                            for (int k = 0; k < iniarr.length; k++){
                                BSsymbol step = newBSsymbol(finarr[i],iniarr[k]);
                                TRACE(E,"computeAstDig: re2 step dig %s\n",step);
                                ast.dig.add(step);
                            }
                        }
                    } else {                             // last
                        finarr = arr[j].fin.toArray(new BSsymbol[0]);
                        for (int i = 0; i < finarr.length; i++){
                            BSsymbol exi = newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE));
                            TRACE(E,"computeAstDig: re2 exit dig %s\n",exi);
                            ast.dig.add(exi);    // last body )group
                        }
                    }
                }
                if (hipart > 0){
                    // produce the bypasses
                    TRACE(E,"computeAstDig: re2 optional part\n");
                    for (int j = ast.lowerbound; j < arr.length; j++){
                        if (j == 0) continue;
                        finarr = arr[j-1].fin.toArray(new BSsymbol[0]);
                        for (int i = 0; i < finarr.length; i++){
                            BSsymbol exi = newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE));
                            TRACE(E,"computeAstDig: re2 bypass dig %s\n",exi);
                            ast.dig.add(exi);
                        }
                    }
                }
                if (ast.upperbound < 0){      // (n,)
                    iniarr = arr[arr.length-1].ini.toArray(new BSsymbol[0]);
                    finarr = arr[arr.length-1].fin.toArray(new BSsymbol[0]);
                    for (int i = 0; i < finarr.length; i++){
                        for (int j = 0; j < iniarr.length; j++){
                            BSsymbol step = newBSsymbol(finarr[i],iniarr[j]);
                            TRACE(E,"computeAstDig: * dig %s\n",step);
                            ast.dig.add(step);
                        }
                    }
                }
            }
            break;
        }
        if (ast.seq == 0){           // top node
            AstNode e = this.botAst;
            e.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN),e.seq));
            e.fin.add(newBSsymbol(e.seq,astToBSele(e,ELECLOSE)));
            e.dig.addAll(e.ini);
            e.dig.addAll(e.fin);
            BSsymbol[] iniarr = ast.ini.toArray(new BSsymbol[0]);
            for (int i = 0; i < iniarr.length; i++){
                BSsymbol topent = newBSsymbol(e.seq,iniarr[i]);
                TRACE(E,"computeAstDig: top enter dig %s\n",topent);
                ast.dig.add(topent);
            }
            e = this.eofAst;
            e.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN),e.seq));
            e.fin.add(newBSsymbol(e.seq,astToBSele(e,ELECLOSE)));
            e.dig.addAll(e.ini);
            e.dig.addAll(e.fin);
            BSsymbol[] finarr = ast.fin.toArray(new BSsymbol[0]);
            for (int i = 0; i < finarr.length; i++){
                BSsymbol topexi = newBSsymbol(finarr[i],e.seq);
                TRACE(E,"computeAstDig: top exit dig %s\n",topexi);
                ast.dig.add(topexi);
            }
        }
        TRACE(E,"computeAstDig done: %s\n",ast);
    }

    /**
     * Compute the n-grams for the tree rooted in the specified AST.
     *
     * @param      ast reference to the AST node
     */

    /* N-grams
     *
     *      a || ^( .... !a   +  !a ...  
     *
     * I keep an array with the ngrams that start with a terminal or (0 and an array of arrays
     * of the ones that start with a symbol (that is not a terminal), subdivided by symbol.
     * Then I visit the first and build the next copy of it enlarging each ngram producing new
     * ones visiting the second. I terminate when no new ngrams are created.
     * The copies are actually kept in a unique one: each time only the portion of it that
     * has been built at the previous step is visited.
     * It is also easy to check duplicates because only the newly built part need be checked.
     *
     * The array of arrays is index by ast seq only because using directly the symbols in
     * bsstrings would make the index huge (bssymbols contain also the enter and leave flags).
     * When visiting the indexed array the entries that correspond to the desired one are
     * selected.
     *
     * Note that this produces ngrams that are englarged at each cycle if they end in
     * a symbol that is not a terminal. At the end we have all ngrams that start and end
     * with a terminal or that start with (0 besides many others).
     */

    private void computeNgrams(AstNode ast){
        TRACE(N,"computeNgrams %s\n",ast);
        BSsymbol[] arr = ast.dig.toArray(new BSsymbol[0]);
        Arrays.sort(arr,new Comparator<BSsymbol>(){
            public int compare(BSsymbol s1, BSsymbol s2){
                return s1.compareTo(s2);
            }});
        TRACE(N,"computeNgrams -0- %s\n",Arrays.toString(arr));
        BSsymbol[] list = new BSsymbol[10];
        BSsymbol[][] nexts = new BSsymbol[this.astMap.length][];
        int[] nextsi = new int[this.astMap.length];
        int last = 0;
        // build initial list and directory
        for (int i = 0; i < arr.length; i++){
            BSsymbol ele = arr[i];
            int start = ele.eleAt(0);
            int ending = ele.eleAt(-1);
            int kind = BSeleKind(start);
            if (isBSeleTerminal(start) ||            // starts with terminal or (0
                BSeleToAst(start).seq == 0){
                if (!isBSeleTerminal(ending)){       // does not terminate with terminal
                    if (last >= list.length){
                        list = Arrays.copyOf(list,list.length*2);
                    }
                    list[last++] = ele;
                }
            }
            if (!isBSeleTerminal(start)){            // add to directory
                int seq = start & ELEMASK;
                if (nexts[seq] == null){
                    nexts[seq] = new BSsymbol[10];
                } else if (nextsi[seq] >= nexts[seq].length){
                    nexts[seq] = Arrays.copyOf(nexts[seq],nexts[seq].length+10);
                }
                nexts[seq][nextsi[seq]++] = ele;
            }
        }
        TRACE(N,"computeNgrams initial list %s\n%s\n",
            last,Arrays.toString(Arrays.copyOf(list,last)));
        #ifdef DEBUG
        if ((FL_N & this.trc) != 0){
            Trc.out.printf("computeNgrams nexts\n");
            for (int i = 0; i < nexts.length; i++){
                BSsymbol[] nex = nexts[i];
                if (nex == null) continue;
                Trc.out.printf("%s:",i);
                for (int j = 0; j < nex.length; j++){
                    if (nex[j] == null) continue;
                    Trc.out.printf(" %s",nex[j]);
                }
                Trc.out.printf("\n");
            }
        }
        #endif

        // then process the list creating a new one, and repeating
        // until no more can be created

        int curlist = 0;
        int end = last;
        for (;;){
            for (int i = curlist; i < end; i++){
                BSsymbol ele = list[i];                             // current element
                int ending = ele.eleAt(-1);                         // last symbol in it
                int seq = ending & ELEMASK;
                BSsymbol[] next = nexts[seq];
                if (next == null) continue;
                for (int j = 0; j < nextsi[seq]; j++){
                    add: if (next[j].arr[0] == ending){             // same symbol and same open/close
                        BSsymbol conc = newBSsymbolConc(ele,next[j]);
                        if (!isAllowedSeq(conc)) break add;         // avoid endless strings ()()...
                        for (int k = end+1; k < last; k++){
                            if (list[k].equals(conc)) break add;    // no duplicates
                        }
                        if (last >= list.length){
                            list = Arrays.copyOf(list,list.length*2);
                        }
                        list[last++] = conc;
                    }
                }
            }
            if (last == end) break;         // empty next list
            curlist = end;
            end = last;
            TRACE(N,"computeNgrams new list %s %s\n%s\n",
                curlist,end,Arrays.toString(Arrays.copyOfRange(list,curlist,end)));
        }

        // add then the ones that start with a terminal or (0 and end with a terminal
        for (int i = 0; i < arr.length; i++){
            BSsymbol ele = arr[i];
            int start = ele.eleAt(0);
            int ending = ele.eleAt(-1);
            int kind = BSeleKind(start);
            if (isBSeleTerminal(start) || BSeleToAst(start).seq == 0){  // starts with terminal or (^
                if (isBSeleTerminal(ending)){       // terminates with terminal
                    if (last >= list.length){
                        list = Arrays.copyOf(list,list.length*2);
                    }
                    list[last++] = ele;
                }
            }
        }
        #ifdef DEBUG
        if ((FL_N & this.trc) != 0){
            Trc.out.printf("computeNgrams resulting list\n");
            for (int i = 0; i < last; i++){
                Trc.out.printf("    %s\n",list[i]);
            }
        }
        #endif

        // build the triples
        // they are the ngrams that start with a terminal and end with a terminal or eof
        // and the ones that start with bot

        this.tagsTable = new BSsymbol[10];
        this.tagsTableNr = 0;
        this.triplesTable = new BSATripleData[10];
        this.triplesNr = 1;
        for (int i = 0; i < last; i++){
            BSsymbol ele = list[i];
            int start = ele.eleAt(0);
            int ending = ele.eleAt(-1);
            if ((BSeleToAst(start) == this.botAst ||
                isBSeleTerminal(start)) &&
                (BSeleToAst(ending) == this.eofAst ||
                isBSeleTerminal(ending))){
                BSsymbol tag = ele.substring(1,-1);
                addTriple(start,tag,ending);
            }
        }
        #ifdef DEBUG
        if ((FL_N & this.trc) != 0){
            Trc.out.printf("computeNgrams triples table\n");
            for (int j = 1; j < this.triplesNr; j++){
                Trc.out.printf("    %s: %s\n",j,this.triplesTable[j].toString());
            }
        }
        #endif
    }

    /**
     * Trace the triple table, and the tag table (the one containing the strings
     * of parentheses of the triples).
     */

    void traceTriples(){
        Trc.out.printf("triples table\n");
        for (int i = 0; i < this.triplesNr; i++){
            if (this.triplesTable[i] == null) continue;
            Trc.out.printf("    %s: %s\n",i,this.triplesTable[i]);
        }
        Trc.out.printf("tags table\n");
        for (int i = 0; i < this.tagsTable.length; i++){
            if (this.tagsTable[i] == null) continue;
            Trc.out.printf("    %s: %s\n",i,this.tagsTable[i]);
        }
    }

    /**
     * Deliver a string representing the parentheses of the specified triple.
     *
     * @param      tri triple
     * @return     string
     */

    private String tripleToBrief(BSATripleData tri){
        return this.tagsTable[tri.tag].toString();
    }

    /**
     * Check that the specified sequence is allowed (i.e. that there are no repeated empty
     * elements).
     *
     * @param      s sequence
     * @return     <code>true</code> if allowed, <code>false</code> otherwise
     */

    #ifdef EXTRA_NULLABLEBODY
    boolean extra_nullablebody = true;

    // This allows for an empty body (when the body is nullable) and a nonempty
    // one in the same segment (aka BSsymbol)
    boolean isAllowedSeq(BSsymbol s){
        TRACE(G,"isAllowedSeq %s\n",s);
        #ifdef DEBUG
        if ((FL_G & this.trc) != 0){
            Trc.out.printf("ast tree\n");
            traceAst();
        }
        #endif
        boolean res = true;
        // this can be done only once by the caller
        doit: {
            TRACE(N,"scan symbol\n");
            int len = s.length();

            // check that there are no repetitions of empty
            for (int i = 0; i < len; i++){
                int ele = s.eleAt(i);
                TRACE(N,"  at %s: ele %s kind %s ast kind %s seq %s\n",i,
                    BSeleToString(ele),BSeleKind(ele),BSeleToAst(ele).kind,BSeleToAst(ele).seq);

                AstNode ast = BSeleToAst(ele);
                int seq = ast.seq;
                int k = BSeleKind(ele);
                if (k == 0) continue;             // not an open or close, i.e. not a metasymbol
                if (ast.kind == A_EMP){
                    for (int j = i+1; j < len; j++){
                        ele = s.eleAt(j);
                        if (k != BSeleKind(ele)) continue;
                        if (seq == BSeleToAst(ele).seq){
                            TRACE(N,"  dupl at %s %s\n",j,BSeleToString(ele));
                            res = false;
                            break doit;
                        }
                    }
                } else if (i < len-1 && BSeleKind(ele) == ELEOPEN &&
                    ast.kind == A_GRO && (ast.groupKind == G_RE0 || ast.groupKind == G_OPT)){
                    // here we have the groups that have a bypass, not the ones that have
                    // a nullable body
                    // this is needed unless we represent * with ((body)+|)* and [] with ((body)|)
                    TRACE(N,"  group %s ele %s\n",ast,BSeleToString(ele));
                    ele = s.eleAt(i+1);
                    if (BSeleKind(ele) != ELECLOSE) continue;

                    // check then the duplication of the same empty group
                    for (int j = i+2; j < len; j++){
                        ele = s.eleAt(j);
                        AstNode a = BSeleToAst(ele);
                        if (j < len-1 && a.seq == seq && BSeleKind(ele) == ELEOPEN &&
                            BSeleKind(s.eleAt(j+1)) == ELECLOSE){
                            TRACE(N,"  dupl at %s %s\n",j,BSeleToString(ele));
                            res = false;
                            break doit;
                        }
                    }
                }
            }
        } // doit
        TRACE(N,"isAllowedSeq %s res %s\n",s.toString(),res);
        return res;
    }

    #else
    boolean extra_nullablebody = false;

    /* This allows either for an empty body or for nonempty ones, but not both
     * in the same segment (aka BSsymbol)
     * In a same segment there can be nodes that are closed, but that are opened
     * in a previous one: they denote nonempty bodies. There can also be nodes
     * that are opened, but closed in a subsequent segmente. They too denote
     * nonempty bodies.
     * Note that in a segment -by construction- there cannot be more than two
     * (possibly partial) subtrees for the same ast node.
     * The sequence of nodes is analysed using an automaton instantiated for each
     * ast node:
     *
     *     0---(--->1---(---> err
     *     |         `--)--->3----(,),end---> err
     *     |---)--->2---)--->err
     *     `---end  `---(--->3
     *              `---end
     */

    boolean isAllowedSeq(BSsymbol s){
        TRACE(G,"isAllowedSeq %s\n",s);
        #ifdef DEBUG
        if ((FL_G & this.trc) != 0){
            Trc.out.printf("ast tree\n");
            traceAst();
        }
        #endif
        boolean res = true;
        // this can be done only once by the caller
        int[] state = new int[this.astMap.length];
        doit: {
            TRACE(N,"scan symbol\n");
            int len = s.length();

            // check that there are no repetitions of empty
            for (int i = 0; i < len; i++){
                int ele = s.eleAt(i);
                AstNode ast = BSeleToAst(ele);
                int seq = ast.seq;
                int k = BSeleKind(ele);
                if (k == 0) continue;             // not an open or close, i.e. not a metasymbol
                int nr = BSeleToAstNum(ele);
                TRACE(N,"  at %s: ele %s kind %s ast kind %s seq %s state[%s] %s\n",i,
                    BSeleToString(ele),BSeleKind(ele),BSeleToAst(ele).kind,BSeleToAst(ele).seq,
                    nr,state[nr]);
                int next = state[nr];
                switch (state[nr]){
                case 0:                 // not yet encountered
                    if (BSeleKind(ele) == ELEOPEN){
                        next = 1;
                    } else if (BSeleKind(ele) == ELECLOSE){
                        next = 2;
                    }
                    break;
                case 1:                 // first open found
                    if (BSeleKind(ele) == ELEOPEN){
                        next = 6;
                    } else if (BSeleKind(ele) == ELECLOSE){
                        next = 3;
                    }
                    break;
                case 2:                 // first close found
                    if (BSeleKind(ele) == ELEOPEN){
                        next = 4;
                    } else if (BSeleKind(ele) == ELECLOSE){
                        next = 6;
                    }
                    break;
                case 3:                 // nullable body
                case 4:                 // non-empty body
                    if (BSeleKind(ele) == ELEOPEN){
                        next = 6;
                    } else if (BSeleKind(ele) == ELECLOSE){
                        next = 6;
                    }
                    break;
                case 6:                 // error
                    res = false;
                    break doit;
                }
                TRACE(N,"    next state [%s] %s\n",nr,next);
                state[nr] = next;
                if (next == 6){
                    res = false;
                    break doit;
                }
            }
        } // doit

        TRACE(N,"isAllowedSeq %s res %s\n",s.toString(),res);
        return res;
    }

    #endif
    
    /** The data of a triple. */

    class BSATripleData {

        /** The starting marked input symbol (ast number) or item index. */
        int startsymbol;

        /** The tag (index in the tags table). */
        int tag;

        /** The ending marked input symbol (ast number) or item index. */
        int endsymbol;

        /**
         * Construct a triple with the specified data.
         *
         * @param      start starting marked symbol
         * @param      tag tag
         * @param      end ending marked symbol
         */

        BSATripleData(int start, int tag, int end){
            this.startsymbol = start;
            this.tag = tag;
            this.endsymbol = end;
        }

        /**
         * Deliver a string representing this triple.
         *
         * @return     string
         */

        public String toString(){
            return String.format("<%s,%s,%s>",
                BSeleToString(this.startsymbol),
                tagsTable[this.tag].toString(),
                BSeleToString(this.endsymbol));
        }

        public boolean equals(BSATripleData other){
            return this.startsymbol == other.startsymbol &&
                this.tag == other.tag &&
                this.endsymbol == other.endsymbol;
        }
    }
    
    /** The table of all tags. */
    BSsymbol[] tagsTable;

    /** The number of entries in the table of all tags. */
    int tagsTableNr;

    /** The table of all triples. */
    BSATripleData[] triplesTable;

    /** The number of entries in the table of triples. */
    int triplesNr;

    /** The vectors of the triples with the same unmarked starting, by char. */
    int[][] tripleStarting;

    /**
     * Add the specified triple.
     *
     * @param      startsym start marked symbol
     * @param      tag
     * @param      endsym end marked symbol
     */

    void addTriple(int startsym, BSsymbol tag, int endsym){
        TRACE(D,"addTriple %s,%s,%s\n",BSeleToString(startsym),tag,BSeleToString(endsym));
        // search the tag in the table, and add it if not found
        int tagnr = -1;
        for (int i = 0; i < this.tagsTableNr; i++){
            if (tag.equals(this.tagsTable[i])){          // found
                tagnr = i;
                break;
            }
        }
        if (tagnr < 0){             // not found, add it
            if (this.tagsTableNr == this.tagsTable.length){
                this.tagsTable = Arrays.copyOf(this.tagsTable,this.tagsTable.length+100);
            }
            tagnr = this.tagsTableNr;
            this.tagsTable[this.tagsTableNr++] = tag;
            TRACE(D,"addTriple tag added %s tagsTableNr %s\n",tag,this.tagsTableNr);
        }
        int triplenr = -1;
        for (int i = 1; i < this.triplesNr; i++){
            if (this.triplesTable[i].startsymbol == startsym &&
                this.triplesTable[i].tag == tagnr &&
                this.triplesTable[i].endsymbol == endsym){          // found
                triplenr = i;
                TRACE(D,"addTriple found in triplesTable\n");
                break;
            }
        }
        if (triplenr < 0){             // not found, add it
            if (this.triplesNr == this.triplesTable.length){
                this.triplesTable = Arrays.copyOf(this.triplesTable,this.triplesTable.length+10);
            }
            triplenr = this.triplesNr;
            this.triplesTable[this.triplesNr++] = new BSATripleData(startsym,tagnr,endsym);
        }
    }

    //---------- NFA -----------------

    /** A state table for the NFA. */

    /* This is the nfa, in which each states represents a triple (except for the initial one).
     * In it there are no states that are dead-ends, i.e. that are not pos-reachable.
     * All the reached nfa states are post-reacheble in general, but they are not for a
     * specific sequence of transitions.
     *
     * Since each state has only one triple in it, all its incoming arcs are labelled with
     * the first unmarked symbol of the triple, and likewise for the reverse ones.
     */

    class Nfa {

        /** Whether it is a GMY one. */
        boolean gmy;

        /** The head of the list of states. */
        State head;

        /** The tail of the list. */
        State last;

        /** The last state added. */
        State lastAdded;

        /** The number of states. */
        int stateNr;

        /** The table of states. */
        State[] table;
        
        /** An arc of the NFA. */

        class Arc {

            /** The reference to the next transition. */
            Arc next;

            /** The next state (endpoint of this arc). */
            State nextState;

            /** The symbol. */
            Symbol sym;

            /**
             * Deliver a string representing the label of this arc.
             *
             * @return     string
             */

            public String toLabel(){
                String str = this.sym.toString();
                return str;
            }

            /**
             * Deliver a string representing this arc.
             *
             * @return     string
             */

            public String toString(){
                return toLabel() + "->" + this.nextState.number;
            }

            /**
             * Tell if this arc is equal to the specified other one.
             *
             * @param      other the other arc
             * @return     <code>true</code> if it is, <code>false</code> otherwise
             */

            private boolean equals(Arc other){
                if (this == other) return true;
                if (other == null) return false;
                return this.nextState == other.nextState && this.sym.equals(other.sym);
            }
        }

        /** A state of the NFA. */

        class State {

            /** The reference to the next state in the list of states. */
            State suc;

            /** The state number. */
            int number;

            /** The head of the list of arcs. */
            Arc transList;

            /** Whether this state is final. */
            boolean accepting;

            /** Whether this state is initial. */
            boolean initial;

            /** The triple number in triplesTable. */
            int tnum;

            /** The symbol that labels transitions. */
            Symbol sym;

            /** The set of subclasses that labels transitions. */
            long cset;

            /** The set of reached states. */
            IntSetBit delta;

            /** The set of postreached states. */
            IntSetBit revdelta;

            /**
             * Tell if this state is equal to the specified other one.
             *
             * @param      other the other state
             * @return     <code>true</code> if it is, <code>false</code> otherwise
             */

            public boolean equals(State other){
                return this.number == other.number;
            }
            public boolean equals(Object other){
                return equals((State)other);
            }

            /**
             * Deliver a string representing this state.
             *
             * @return     string
             */
            public String toString(){
                return "" + this.number;
            }
            public String toTripleString(){
                return  "" + this.tnum + " " + triplesTable[this.tnum];
            }
        }
            
        /**
         * Add a new state.
         *
         * @param      tn triple number
         * @param      rev <code>true</code> to produce the reversed FA, <code>false</code> otherwise
         * @return     reference to the state
         */
         
        State newState(int tn, boolean rev){
            State n = new State();
            n.number = this.stateNr++;
            n.tnum = tn;
            if (!rev){
                if (n.tnum >= 0){
                    BSATripleData tri = triplesTable[tn];
                    AstNode ast = astMap[BSeleToAstNum(tri.endsymbol)];
                    n.sym = ast.sym;
                } else {
                    n.sym = botAst.sym;
                }
            } else {
                if (n.tnum >= 0){
                    BSATripleData tri = triplesTable[tn];
                    AstNode ast = astMap[BSeleToAstNum(tri.startsymbol)];
                    n.sym = ast.sym;
                } else {
                    n.sym = eofAst.sym;
                }
            }
            
            if (this.last == null) this.head = n;     // append to list
            else this.last.suc = n;
            this.last = n;
            this.lastAdded = n;
            TRACE(D,"add new state %s\n",n.number);
            return n;
        }

        /**
         * Trace the specified state.
         *
         * @param      s state
         */

        void traceState(State s){
            String status = "";
            if (s.initial) status += " initial";
            if (s.accepting) status += " final";
            Trc.out.printf("state: %s%s",
                s.number,status);
            int incoming = '0';
            int outgoing = '0';
            String tstr = "";
            if (s.tnum >= 0){
                BSATripleData tri = triplesTable[s.tnum];
                Trc.out.printf(" triple nr %s",s.tnum);
                tstr = tri.toString();
            }
            Trc.out.printf(" cset: %s",csetToString(s.cset));
            Trc.out.printf(" item: %s\n  delta %s revdelta %s\n  transitions:\n",tstr,s.delta,s.revdelta);
            for (Arc t = s.transList; t != null; t = t.next){
                Trc.out.printf("    %s\n",t);
            }
        }

        /**
         * Trace this table of states.
         */

        void trace(){
            for (int i = 0; i < this.stateNr; i++){
                State s = this.table[i];
                traceState(s);
            }
            Trc.out.printf("nr states %s\n",this.stateNr);
        }

        /**
         * Add an arc from the specifed state with the specified symbol
         * to the specified state.
         *
         * @param      from state
         * @param      to state
         * @param      sym symbol
         * @return     reference to the arc
         */
         
        Arc addArc(State from, State to, Symbol sym){
            Arc t = null;
            sea: {
                Arc pr = null;
                for (t = from.transList; t != null; t = t.next){      // find last
                    pr = t;
                }
                t = new Arc();
                t.nextState = to;
                t.sym = sym;
                if (pr == null){                // append
                    from.transList = t;
                } else {
                    pr.next = t;
                }
            }
            TRACE(D,"addArc %s-%s\n",from.number,t);
            return t;
        }

        /**
         * Create a new state table.
         */
         
        Nfa(){
        }

        void buildDelta(){
            TRACE(A,"buildDelta start\n");
            for (State s = this.head; s != null; s = s.suc){
                s.delta = new IntSetBit();
                for (Arc t = s.transList; t != null; t = t.next){
                    int nexts = t.nextState.number;   // state nr
                    s.delta.add(nexts);
                }
                TRACE(A,"  state %s delta %s\n",s.number,s.delta);
            }
            TRACE(A,"buildDelta done\n");

            for (int i = 0; i < this.stateNr; i++){
                State s = this.table[i];
                s.revdelta = new IntSetBit();
                for (int j = 0; j < this.stateNr; j++){
                    State t = this.table[j];
                    if (t.delta.contains(i)){
                        s.revdelta.add(j);
                    }
                }
            }
        }
            
        /**
         * Deliver the action corresponding to the specified state and symbol.
         *
         * @param      state number of the state
         * @param      sym symbol
         * @return     action
         */

        IntSetBit faAction(int state, int sym){
            IntSetBit res = null;
            State s = this.table[state];
            boolean match = (s.cset & (1L << subclass(sym))) != 0;
            TRACE(Q,"faAction %s sym %s state sym %s cset %s match %s\n",
                state,(char)sym,s.sym,longBsToString(s.cset),match);
            if (match){
                res = s.delta;
            }
            TRACE(Q,"faAction res %s\n",res);
            return res;
        }

        /**
         * Build the nfa.
         */

        void buildTriplesNfa(){
            // visit all triples and make a NFA

            // create the initial node
            State ini = newState(-1,false);
            ini.initial = true;

            for (int i = 0; i < triplesTable.length; i++){
                BSATripleData tri = triplesTable[i];
                if (tri == null) continue;
                // AstNode ast = astMap[BSeleToAstNum(tri.endsymbol)];
                State n = newState(i,false);
                TRACE(N,"crea node %s\n",n);
            }
            for (State n = this.head; n != null; n = n.suc){
                TRACE(N,"process node %s\n",n);
                if (n.tnum < 0) continue;
                // find the state whose triple ends in the initial symbol if tri
                BSATripleData tri = triplesTable[n.tnum];
                int start = tri.startsymbol;
                int end = tri.endsymbol;
                AstNode ast = astMap[BSeleToAstNum(end)];
                TRACE(N,"  start %s end %s\n",BSeleToString(start),
                    BSeleToString(tri.endsymbol));
                for (State m = this.head; m != null; m = m.suc){
                    if (m.tnum < 0) continue;
                    BSATripleData t = triplesTable[m.tnum];
                    if (t.startsymbol == end){  // found
                        Arc e = addArc(n,m,ast.sym);
                        TRACE(N,"edge %s-%s->%s\n",n.number,ast.sym,m.number);
                    }
                }
                if (ast == eofAst){
                    n.accepting = true;
                }
                ast = astMap[BSeleToAstNum(start)];
                if (ast == botAst){
                    addArc(ini,n,ast.sym);
                }
            }

            this.table = new State[this.stateNr];
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = (State)s;
            }
            buildDelta();
        }

        /**
         * Deliver a string representing the graph with the states reacheable from the
         * start state.
         *
         * @return     string
         */

        public String toString(){
            StringBuilder sb = new StringBuilder();
            int dp = 0;
            int qp = 0;
            State[] queue = new State[this.stateNr];
            queue[qp++] = this.head;                    // start from it
            while (dp != qp){                           // while queue not empty
                State s = queue[dp++];
                if (sb.length() > 0) sb.append("; ");
                sb.append(s.number);
                if (s.accepting) sb.append("f");
                sb.append(":");
                loop: for (Arc t = s.transList; t != null; t = t.next){
                    if (t != s.transList) sb.append(",");
                    sb.append(t);
                    for (int j = 0; j < qp; j++){
                        if (queue[j] == t.nextState) continue loop;  // already visited
                    }
                    queue[qp++] = t.nextState;          // enqueue it
                }
            }
            return sb.toString();
        }

        /**
         * Deliver a string representing the fa as a graph in the ShowGraph format.
         *
         * @return     string
         */

        String toGraph(){
            Graph g = new Graph(Graph.DIRECTED);
            g.name = "fa";
            // create all nodes
            Node[] nodes = new Node[this.stateNr];
            for (int i = 0; i < this.stateNr; i++){
                nodes[i] = g.newNode("" + i);
            }
            // create then the edges
            for (int i = 0; i < this.stateNr; i++){
                State s = this.table[i];
                if (s.transList != null){
                    for (Arc t = s.transList; t != null; t = t.next){
                        g.newEdge(nodes[s.number],nodes[t.nextState.number],"\"" +
                            t.sym.toString() + "\"",true);
                    }
                }
            }
            return g.toString();
        }
    }

    /* This is the GMY nfa, in which each states represents a symbol.
     */

    class GMYNfa extends Nfa {

        GMYNfa(){
            this.gmy = true;
        }

        class GMYState extends State {

            /** The ast that characterizes the state, and represents a numbered symbol. */
            AstNode ast;

            /**
             * Tell if this state is equal to the specified other one.
             *
             * @param      other the other state
             * @return     <code>true</code> if it is, <code>false</code> otherwise
             */

            public boolean equals(State other){
                return this.ast == ((GMYState)other).ast;
            }
        }

        /**
         * Add a new state.
         *
         * @param      ast ast
         * @return     reference to the state
         */
         
        GMYState newState(AstNode ast){
            GMYState n = new GMYState();
            n.number = this.stateNr++;
            n.ast = ast;
            n.sym = ast.sym;    // to make the building of char subclasses
            
            if (this.last == null) this.head = n;     // append to list
            else this.last.suc = n;
            this.last = n;
            this.lastAdded = n;
            TRACE(D,"add new state %s\n",n.number);
            return n;
        }

        /**
         * Trace the specified state.
         *
         * @param      s state
         */

        void traceState(State s){
            String status = "";
            if (s.initial) status += " initial";
            if (s.accepting) status += " final";
            Trc.out.printf("state: %s%s",
                s.number,status);
            Trc.out.printf(" item: %s\n transitions:\n",((GMYState)s).ast);
            for (Arc t = s.transList; t != null; t = t.next){
                Trc.out.printf("    %s\n",t);
            }
        }

        /**
         * Build the nfa.
         */

        /* The states are: an initial one, one for each numbered terminal.
         * There is no state for the eof: all states that would have an arc
         * to it are final.
         */

        void build(){
            TRACE(E,"build GMY\n");
            // create the states
            // collect the asts that are needed (there are some, generated by
            // bounded groups that are replaced by cloned ones)
            BSsymbol[] iniarr = astRoot.ini.toArray(new BSsymbol[0]);
            BSsymbol[] finarr = astRoot.fin.toArray(new BSsymbol[0]);
            BSsymbol[] digarr = astRoot.dig.toArray(new BSsymbol[0]);
            Set<Integer> all = new HashSet<Integer>();
            for (int i = 0; i < iniarr.length; i++){
                all.add(iniarr[i].arr[0]);
            }
            for (int i = 0; i < finarr.length; i++){
                all.add(finarr[i].arr[0]);
            }
            for (int i = 0; i < digarr.length; i++){
                all.add(digarr[i].arr[0]);
                all.add(digarr[i].arr[1]);
            }
            Integer[] allarr = all.toArray(new Integer[0]);
            TRACE(E,"build GMY %s\n",Arrays.toString(allarr));

            GMYState[] stateByAst = new GMYState[astMap.length];
            GMYState q0 = newState(botAst);
            stateByAst[botAst.seq] = q0;
            if (astRoot.isNull){
                q0.accepting = true;
            }
            TRACE(E,"build GMY q0 %s ast %s\n",q0,botAst);
            for (int a = 0; a < allarr.length; a++){
                int i = allarr[a];
                if (astMap[i] == null) continue;
                if (astMap[i] == botAst || astMap[i] == eofAst) continue;
                if (astMap[i].kind == A_LEA){
                    stateByAst[i] = newState(astMap[i]);
                    TRACE(E,"build GMY state %s ast %s %s\n",stateByAst[i],i,astMap[i]);
                }
            }
            // create the transitions, their labels are unnumbered symbols
            for (BSsymbol b : astRoot.ini){
                TRACE(E,"build GMY ini %s\n",b);
                if (astMap[b.arr[0]] == eofAst){
                    q0.accepting = true;
                    TRACE(E,"build GMY final %s\n",q0);
                    continue;
                }
                Arc a = addArc(q0,stateByAst[b.arr[0]],astMap[b.arr[0]].sym);
                TRACE(E,"build GMY ini arc %s sym %s\n",a,b);
            }
            for (BSsymbol b : astRoot.dig){
                TRACE(E,"build GMY %s\n",b);
                GMYState fromstate = stateByAst[b.arr[0]];
                GMYState tostate = stateByAst[b.arr[1]];
                if (astMap[b.arr[1]] == eofAst){
                    fromstate.accepting = true;
                    TRACE(E,"build GMY final %s\n",fromstate);
                    continue;
                }
                Arc a = addArc(fromstate,tostate,astMap[b.arr[1]].sym);
                TRACE(E,"build GMY arc %s->%s sym %s\n",stateByAst[b.arr[0]],a,b);
            }
            this.table = new State[this.stateNr];
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = (State)s;
            }
            TRACE(E,"build GMY %s\n",toGraph());
        }

        IntSetBit faAction(int state, int sym){
            // delta cannot be used because now we have outgoing arcs with different labels
            IntSetBit res = null;
            State s = this.table[state];
            for (Arc t = this.table[state].transList; t != null; t = t.next){
                if ((t.sym.cset & (1L << subclass(sym))) != 0){
                    if (res == null) res = new IntSetBit();
                    res.add(t.nextState.number);
                }
            }
            TRACE(Q,"faAction %s sym %s reached %s\n",
                state,(char)sym,res);
            return res;
        }
    }

    /**
     * Do a transition from the specified state and symbol, i.e. determine the
     * set of the nfa states reched from the state with arcs labelled with the symbol.
     *
     * @param      n state
     * @param      sym symbol
     * @return     set of reached states
     */

    IntSetBit transit(int n, int sym){
        IntSetBit act = this.nfa.faAction(n,sym);
        TRACE(Q,"transit state %s sym %s to %s\n",n,(char)sym,act);
        return act;
    }

    /**
     * Do a transition from the specified set of states and symbol, i.e. determine the
     * set of the nfa states reached from the specified set of states with arcs labelled
     * with the symbol.
     *
     * @param      from set of states
     * @param      sym symbol
     * @param      res returned reached states
     * @return     number of unions done
     */

    int transit(IntSetBit from, int sym, IntSetBit res){
        TRACE(Q,"transit states %s sym %s\n",from,(char)sym);
        int nr = 0;
        res.clear();
        for (int i = 0; i < from.arr.length<<6; i++){
            if ((from.arr[i >>> 6] & (1L << (i & 0x3f))) == 0) continue;
            // take the states reached from nstate with sym
            IntSetBit rea = this.nfa.faAction(i,sym);
            if (rea == null) continue;
            res.add(rea);
            #ifdef MEASURE
            nr += rea.card();
            #endif
        }
        TRACE(Q,"transit reached states %s\n",res);
        return nr;
    }

    /**
     * Do a transition from the specified reverse dfa state and symbol, i.e. determine the
     * set of the nfa states reched from the state with arcs labelled with the symbol.
     *
     * @param      n state
     * @param      sym symbol
     * @return     set of reached states
     */

    IntSetBit revtransit(int n, int sym){
        IntSetBit act = this.nfa.table[n].revdelta;
        TRACE(Q,"transit state %s sym %s to %s\n",n,(char)sym,act);
        return act;
    }

    /**
     * Do a transition from the specified set of states on the reverse nfa, i.e. determine
     * the set of the nfa states reached from the specified set of states.
     * N.B. all the specified set of states are reached with arcs with the same symbol.
     *
     * @param      from set of states
     * @param      res returned reached states
     */

    void revtransit(IntSetBit from, IntSetBit res){
        TRACE(Q,"revtransit states %s\n",from);
        res.clear();
        for (int i = 0; i < from.arr.length<<6; i++){
            if ((from.arr[i >>> 6] & (1L << (i & 0x3f))) == 0) continue;
            // take the states reached from nstate (with ch)
            IntSetBit rea = this.nfa.table[i].revdelta;
            if (rea == null) continue;
            res.add(rea);
        }
        TRACE(Q,"revtransit reached states %s\n",res);
    }

    //---------- DFA -----------------

    /** The DFA. */

    /* This class serves to determinize the nfa producing a dfa and also a reverse dfa.
     * The dfa start states contain the nfa states reached with BOT, the revdfa start
     * state contains the nfa final states and has a final state reached by BOT containing
     * nfa state 0.
     */

    class Dfa extends HashBag {

        /** The head of the ordered list. */
        State head;

        /** The last of the list. */
        State last;

        /** The last element added. */
        State lastAdded;

        /** The resulting array of states. */
        State[] table;

        /** The number of states. */
        int stateNr = 0;
    
        /** The number of states without the additional ones. */
        int strictStateNr = 0;
    
        /** The trace flags. */
        int trc;

        /**
         * A transition (edge) from a state to another.
         */

        class Arc {

            /** The reference to the next one. */
            Arc next;

            /** The next state. */
            State nextState;

            /** The symbol (character subclass) on the edge. */
            int sclass;

            /**
             * Deliver a new transition with the specified subclass and next state.
             *
             * @param   s subclass
             * @param   next next state
             * @return  transition
             */

            Arc(int s, State next){
                this.sclass = s;
                this.nextState = next;
            }

            /**
             * Deliver a string representing this object.
             *
             * @return  string
             */

            public String toString(){
                return String.format("-%s->%s",
                    subclassToString(this.sclass),this.nextState.number);
            }
        }

        /**
         * A state.
         */

        class State extends HashNode {

            /** The reference to the next element. */
            State suc;

            /** The number of the state. */
            int number;

            /** The list of edges. */
            Arc transList;

            /** Whether this state is final. */
            boolean accepting;

            /** The reference to set of NFA states represented by a DFA one. */
            IntSetBit nfaStates;
        
            /**
             * Deliver a new state with the specified number.
             *
             * @param   number
             * @return  state
             */

            State(int n){
                this.number = n;
            }

            /**
             * Deliver a new state.
             *
             * @return  state
             */

            State(){
            }

            /**
             * Deliver a string representing this object.
             *
             * @return  string
             */

            public String toString(){
                return "" + this.number;
            }

            /**
             * Tell if this object is equal to the specified one.
             *
             * @param   other object
             * @return  <code>true</code> if equal, <code>false</code> otherwise
             */

            public boolean equals(Object other){
                if (this == other) return true;
                if (other == null) return false;
                return this.nfaStates.equals(((State)other).nfaStates);
            }

            /**
             * Deliver the hash value of this object.
             *
             * @return  hash value
             */

            public int hashCode(){
                return this.nfaStates.hashCode();
            }

            /**
             * Add a transition, if not already present, keeping the transitions ordered.
             *
             * @param   tr transition
             * @return  reference to the added transition
             */

            Arc addArc(Arc tr){
                TRACE(F,"addArc adding %s\n",tr);
                Arc res = null;
                boolean found = false;
                Arc prev = null;
                // add it in sorted order
                for (Arc t = this.transList; t != null; t = t.next){
                    if (t.sclass == tr.sclass && t.nextState == tr.nextState){   // do not add duplicates
                        TRACE(F,"addArc already present\n");
                        res = t;
                        found = true;
                        break;
                    }
                    prev = t;
                }
                if (!found){
                    if (prev == null){
                        tr.next = this.transList;
                        this.transList = tr;
                    } else {
                        tr.next = prev.next;
                        prev.next = tr;
                    }
                    res = tr;
                    TRACE(F,"addArc added\n");
                }
                return res;
            }

            /**
             * Deliver a string representing the name of this state.
             *
             * @return  string
             */

            String name(){
                return Integer.toString(this.number);
            }

            /**
             * Trace this state.
             */

            void trace(){
                String status = "";
                if (this.accepting) status += " final";
                Trc.out.printf("state: %s%s",this.number,status);
                Trc.out.printf(" %s\n",this.nfaStates);
                if (this.transList != null){
                    Trc.out.printf("  transitions\n");
                    for (Arc t = this.transList; t != null; t = t.next){    // trace its transitions
                        Trc.out.printf("    %s\n",t.toString());
                    }
                }
            }
        }

        /**
         * Trace this FA.
         */

        public void trace(){
            for (State s = this.head; s != null; s = s.suc){
                s.trace();
            }
            if (this.startStates != null){
                Trc.out.printf("startStates\n");
                for (int i = 0; i < this.startStates.length; i++){
                    Trc.out.printf("nfa state %s dfa %s\n",i,this.startStates[i]);
                }
            }
            if (this.start0 != null){
                Trc.out.printf("start0 nfa states %s\n",Arrays.toString(this.start0));
                Trc.out.printf("start1 nfa states %s\n",Arrays.toString(this.start1));
            }
            Trc.out.printf("nr states %s strict %s\n",this.stateNr,this.strictStateNr);
        }

        /**
         * Search a state that is equal to the specified one.
         *
         * @param   other the other state
         * @return  reference to the state, <code>null</code> if not found
         */

        State search(State other){
            if (this.elemNr == 0) return null;
            int hvalue = (other.hashCode() & 0x7FFFFFFF)
                % this.hdir.length;
            HashNode pr = null;
            HashNode e = null;
            State d = null;
            sea: for (e = this.hdir[hvalue];
                e != null; e = e.hlink){              // scan the chain
                d = (State)e;
                if (d.equals(other)) break sea;
                pr = e;
            }
            if (e == null) d = null;
            return d;
        }

        /**
         * Ensure that this FA contains an element that is equal to the specified one.
         * If it is not yet present, add it.
         * It appends the new element at the end of the ordered list.
         *
         * @param   state reference to the state to add
         * @return  <code>true</code> if the element has been inserted
         */

        boolean addUnique(State state){
            State h = search(state);
            this.lastAdded = (State)h;
            if (h != null){                         // found
                TRACE(E,"addUnique found state %s\n",h.number);
                return false;
            }
            h = state;
            h.number = this.stateNr++;
            add(h);
            this.lastAdded = h;
            if (this.last == null) this.head = h;   // append to list
            else this.last.suc = h;
            this.last = h;
            TRACE(E,"addUnique added %s\n",h);
            return true;
        }

        /**
         * Build the pilot.
         *
         * @param      starts state from which the building must begin
         */

        void buildPilot(State starts){
            TRACE(EA,"buildPilot\n");

            // visit the initial state and the ones generated after it
            // to create all other states
            if (nfa.gmy){
                synth_attr(starts);
            }
            IntSetBit rea = new IntSetBit();
            for (State cur = starts; cur != null; cur = (State)cur.suc){
                TRACE(E,"processing state: %s %s\n",cur.number,cur.nfaStates);
                // collect the symbols that make transitions of this state
                long shifts = 0;
                // scan all its NFA states
                int[] ns = cur.nfaStates.toArray();
                for (int i = 0; i < ns.length; i++){
                    if (nfa.gmy){
                        // arcs have a set of char subclasses
                        for (Nfa.Arc t = nfa.table[ns[i]].transList; t != null; t = t.next){
                            shifts |= t.sym.cset;
                        }
                    } else {
                        shifts |= nfa.table[ns[i]].cset;
                    }
                }
                TRACE(E,"  shifts: %s %s\n",csetToString(shifts),longBsToString(shifts));
                for (int n = 0; n < 64; n++){                    // for all the shifts
                    if ((shifts & 1L << n) == 0) continue;
                    // n is the number of the char subclass
                    // determine the nfa states reached
                    rea.clear();
                    for (int j = 0; j < ns.length; j++){
                        int i = ns[j];
                        // take the states reached from nstate with class n
                        Nfa.State s = nfa.table[i];
                        if (nfa.gmy){
                            for (Nfa.Arc t = s.transList; t != null; t = t.next){
                                boolean match = (t.sym.cset & (1L << n)) != 0;
                                if (match){
                                    rea.add(t.nextState.number);
                                }
                            }
                        } else {
                            boolean match = (s.cset & (1L << n)) != 0;
                            // TRACE(E,"    nfa state %s shift %s match %s delta %s\n",
                            //    s.number,n,match,s.delta);
                            if (match){
                                rea.add(s.delta);
                            }
                        }
                    }
                    TRACE(E,"    reached %s with shift: %s\n",rea,n);
                    // if there are no states, the current is final
                    if (rea.isEmpty()){
                        cur.accepting = true;
                        continue;
                    }
                    // there is at least one state reached with n
                    State nextstate = new State();
                    nextstate.nfaStates = (IntSetBit)rea.clone();
                    if (nfa.gmy){
                        synth_attr(nextstate);
                    }
                    addUnique(nextstate);
                    nextstate = (State)this.lastAdded;
                    TRACE(E,"   adding trans to %s subclass %s\n",nextstate.number,n);
                    cur.addArc(new Arc(n,nextstate));
                    #ifdef DEBUG
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    next state:\n");
                        nextstate.trace();
                    }
                    #endif
                }
            }
            if (dfaKind == DFA || dfaKind == DFA_TR ||            // recognizion with dfa
                dfaKind == DFA_F || dfaKind == DFA_B || dfaKind == DFA_FB){
                TRACE(EA,"minimize\n");
                minimizeDfa(true);
            }
            this.table = new State[this.stateNr];
            // build table of states
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = s;
            }

            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                trace();
            }
            #endif
            TRACE(EA,"buildPilot done\n");
        }

        /**
         * Synthetises the attributes of a DFA state from those of the
         * represented NFA states.
         *
         * @param      s reference to the state
         */

        void synth_attr(State s){
            for (int i = 0; i < s.nfaStates.arr.length<<6; i++){
                if ((s.nfaStates.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    Nfa.State h = nfa.table[i];
                    if (h.accepting){
                        s.accepting = true;
                    }
                }
            }
        }

        /**
         * Build the pilots starting from all the NFA states.
         *
         * @param      dir <code>true</code> to build the direct dfa, <code>false</code> to
         *             build the reverse one
         */

        void buildPilotAll(boolean dir){
            TRACE(EA,"buildPilotAll\n");
            this.startStates = new int[nfa.table.length];
            if (!nfa.gmy){                          // 0 for fake initial nfa state
                this.startStates[0] = -1;           // no dfa states for BOT
            }
            for (int i = 0; i < nfa.table.length; i++){
                if (!nfa.gmy && i == 0) continue;   // 0 for fake initial nfa state
                State state = new State();
                IntSetBit rea = new IntSetBit(i);
                state.nfaStates = rea;
                boolean b = addUnique(state);       // add a state with these items
                this.startStates[i] = this.lastAdded.number;
                #ifdef DEBUG
                if ((FL_E & trc) != 0){
                    Trc.out.printf("first state:\n");
                    state.trace();
                }
                #endif
                if (b){                          // state added
                    if (dir){
                        buildPilot(state);       // build the pilot
                    } else {
                        buildPilotRev(state);    // build the pilot
                    }
                }
            }
            TRACE(EA,"buildPilotAll done\n");
        }

        /** The table of the start states of the dfa for each nfa state in index. */
        int[] startStates;

        /**
         * Build the dfa.
         *
         * @param      all <code>true</code> to build all the start states and the ones
         *             deriving from them, <code>false</code> otherwise
         * @return     reference to the dfa
         */

        void build(boolean all){
            TRACE(EA,"build dfa\n");
            // build the first state
            State state = new State();
            IntSetBit rea = null;
            if (nfa.gmy){
                rea = new IntSetBit(0);
            } else {
                rea = transit(0,ReParallel.BOT);
            }
            state.nfaStates = rea;
            addUnique(state);                          // add a state with these items
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("first state:\n");
                state.trace();
            }
            #endif

            buildPilot(state);                 // build the pilot
            this.strictStateNr = this.stateNr;

            if (all){
                buildPilotAll(true);           // build the dfas from all states and merge them
            }
            if (dfaKind == MIN_ME_DFA ||       // recognizion with me-dfa
                dfaKind == MIN_ME_DFA_B){
                TRACE(EA,"minimizeMeDfa\n");
                minimizeMeDfa();
            } else if (dfaKind == NME_DFA ||
                dfaKind == NME_DFA_B){
                TRACE(H,"building start0 and start1\n");
                this.start0 = this.table[0].nfaStates.toArray();
                this.start1 = new int[nfa.stateNr];
                for (int i = 0; i < this.start1.length; i++){  // all nfa states initial
                    this.start1[i] = i;
                }
            }
            compactTables();                   // produce the compact tables
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("end build fa\n");
                trace();
            }
            #endif
            TRACE(EA,"build dfa done\n");
        }

        /**
         * Build the compressed tables of this dfa.
         */

        void compactTables(){
            TRACE(E,"compactTables\n");
            int nsym = symClassTable.length + 1;
            int[][] tabs = new int[this.stateNr][];    // tables before compression
            // build the tables taking into account that the transitions are
            // already ordered by increasing symbol (by construction)
            for (int i = 0; i < this.stateNr; i++){
                // compute the number of arcs
                State s = this.table[i];
                int nval = 0;
                for (Arc t = s.transList; t != null; t = t.next){
                    nval++;
                }
                tabs[i] = new int[nval*2 + 1];
                int k = 0;
                tabs[i][k++] = nsym;  // length
                // compute the pairs (subclass,next-state)
                for (Arc t = s.transList; t != null; t = t.next){
                    tabs[i][k++] = t.sclass;
                    tabs[i][k++] = t.nextState.number;
                }
                #ifdef DEBUG
                if ((FL_D & trc) != 0){
                    Trc.out.printf("tab row: %s len %s",i,tabs[i][0]);
                    for (int j = 1; j < tabs[i].length; j += 2){
                        Trc.out.printf(" %s %s",tabs[i][j],tabs[i][j+1]);
                    }
                    Trc.out.printf("\n");
                }
                #endif
            }
            // now we have a table with a row for each triple and a column for
            // each triple-set and cells that tell the index in triple starting where
            // the triple-nr,triple-set-nr occurs
            CombVector comb = new CombVector(-1,
                CombVector.HOLES_ACCESSED |
                CombVector.FOLD_ROWS |
                CombVector.PAIRS);
            if ((FL_D & trc) != 0){
                // comb.settrc("ab");
            }
            comb.merge(tabs);
            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                comb.statistics();
            }
            #endif
            this.trtable = comb.tabMerged;
            this.base = comb.base;
            this.check = comb.check;

            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                Trc.out.printf("compact tables\n");
                for (int i = 0; i < this.stateNr; i++){
                    State s = this.table[i];
                    Trc.out.printf("%s:",i);
                    String sep = " ";
                    for (int j = 0; j < nsym; j++){
                        int bas = this.base[i];
                        int start = bas+j;
                        int ele = this.check[start] == bas ? this.trtable[start] : -1;
                        if (ele >= 0){
                            Trc.out.printf("%s%s: %s",sep,j,ele);
                            sep = "; ";
                        }
                    }
                }
            }
            #endif
        }

        /** The compressed table state,sym -> transition. */
        int[] trtable;

        /** The check table. */
        int[] check;

        /** The base table. */
        int[] base;

        /** The accessing symbol sets of states. */
        private long[] accCset;

        /**
         * Build the reverse DFA.
         *
         * @param      all <code>true</code> to build all the start states and the ones
         *             deriving from them, <code>false</code> otherwise
         * @return     reference to the dfa
         */

        void buildReverse(boolean all){
            TRACE(E,"buildPilot reverse\n");

            // build the sets of subclasses of ingoing arcs
            long[] accCset = new long[nfa.table.length];
            for (int i = 0; i < nfa.table.length; i++){
                Nfa.State s = nfa.table[i];
                AstNode ast = null;
                if (s.tnum >= 0){
                    BSATripleData tri = triplesTable[s.tnum];
                    ast = astMap[BSeleToAstNum(tri.startsymbol)];
                } else if (s.number == 0){
                    ast = botAst;
                } else {
                    ast = eofAst;
                }
                if (ast.sym.sym == BOT){
                    accCset[s.number] = 1L << ReParallel.BOT_SCLASS;
                } else if (ast.sym.sym == EOF){
                    accCset[s.number] = 1L << ReParallel.EOF_SCLASS;
                } else {
                    accCset[s.number] = getClassSets(ast.sym);
                }
                TRACE(E,"buildPilot subcl state %s tnum %s ast %s -- sub %s\n",
                    s,s.tnum,ast,csetToString(accCset[s.number]));
            }
            this.accCset = accCset;

            // visit the initial state and the ones generated after it
            // to create all other states

            // create the initial state with the nfa final states
            State state = new State();
            IntSetBit rea = new IntSetBit();
            for (int i = 0; i < nfa.table.length; i++){
                Nfa.State s = nfa.table[i];
                if (s.accepting){
                    rea.add(i);
                }
            }
            state.nfaStates = rea;
            addUnique(state);                          // add a state with these items
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("first state:\n");
                state.trace();
            }
            #endif

            buildPilotRev(state);              // build the pilot
            this.strictStateNr = this.stateNr;

            if (all){
                buildPilotAll(false);          // build the dfas from all states and merge them
            }
            compactTables();                   // produce the compact tables
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("end build reverse fa\n");
                trace();
            }
            #endif
        }

        /**
         * Build the reverse pilot.
         *
         * @param      starts start state
         */

        void buildPilotRev(State starts){                 // build the pilot
            TRACE(E,"buildPilotRev\n");
            IntSetBit rea = new IntSetBit();
            for (State cur = starts; cur != null; cur = (State)cur.suc){
                TRACE(E,"processing state: %s %s\n",cur.number,cur.nfaStates);
                // collect the symbols that make transitions of this state
                long shifts = 0;
                // scan all its NFA states
                int[] ns = cur.nfaStates.toArray();
                for (int i = 0; i < ns.length; i++){
                    shifts |= this.accCset[ns[i]];
                }
                TRACE(E,"  shifts: %s %s\n",csetToString(shifts),longBsToString(shifts));
                for (int n = 0; n < 64; n++){                    // for all the shifts
                    if ((shifts & 1L << n) == 0) continue;
                    // n is the number of the char subclass
                    // determine the nfa states reached
                    rea.clear();
                    for (int j = 0; j < ns.length; j++){
                        int i = ns[j];
                        // take the states reached from nstate with class n
                        Nfa.State s = nfa.table[i];
                        boolean match = (this.accCset[i] & (1L << n)) != 0;
                        TRACE(E,"    nfa state %s shift %s match %s delta %s\n",
                            s.number,n,match,s.delta);
                        if (match){
                            rea.add(s.revdelta);
                        }
                    }
                    TRACE(E,"    reached %s with shift: %s\n",rea,n);
                    // if there are no states, the current is final
                    if (rea.isEmpty()){
                        cur.accepting = true;
                        continue;
                    }
                    // there is at least one state reached with n
                    State nextstate = new State();
                    nextstate.nfaStates = (IntSetBit)rea.clone();
                    addUnique(nextstate);
                    nextstate = (State)this.lastAdded;
                    TRACE(E,"   adding trans to %s subclass %s\n",nextstate.number,n);
                    cur.addArc(new Arc(n,nextstate));
                    #ifdef DEBUG
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    next state:\n");
                        nextstate.trace();
                    }
                    #endif
                }
            }
            this.table = new State[this.stateNr];
            // build table of states
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = s;
            }
        }

        /**
         * Minimize this DFA, if it is a ME-DFA.
         */

        /**
         * A pair of integers.
         */

        static class Pairs {
            List<int[]> list = new LinkedList<int[]>();
            void add(int p, int q){
                for (int[] l : this.list){
                    if (l[0] == p && l[1] == q){
                        return;
                    }
                }
                this.list.add(new int[]{p,q});
            }
        }

        /**
         * Deliver a string representing the list of pairs at the specified indexes.
         *
         * @param      p array of lists of pairs
         * @param      i row index
         * @param      j column index
         * @return     string
         */

        String pairsToString(Pairs [][] p, int i, int j){
            String str = "(";
            if (p != null && p[i] != null && p[i][j] != null){
                for (int[] l : p[i][j].list){
                    str += " " + l[0] + "," + l[1];
                }
            }
            str += ")";
            return str;
        }

        /**
         * Determine the minimized start states of this me-dfa.
         */

        /* The algorithm is an optimized version of thetriangular one:
         *
         * initialize triangular matrix
         * for i from 2 to n
         *   for j from 1 to i - 1
         *     if (i accepting != j accepting)
         *       mark mark case (i, j) as distinguishable
         *       continue;
         *     for each input symbol c
         *       if \delta(q_i, c) is defined and \delta(q_j, c)) is not defined then
         *          mark case (i, j) as distinguishable
         *       else if \delta(q_i, c) is not defined and \delta(q_j, c)) is defined then
         *          mark case (i, j) as distinguishable
         *       else
         *          record into case (i, j) the state pair (\delta(q_i, c), \delta(q_j, c))
         *       end for
         *     end if
         *   end for
         * end for
         *
         * find fixed point
         * repeat
         *   for i from 2 to n
         *     for j from 1 to i - 1
         *       if case (i, j) is not marked as distinguishable
         *         for each pair (q_h, q_k) recorded in case (i, j)
         *           if case (h, k) is marked distinguishable then
         *             mark case (i, j) as distinguishable
         *           end if
         *         end for
         *       end if
         *     end for
         *   end for
         * until no new distinguishability mark was added
         *
         * The equivalence class of state i-th is the half-row i-th, the element i,i,
         * and the half column from i,i down.
         */

        void minimizeMeDfa(){
            TRACE(H,"minimizeMeDfa start\n");
            if ((FL_H & trc) != 0){
                trace();
                Trc.out.printf("%s\n",toGraph());
                Trc.out.printf("nfa: %s\n",nfa.toGraph());
            }
            // minimization of the states of the me-dfa
            // build the triangular matrix that tells the distinguishable states
            boolean[][] dist = new boolean[this.stateNr][this.stateNr];
            // build the triangular matrix that tells the state pairs

            Pairs[][] pairs = new Pairs[this.stateNr][this.stateNr];
            for (int i = 0; i < this.stateNr; i++){
                if (!nfa.gmy && i == 0) continue;   // 0 for fake initial nfa state
                for (int j = 0; j < i; j++){
                    // compare the arcs of state i with the ones of state j
                    boolean eq = false;
                    State s1 = this.table[i];
                    State s2 = this.table[j];
                    if (s1.accepting != s2.accepting){
                        dist[i][j] = true;
                        continue;
                    }
                    comp: {
                        Arc t1 = s1.transList;
                        Arc t2 = s2.transList;
                        while ((t1 != null) && (t2 != null)){
                            if (t1.sclass != t2.sclass){
                                break;
                            } else {
                                if (pairs[i][j] == null){
                                    pairs[i][j] = new Pairs();
                                }
                                if (t1.nextState.number < t2.nextState.number){
                                    pairs[i][j].add(t2.nextState.number,t1.nextState.number);
                                } else {
                                    pairs[i][j].add(t1.nextState.number,t2.nextState.number);
                                }
                            }
                            t1 = t1.next;
                            t2 = t2.next;
                        }
                        eq = t1 == t2;
                        dist[i][j] = !eq;
                    }
                }
            }
            if ((FL_H & trc) != 0){
                Trc.out.printf("triangular matrix\n");
                for (int i = 0; i < this.stateNr; i++){
                    Trc.out.printf("%s:",i);
                    for (int j = 0; j < i; j++){
                        if (dist[i][j]){
                            Trc.out.printf(" %s: dist",j);
                            continue;
                        }
                        String str = "";
                        if (pairs[i][j] != null && pairs[i][j].list != null){
                            for (int[] l : pairs[i][j].list){
                                str += "(" + l[0] + "," + l[1] + ")";
                            }
                        }
                        Trc.out.printf(" %s: eq? %s",j,str);
                    }
                    Trc.out.printf("\n");
                }
            }
            TRACE(H,"minimizeMeDfa fixed point\n");
            // find then the fixed point
            boolean change = true;                         // .. partitions
            while (change){
                TRACE(H,"---new cycle---\n");
                change = false;
                for (int i = 1; i < this.stateNr; i++){
                    TRACE(H,"state %s\n",i);
                    for (int j = 0; j < i; j++){
                        if (!dist[i][j]){
                            if (pairs[i][j] == null || pairs[i][j].list == null) continue;
                            TRACE(H,"  test eq with state %s\n",j);
                            for (int[] l : pairs[i][j].list){
                                int v1 = l[0];
                                int v2 = l[1];
                                TRACE(H,"  pair %s,%s\n",v1,v2);
                                if (dist[v1][v2]){
                                    change = true;
                                    dist[i][j] = true;
                                    TRACE(H,"  dist\n");
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // now dist[i][j] tells if me-dfa states i and j (with i < j) are distinguishable
            if ((FL_H & trc) != 0){
                Trc.out.printf("equivalence classes\n");
                // for state i, it is the half-row i-th, then the diagonal cell,
                // then the half-column down
                boolean[] done = new boolean[dist.length];
                for (int i = 0; i < dist.length; i++){
                    if (done[i]) continue;
                    Trc.out.printf("%s:",i);
                    for (int j = 0; j < i; j++){
                        if (!dist[i][j]){
                            Trc.out.printf(" %s",j);
                            done[j] = true;
                        }
                    }
                    if (!dist[i][i]) Trc.out.printf(" %s",i);
                    for (int j = i+1; j < dist.length; j++){
                        if (!dist[j][i]){
                            Trc.out.printf(" %s",j);
                            done[j] = true;
                        }
                    }
                    Trc.out.printf("\n");
                }
            }

            #ifdef DEBUG
            // compare equivalence classes with the ones of Hopcroft
            String[] parts = new String[0];
            boolean[] done = new boolean[dist.length];
            for (int i = 0; i < dist.length; i++){
                if (done[i]) continue;
                String str = "";
                for (int j = 0; j < i; j++){
                    if (!dist[i][j]){
                        if (str.length() > 0) str += " ";
                        str += j;
                        done[j] = true;
                    }
                }
                if (str.length() > 0) str += " ";
                str += i;
                for (int j = i+1; j < dist.length; j++){
                    if (!dist[j][i]){
                        if (str.length() > 0) str += " ";
                        str += j;
                        done[j] = true;
                    }
                }
                parts = Arrays.copyOf(parts,parts.length+1);
                parts[parts.length-1] = str;
            }
            Arrays.sort(parts);
            TRACE(H,"parts %s\n",Arrays.toString(parts));

            String[] parts1 = minimizeDfa(false);
            if (!Arrays.equals(parts,parts1)){
                Trc.out.printf("!! different partitions %s %s\n",
                    Arrays.toString(parts),Arrays.toString(parts1));
                for (int i = 0; i < dist.length; i++){
                    Trc.out.printf("%s ",i);
                }
                Trc.out.printf("\n");
                for (int i = 0; i < dist.length; i++){
                    Trc.out.printf("%s ",i);
                    for (int j = 0; j < i; j++){
                        Trc.out.printf("%s ",dist[i][j] ? "d" : ".");
                    }
                    Trc.out.printf("\n");
                }
                Trc.out.printf("me-dfa\n");
                trace();
                new Throwable().printStackTrace();
                System.exit(1);
            }
            #endif
 
            // Build the tables of initial states.
            TRACE(H,"me-dfa initial states %s\n",Arrays.toString(this.startStates));
            boolean[] initials = new boolean[this.stateNr];
            for (int i = 0; i < this.startStates.length; i++){
                if (!nfa.gmy && i == 0) continue;   // 0 for fake initial nfa state
                initials[this.startStates[i]] = true;
            }
            // now build a table of the me-dfa representatives of each me-dfa initial state
            // the representative is the lowest initial in its class (which is lowest or
            // equal to the state itself since the state is in its class);
            // build also a table of the nfa representative for each nfa state
            int[] meDfaRepr = new int[this.stateNr];
            int[] nfaRepr = new int[this.startStates.length];
            for (int i = 0; i < this.startStates.length; i++){
                if (!nfa.gmy && i == 0) continue;   // 0 for fake initial nfa state
                // startStates[i] is a ME-DFA start state
                // find its representative
                int meStnum = this.startStates[i];
                int repr = -1;
                for (int j = 0; j < meStnum; j++){
                    if (!dist[meStnum][j] && initials[j]){
                        repr = j;
                        break;
                    }
                }
                if (repr < 0) repr = meStnum;   // represents itself
                meDfaRepr[meStnum] = repr;
                // convert repr into a NFA state number
                boolean found = false;
                for (int j = 0; j < this.startStates.length; j++){
                    if (this.startStates[j] == repr){  // found
                        nfaRepr[i] = j;
                        found = true;
                        break;
                    }
                }
                if (!found){
                    Trc.out.printf("!!!! minimize error\n");
                    new Throwable().printStackTrace();
                    System.exit(1);
                }
            }
            if ((FL_H & trc) != 0){
                Trc.out.printf("representative\n");
                for (int i = 1; i < this.startStates.length; i++){
                    Trc.out.printf("nfa %s nfa repr %s me-dfa %s me-dfa repr %s\n",
                        i,nfaRepr[i],this.startStates[i],meDfaRepr[this.startStates[i]]);
                }
            }
            this.nfaRepres = nfaRepr;

            // then replace all the nfastates in me-dfa states with the set of their
            // representatives
            TRACE(H,"replace me-dfa nfaStates\n");
            for (int i = 0; i < this.table.length; i++){
                // table[i].nfaStates is a set of NFA states
                // replace with their representatives
                IntSetBit bset = new IntSetBit();
                int[] arr = this.table[i].nfaStates.toArray();
                for (int a = 0; a < arr.length; a++){
                    int nstate = arr[a];
                    bset.add(nfaRepr[nstate]);
                }
                TRACE(H,"  me-dfa %s %s repr %s\n",i,this.table[i].nfaStates,bset);
                this.table[i].nfaStates = bset;
            }

            TRACE(H,"building start0 from %s\n",this.table[0].nfaStates);
            // the table of the initial states for chunk 0:
            // take the NFA states reached by BOT, for each one get the representative
            // one of its class, and make a set (removing duplicates)
            this.start0 = this.table[0].nfaStates.toArray();

            TRACE(H,"building start0 done %s\n",Arrays.toString(this.start0));
            TRACE(H,"building start1 from %s\n",Arrays.toString(this.startStates));
            IntSetBit bset = new IntSetBit();
            for (int i = 0; i < this.startStates.length; i++){
                if (!nfa.gmy && i == 0) continue;   // 0 for fake initial nfa state
                int repr = nfaRepr[i];
                bset.add(repr);
            }
            this.start1 = bset.toArray();
            TRACE(H,"building start1 done %s\n",Arrays.toString(this.start1));
            TRACE(H,"minimizeMeDfa done old start: %s new %s\n",
                this.startStates.length,this.start1.length);
        }

        /** The initial states of nfa state 0. */
        int[] start0;

        /** The initial nfa states of the whole me-dfa. */
        int[] start1;

        /** The nfa representatives for each nfa state. */
        int[] nfaRepres;

        /**
         * Minimize this DFA.
         *
         * @param      repl <code>true</code> to replace this automaton with the reduced
         *             one, <code>false</code> otherwise
         * @return     if repl = false, a string representing the partition
         */

        /* Hopcroft algorithm.
         * Partitions:
         *
         *     1. build an initial partition of two groups: the one of the final
         *        states and the one of the non-final ones
         *     2. for each group in the current partition:
         *        keep the group as it is if for all inputs the states in it
         *        have a transition to states in a same group, otherwise
         *        split the group to make this true.
         *        N.B. the states must be in a same group for each input,
         *        no matter if they are in different groups for different inputs.
         *     3. make the new partition current, and repeat step 2.
         *
         * Groups are represented as lists of states, and partitions as arrays with
         * each element being a group (i.e. a partition block).
         * A group is processed by taking its elements one by one: placing the
         * first on a new group by itself, then testing the second against the
         * first and placing it in its group if all its transitions go to states
         * in the same (old) group as the state(s) collected so far, otherwise
         * in a newly created group, and then by repeating this for the remaining
         * ones.
         * Each state in a group is checked against the sub-groups in which
         * the current one is being split so as to find the one to join,
         * or create a new one if none appropriate is found.
         * Since states are kept in a same group when all their transitions lead
         * to states in a same (old) group, this could change if the new groups
         * were taken into account. This is why the process is repeated until no
         * changes occur in groups.
         * Then, the state with the lowest number in each group is taken as its
         * representative, and transitions to states in a group are redirected to
         * its representative.
         * This can lead to have several transitions in a state to a same next
         * state, which are then collapsed before computing the character
         * categories.
         */

        String[] minimizeDfa(boolean repl){
            TRACE(H,"minimizeDfa\n");
            if ((FL_H & trc) != 0){
                trace();
            }
            int sn = this.stateNr;
            State[] curPart = new State[sn+1];          // current partition
            State[] newPart = new State[sn+1];          // new partition
            int[] groupNr = new int[sn+1];              // group numbers of states
            State[] list = new State[sn+1];             // list pointers of groups

            int n = 0;                                  // build initial partition
            for (State h = this.head; h != null;        // visit all states
                h = h.suc){
                State s1 = h;
                for (int i = 0; i < n; i++){        // scan the collected ones
                    State s = curPart[i];
                    TRACE(H,"visit group %s h %s s %s\n",i,h,s);
                    boolean equiv = false;
                    comp: {
                        if (h.accepting){           // final state
                            if (!s.accepting){      // different
                                break comp;
                            }
                        } else {
                            if (s.accepting){       // different
                                break comp;
                            }
                        }
                        equiv = true;
                    }
                    if (equiv){                            // in an existing group
                        TRACE(H,"with: %s\n",curPart[i]);
                        list[s1.number] = curPart[i];      // add to it
                        curPart[i] = s1;
                        s1 = null;
                        break;
                    }
                }
                if (s1 != null){                           // in no groups
                    curPart[n] = s1;                       // create new one
                    list[curPart[n].number] = null;
                    TRACE(E,"new group %s\n",n);
                    n++;
                }
            }
            for (int i = 0; i < n; i++){                   // fill in group numbers
                for (State g = curPart[i];                 // scan group
                    g != null; g = list[g.number]){
                    groupNr[g.number] = i;
                }
            }

            int m = 0;                                     // fragment now
            boolean change = true;                         // .. partitions
            while (change){
                if ((FL_H & trc) != 0){
                    Trc.out.printf("---new cycle--- partition\n");
                    for (int i = 0; i < n; i++){
                        Trc.out.printf("%s:",i);
                        for (State g = curPart[i];
                            g != null; g = list[g.number]){
                            Trc.out.printf(" %s",g);
                        }
                        Trc.out.printf("\n");
                    }
                }
                change = false;
                for (int i = 0; i < n; i++){               // scan current partition
                    TRACE(H,"processing group: %s\n",i);
                    State group = curPart[i];              // current group
                    if (group == null) continue;
                    newPart[m] = group;                    // place first in new group
                    group = list[group.number];
                    list[newPart[m].number] = null;
                    int mm = m++;
                    State next;
                    for (State g = group;                  // scan remaining of current group
                        g != null; g = next){
                        next = list[g.number];
                        TRACE(H,"  processing state: %s\n",g);
                        State s1 = g;
                        for (int j = mm; j < m; j++){      // scan the previous ones in group
                            State s2 = newPart[j];         // take first, all have
                            boolean equiv = false;         // .. the same transitions
                            comp: {
                                Arc t1 = s1.transList;
                                Arc t2 = s2.transList;
                                while ((t1 != null) && (t2 != null)){
                                    if ((t1.sclass != t2.sclass) ||
                                        (groupNr[t1.nextState.number] !=
                                        groupNr[t2.nextState.number])){
                                        TRACE(H,"  t1 %s %s t2 %s %s\n",
                                            t1,groupNr[t1.nextState.number],
                                            t2,groupNr[t2.nextState.number]);
                                        break;
                                    }
                                    t1 = t1.next;
                                    t2 = t2.next;
                                }
                                equiv = t1 == t2;
                                if (!equiv){
                                    TRACE(H,"  t1 %s t2 %s\n",t1,t2);
                                }
                            } // comp
                            if (equiv){                    // in an existing group
                                TRACE(H,"  with: %s\n",newPart[j]);
                                list[s1.number] = newPart[j];      // add to it
                                newPart[j] = s1;
                                s1 = null;
                                break;
                            }
                        }
                        if (s1 != null){                   // in no groups
                            newPart[m] = s1;               // create new one
                            list[newPart[m].number] = null;
                            TRACE(H,"  new group\n");
                            m++;
                            change = true;
                        }
                    }
                }
                for (int i = 0; i < m; i++){               // write group numbers
                    for (State g = newPart[i];             // scan group
                        g != null; g = list[g.number]){
                        groupNr[g.number] = i;
                    }
                }
                State[] tmp = curPart;
                curPart = newPart;
                newPart = tmp;
                n = m;
                m = 0;
            }
            if ((FL_H & trc) != 0){
                Trc.out.printf("minimizeDfa end partitioning\n");
                for (int i = 0; i < n; i++){
                    Trc.out.printf("%s: ",i);
                    for (State g = curPart[i];
                        g != null; g = list[g.number]){
                        Trc.out.printf(" %s",g);
                    }
                    Trc.out.printf("\n");
                }
            }

            if (!repl){
                // represent each partition with a string, and order them
                String[] parts = new String[n];
                for (int i = 0; i < n; i++){
                    boolean[] p = new boolean[this.stateNr];
                    for (State g = curPart[i];
                        g != null; g = list[g.number]){
                        p[g.number] = true;
                    }
                    String str = "";
                    for (int j = 0; j < p.length; j++){
                        if (p[j]){
                            if (str.length() > 0) str += " ";
                            str += j;
                        }
                    }
                    parts[i] = str;
                    TRACE(H,"part %s\n",str);
                }
                Arrays.sort(parts);
                TRACE(H,"parts %s\n",Arrays.toString(parts));
                return parts;
            }
            // reduce now the automaton

            State[] stateMap = newPart;               // build map, reuse newPart
            if ((FL_H & trc) != 0){
                Trc.out.printf("state translation map: old -> new\n");
                for (int i = 0; i < sn; i++){
                    Trc.out.printf("  %s -> %s\n",i,stateMap[i]);
                }
            }
            for (int i = 0; i < n; i++){              // put state translation
                State s = curPart[i];                 // .. in stateMap
                int min = s.number;                   // determine representative
                for (State g = list[s.number];        // it is the one with the
                    g != null; g = list[g.number]){   // .. minimum state number
                    if (g.number < min){
                        min = g.number;
                        s = g;
                    }
                }
                int nn = 0;
                for (State g = curPart[i];            // fill now the translation map
                    g != null; g = list[g.number]){
                    s.nfaStates.add(g.nfaStates);
                    stateMap[g.number] = s;
                }
                TRACE(H,"representative: %s: %s\n",i,s);
            }

            State tail = null;
            State head = null;
            State next = null;
            for (State h = this.head; h != null;  // visit all states
                h = next){
                TRACE(H,"rebuild state: %s\n",h);
                next = h.suc;
                if (stateMap[h.number] == h){             // keep this state
                    if (tail == null){                    // insert at beginning
                        head = h;
                    } else {                              // append
                        tail.suc = h;
                    }
                    h.suc = null;
                    tail = h;
                } else {
                    TRACE(H,"remove: %s\n",h);
                    continue;
                }
                // scan all transitions and translate state 
                for (Arc ts = h.transList; ts != null; ts = ts.next){
                    ts.nextState = stateMap[ts.nextState.number];
                    TRACE(H,"trans: %s -%s-> %s\n",
                        h,ts,ts.nextState);
                }
            }
            this.head = head;
            this.last = tail;
            // renumber states
            int ns = 0;
            for (State h = this.head; h != null;
                h = h.suc){
                h.number = ns++;
            }

            // now rebuild the table of start states
            if (this.startStates != null){
                for (int i = 0; i < this.startStates.length; i++){
                    this.startStates[i] = stateMap[this.startStates[i]].number;
                }
            }

            TRACE(H,"minimizeDfa reduced: %s to %s\n",this.stateNr,ns);
            this.stateNr = ns;

            this.clear();   // clear hash table
            for (State s = this.head; s != null; s = s.suc){
                add(s);
            }
            this.table = new State[this.stateNr];
            // build table of states
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = s;
            }
            TRACE(H,"minimizeDfa done\n");
            if ((FL_H & trc) != 0){
                trace();
            }
            return null;
        }

        /**
         * Deliver a string representing the fa as a graph in the ShowGraph format.
         *
         * @return     string
         */

        String toGraph(){
            Graph g = new Graph(Graph.DIRECTED);
            g.name = "fa";
            // create all nodes
            Node[] nodes = new Node[this.stateNr];
            for (int i = 0; i < this.stateNr; i++){
                nodes[i] = g.newNode("" + i);
            }
            // create then the edges
            for (int i = 0; i < this.stateNr; i++){
                State s = this.table[i];
                if (s.transList != null){
                    for (Arc t = s.transList; t != null; t = t.next){
                        g.newEdge(nodes[s.number],nodes[t.nextState.number],"\"" +
                            subclassToString(t.sclass) + "\"",true);
                    }
                }
            }
            return g.toString();
        }
    }

    //---------- Character subclasses -----------------

    /** The set of character of each character subclass. */
    IntSet[] symClassTable;

    /**
     * Build the partition of the character classes that are present in the ast.
     * Each element of the partition is a character subclass.
     */

    boolean buildSymClass(){
        TRACE(G,"buildSymClass\n");
        IntSet complement = new IntSet();
        complement.assign(0,Character.MAX_VALUE);
        Set<IntSet> tempSet = new HashSet<IntSet>();
        Set<IntSet> classSet = new HashSet<IntSet>();
        IntSet curSet = new IntSet();
        IntSet inter = new IntSet();
        int classNr = 0;
        // scan the states
        for (int i = 0; i < this.nfa.table.length; i++){
            Nfa.State s = this.nfa.table[i];
            TRACE(G,"buildSymClass state %s\n",s);
            if (s.sym.sym == BOT || s.sym.sym == EOF) continue;
            curSet.assign(symToSet(s.sym));
            TRACE(G,"    current set %s, compare with subclasses\n",symSetToString(curSet));
            complement.sub(curSet);                 // update complement
            tempSet.clear();
            Iterator iter = classSet.iterator();
            while (iter.hasNext()){
                IntSet elem = (IntSet)(iter.next());
                TRACE(G,"    subclass %s\n",symSetToString(elem));
                if (curSet.isEmpty()) break;
                if (curSet.equals(elem)){           // already there
                    curSet.clear();
                    TRACE(G,"   found\n");
                    break;
                }
                inter.assign(elem);
                inter.and(curSet);
                if (inter.isEmpty()){
                    TRACE(G,"    no intersection\n");
                    continue;                       // no overlap
                }
                if (!inter.equals(elem)){           // not a superset
                    elem.sub(inter);                // remove common symbols
                    TRACE(G,"    split subclass %s splitted %s\n",
                        symSetToString(elem),symSetToString(inter));
                    IntSet set = (IntSet)inter.clone();
                    tempSet.add(set);               // insert in temporary
                }
                curSet.sub(inter);
                TRACE(G,"    new current set %s\n",symSetToString(curSet));
            }
            if (!curSet.isEmpty()){                 // add to temp
                IntSet set = (IntSet)curSet.clone();
                tempSet.add(set);                   // insert in temporary
                TRACE(G,"    add current %s to temp set %s\n",
                    symSetToString(curSet),symSetToString(set));
            }
            if (!tempSet.isEmpty()){
                TRACE(G,"    add temp %s to subclasses\n",tempSet);
                classSet.addAll(tempSet);
            }
        }
        IntSet[] classTable = new IntSet[classSet.size()];
        classSet.toArray(classTable);
        Arrays.sort(classTable);
        this.symClassTable = new IntSet[classTable.length+3];
        System.arraycopy(classTable,0,
            this.symClassTable,3,classTable.length);     // first three entries reserved
        if (this.symClassTable.length > 64){
            System.out.printf("too many character subclasses %s\n",this.symClassTable.length);
            return false;
        }

        // store then in states the sets of subclasses
        TRACE(G,"buildSymClass store subclasses in states\n");
        for (int i = 0; i < this.nfa.table.length; i++){
            Nfa.State s = this.nfa.table[i];
            if (s.sym.sym == BOT){
                s.cset = 1L << BOT_SCLASS;
            } else if (s.sym.sym == EOF){
                s.cset = 1L << EOF_SCLASS;
            } else {
                s.cset = getClassSets(s.sym);
            }
            TRACE(G,"    changed state %s: %s -- %s\n",s,longBsToString(s.cset),s.cset);
        }
        // store then also in symbols
        TRACE(G,"buildSymClass store subclasses in symbols and asts\n");
        for (int i = 0; i < this.astMap.length; i++){
            AstNode a = this.astMap[i];
            if (a == null) break;
            if (a == this.botAst){
                a.sym.cset = 1L << BOT_SCLASS;
                continue;
            }
            if (a == this.eofAst){
                a.sym.cset = 1L << EOF_SCLASS;
                continue;
            }
            TRACE(G,"    ast %s\n",a);
            if (a.kind == A_LEA){
                a.sym.cset = getClassSets(a.sym);
            }
            TRACE(G,"    changed symbol %s\n",a.sym);
        }
        
        #ifdef DEBUG
        if ((FL_F & this.trc) != 0){
            Trc.out.printf("buildClass done:\n");
            for (int i = 0; i < this.symClassTable.length; i++){
                if (this.symClassTable[i] == null){
                    Trc.out.printf("%s: reserved\n",i);
                } else {
                    Trc.out.printf("%s: %s\n",i,this.symClassTable[i]);
                }
            }
        }
        #endif
        genClassMap();
        return true;
    }

    /**
     * Deliver a set representing a character class for the specified symbol.
     *
     * @param      sym symbol
     * @return     set
     */

    IntSet symToSet(Symbol sym){
        IntSet res = new IntSet();
        switch (sym.kind){
        case S_CHAR:
            res.assign(sym.sym);
            break;
        case S_DOT:
            res.assign(0,Character.MAX_VALUE);
            res.remove('\n');
            break;
        case S_SET:
        case S_NSET:
            res.assign(sym.symset);
            break;
        }
        TRACE(G,"symToSet %s: %s\n",sym,res);
        return res;
    }

    /**
     * Return the set of character subclasses that make up the specified symbol.
     *
     * @param      sym symbol
     * @return     set of subclasses
     */

    long getClassSets(Symbol sym){
        long res = 0;
        IntSet cur = new IntSet();
        IntSet inter = new IntSet();
        cur.assign(symToSet(sym));
        for (int i = 3;                               // find subclasses which
            i < this.symClassTable.length; i++){      // .. make up the set
            inter.assign(this.symClassTable[i]);
            inter.and(cur);
            if (!inter.isEmpty()){                    // found a subset component of the current one
                res |= 1L << i;
                TRACE(G,"component found: %s res %x\n",i,res);
                cur.sub(inter);
                if (cur.isEmpty()) break;
            }
        }
        TRACE(F,"getClassSets %s: %s %x\n",sym,longBsToString(res),res);
        return res;
    }

    /**
     * Deliver a string with the number of the 1 bits in the specified value.
     *
     * @param      bs value
     * @return     string
     */

    String longBsToString(long bs){
        String res = "";
        for (int i = 0; i < 64; i++, bs >>= 1){
            if (bs == 0) break;
            if ((bs & 1L) != 0) res += " " + i;
        }
        return res;
    }

    /**
     * Trace the character subclasses.
     */

    void traceSubClasses(){
        Trc.out.printf("subclasses\n");
        for (int i = 0; i < this.symClassTable.length; i++){
            Trc.out.printf("    %s: %s\n",i,symSetToString(this.symClassTable[i]));
        }
    }
    
    /** The map that tells the number of character subclass of each character for the first plane. */
    private int[] classMap;

    /** The map that tells the number of character subclass of each character. */
    private int[][] classMaps;

    /** The subclass of BOT. */
    static final int BOT_SCLASS = 1;

    /** The subclass of EOF. */
    static final int EOF_SCLASS = 2;
    
    /**
     * Deliver the number of the character subclass of the specified character.
     *
     * @param      ch character
     * @return     number of its subclass
     */

    int subclass(int ch){
        int sub = 0;
        if (ch < 255){
            sub = this.classMap[ch];
        } else if (ch == BOT){
            sub = BOT_SCLASS;
        } else if (ch == EOF){
            sub = EOF_SCLASS;
        } else if (this.classMaps[ch>>>8] != null){
            sub = this.classMaps[ch>>>8][ch&0xff];
        }
        // TRACE(A,"subclass %s %s %s\n",ch,(char)ch,sub);
        return sub;
    }

    /* How character subclasses are used:
     *
     * char c from text
     * (classMap[c] = subclass nr)
     * int sub = (i == 0) ? BOT_SCLASS : subclass(text.charAt(i-1));
     * sym.classSet[subclass nr] = true if sym matches subclass
     * N.B. if sub == 0, the character does not belong to sigma
     */

    /**
     * Generate the map between character and character subclasses.
     */

    void genClassMap(){
        this.classMap = new int[256];
        TRACE(G,"genClassMap %s\n",this.symClassTable.length);
        for (int i = 0; i < this.symClassTable.length; i++){
            if (this.symClassTable[i] == null) continue;
            TRACE(G,"genClassMap subclass %s\n",symSetToString(this.symClassTable[i]));
            int[] arr = this.symClassTable[i].toArray();
            for (int j = 0; j < arr.length; j++){
                if (arr[j] < 256){
                    this.classMap[arr[j]] = i;       // number of subset
                }
                int bn = arr[j] >>> 8;
                if (this.classMaps == null){
                    this.classMaps = new int[256][];
                    this.classMaps[0] = this.classMap;
                }
                if (this.classMaps[bn] == null){
                    this.classMaps[bn] = new int[256];
                }
                this.classMaps[bn][arr[j] & 0xff] = i;
            }
        }
        if (this.classMaps == null) return;
        // share identical blocks
        for (int i = 1; i < this.classMaps.length; i++){
            if (this.classMaps[i] == null) continue;
            int[] curr = this.classMaps[i];
            for (int j = 0; j < i; j++){
                if (this.classMaps[j] == null) continue;
                if (Arrays.equals(this.classMaps[j],curr)){
                    // an equal one found
                    this.classMaps[j] = curr;
                    // TRACE(G,"genClassMap block %s same as %s\n",i,j);
                    break;
                }                        
            }
        }
        if ((FL_F & this.trc) != 0){
            Trc.out.printf("classMap:\n");
            for (int i = 0; i < this.classMap.length; i++){
                Trc.out.printf("%s: %s\n",i,this.classMap[i]);
            }
        }
    }

    //---------- Subsets of triples -----------------
    
    /** The map that tells the subset of triples that start with the same character subclass. */
    private int[] startMap;

    /** The number of the tripleStarting sets. */
    int tripleStartingNr;

    /**
     * Add a new tripleStarting set with the specified set of triples.
     *
     * @param      set set of triples
     * @return     number of the tripleStarting added
     */

    int addTripleSet(IntSet set){
        // TRACE(A,"addTripleSet %s\n",set);
        int res = 0;
        doit: {
            int[] arr = set.toArray();
            if (this.tripleStarting == null){
                this.tripleStarting = new int[100][];
                this.tripleStartingNr = 3;      // first three reserved
                res = this.tripleStartingNr;
                this.tripleStarting[this.tripleStartingNr++] = arr;
                // TRACE(A,"addTripleSet first\n");
                break doit;
            } else {
                // search the table
                for (int i = 0; i < this.tripleStartingNr; i++){
                    if (Arrays.equals(this.tripleStarting[i],arr)){   // found
                        res = i;
                        // TRACE(A,"addTripleSet found %s\n",res);
                        break doit;
                    }
                }
                // not found, add
                if (this.tripleStartingNr >= this.tripleStarting.length){
                    this.tripleStarting =
                        Arrays.copyOf(this.tripleStarting,this.tripleStarting.length+100);
                }
                res = this.tripleStartingNr;
                this.tripleStarting[this.tripleStartingNr++] = arr;
                // TRACE(A,"addTripleSet added %s 0x%x %s\n",res,(int)c,set);
                break doit;
            }
        } // doit
        // TRACE(A,"addTripleSet res %s\n",res);
        return res;
    }
    
    /**
     * Build the tripleStarting tables.
     */

    // startMap[subclass-nr]:  tripleset-nr              0,1,2 reserved
    // tripleStarting[tripleset-nr] = array-of-trioples

    void buildTripleStarting(){
        TRACE(A,"buildTripleStarting\n");
        #ifdef DEBUG
        if ((FL_D & this.trc) != 0){
            Trc.out.printf("buildTripleStarting triples table\n");
            for (int j = 1; j < this.triplesNr; j++){
                Trc.out.printf("    %s: %s\n",j,this.triplesTable[j].toString());
            }
        }
        #endif
        this.tripleStarting = null;
        this.tripleStartingNr = 0;
        this.startMap = new int[this.symClassTable.length];
        for (int c = 0; c < this.symClassTable.length; c++){
            if (this.symClassTable[c] == null) continue;   // reserved
            // compute the set of triples that can start with subclass c
            IntSet set = new IntSet();
            for (int i = 1; i < this.triplesNr; i++){
                BSATripleData tri = this.triplesTable[i];
                int start = tri.startsymbol;
                AstNode ast = astMap[BSeleToAstNum(start)];
                Symbol s = ast.sym;
                if ((s.cset & 1L << c) != 0){
                    set.add(i);
                }
            }
            int setnr = addTripleSet(set);
            this.startMap[c] = setnr;
            TRACE(A,"  subclass %s setnr %s\n",c,setnr);
        }
        // build the set of triples for bot
        IntSet set = new IntSet();
        for (int i = 1; i < this.triplesNr; i++){
            BSATripleData tri = this.triplesTable[i];
            int start = tri.startsymbol;
            AstNode ast = astMap[BSeleToAstNum(start)];
            Symbol s = ast.sym;
            if (s.kind == S_CHAR && s.sym == BOT){
                set.add(i);
            }
        }
        if (this.tripleStarting == null){
            this.tripleStarting = new int[3][];
            this.tripleStartingNr = 3;
        }
        this.tripleStarting[1] = set.toArray();
        this.startMap[1] = 1;

        for (int i = 0; i < this.tripleStartingNr; i++){
            if (this.tripleStarting[i] == null) continue;
            this.maxbs = Math.max(this.maxbs,this.tripleStarting[i].length);
        }

        #ifdef DEBUG
        if ((FL_D & this.trc) != 0){
            traceTripleStarting();
        }
        #endif
        buildTripleToStartNr();
    }

    /**
     * Trace the tripleStarting table.
     */

    void traceTripleStarting(){
        Trc.out.printf("triples starting\n");
        for (int j = 0; j < this.tripleStartingNr; j++){
            if (this.tripleStarting[j] == null) continue;
            Trc.out.printf("    %s: %s\n",j,Arrays.toString(this.tripleStarting[j]));
        }
        Trc.out.printf("start map\n");
        for (int j = 0; j < this.startMap.length; j++){
            Trc.out.printf("    %s: %s\n",j,this.startMap[j]);
        }
    }
    
    /* Here is a map that for each triple tells the index in the tripleStarting table
     * for any character:
     *
     *   int bas = this.base[triple-nr];
     *   int start = bas+startSet(character);
     *   int idx = this.check[start] == bas ? this.tstable[start] : -1;
     *
     * It allows to convert a set of triple numbers in the corresponding set of tripleStarting
     * triples for the dag column corresponding to a character.
     * N.B. startSet() uses the table classMap to obtain the character subclass, and then
     * the table startMap that tells the number of the triple set that start with a same
     * character subclass.
     */
     
    /** The comb table of the map from triple numbers to their bit position in tripleStarting.*/
    private int[] tstable;

    /** The comb base table.*/
    private int[] base;

    /** The comb check table.*/
    private int[] check;

    /**
     * Build the compressed map from triple numbers to their bit position in tripleStarting.
     */

    void buildTripleToStartNr(){
        // build the tripleToStartNr table
        TRACE(D,"buildTripleToStartNr\n");
        #ifdef DEBUG
        if ((FL_D & this.trc) != 0){
            Trc.out.printf("triples starting\n");
            for (int j = 0; j < this.tripleStartingNr; j++){
                Trc.out.printf("    %s: %s\n",j,Arrays.toString(this.tripleStarting[j]));
            }
        }
        #endif

        int[][] tabs = new int[this.triplesNr][];    // tables before compression
        for (int i = 0; i < this.triplesNr; i++){
            // compute the number of triples sets in which a triple occurs
            int nval = 0;
            for (int j = 0; j < this.tripleStartingNr; j++){
                if (this.tripleStarting[j] == null) continue;
                for (int l = 0; l < this.tripleStarting[j].length; l++){
                    if (this.tripleStarting[j][l] == i){
                        nval++;
                        break;
                    }
                }
            }
            tabs[i] = new int[nval*2 + 1];
            int k = 0;
            tabs[i][k++] = this.tripleStartingNr;  // length
            // compute the pairs (triple-set-nr,triple-index-starting)
            for (int j = 0; j < this.tripleStartingNr; j++){
                if (this.tripleStarting[j] == null) continue;
                for (int l = 0; l < this.tripleStarting[j].length; l++){
                    if (this.tripleStarting[j][l] == i){
                        tabs[i][k++] = j;
                        tabs[i][k++] = l;
                        break;
                    }
                }
            }
            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                Trc.out.printf("tab row: %s len %s",i,tabs[i][0]);
                for (int j = 1; j < tabs[i].length; j += 2){
                    Trc.out.printf(" %s %s",tabs[i][j],tabs[i][j+1]);
                }
                Trc.out.printf("\n");
            }
            #endif
        }
        // now we have a table with a row for each triple and a column for
        // each triple-set and cells that tell the index in triple starting where
        // the triple-nr,triple-set-nr occurs
        CombVector comb = new CombVector(-1,
            CombVector.HOLES_ACCESSED |
            CombVector.FOLD_ROWS |
            CombVector.PAIRS);
        if ((FL_D & trc) != 0){
            // comb.settrc("ab");
        }
        comb.merge(tabs);
        #ifdef DEBUG
        if ((FL_D & trc) != 0){
            comb.statistics();
        }
        #endif
        this.tstable = comb.tabMerged;
        this.base = comb.base;
        this.check = comb.check;

        #ifdef DEBUG
        if ((FL_D & trc) != 0){
            Trc.out.printf("compact tables\n");
            for (int i = 0; i < this.triplesNr; i++){
                Trc.out.printf("triple %s:",i);
                String sep = " ";
                for (int j = 0; j < this.tripleStartingNr; j++){
                    if (this.tripleStarting[j] == null) continue;
                    int bas = this.base[i];
                    int start = bas+j;
                    int ele = this.check[start] == bas ? this.tstable[start] : -1;
                    if (ele >= 0){
                        Trc.out.printf("%s%s: %s",sep,j,ele);
                        sep = "; ";
                    }
                }
                Trc.out.printf("\n");
            }
        }
        #endif
    }

    /**
     * Deliver the triple subset for the specified character.
     *
     * @param      ch character
     * @return     number of its subclass
     */

    private int startSet(int ch){
        int sub = 0;
        if (ch <= Character.MAX_VALUE){
            sub = subclass(ch);
        } else if (ch == BOT){
            sub = 1;
        } else if (ch == EOF){
            sub = 2;
        }
        int st = this.startMap[sub];
        // TRACE(A,"startSet %s %s %s\n",ch,(int)ch,st);
        return st;
    }
    
    /** The max length of tripleStarting sets. */
    int maxbs;


    //---------- Compilation --------------

    /** The NFA. */
    Nfa nfa;

    /** The DFA. */
    Dfa dfa;

    /** The reverse DFA. */
    Dfa revdfa;

    /** The map from groupnumbers to numbered parentheses. */
    public int[] groupNumbers;

    /**
     * Compile the specified regular expression.
     *
     * @param      re string of the regular expression
     * @param      kind 0: parsins, 1: recognizion with me-dfa, 2: recognizion with dfa
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    /** Kind of fa. */
    int dfaKind;

    /** The kind of FA for parsing. */
    public static final int ME_DFA = 0;

    /** The kind of FA for recognizion with minimized ME-DFA. */
    public static final int MIN_ME_DFA = 1;

    /** The kind of FA for recognizion with DFA. */
    public static final int DFA = 2;

    /** The kind of FA for recognizion with NFA. */
    public static final int NFA = 3;

    /** The kind of FA for recognizion with CE-DFA. */
    public static final int CE_DFA = 4;

    /** The kind of FA for recognizion with SDFA. */
    public static final int SFA = 5;

    /** The kind of FA for recognizion with minimized ME-DFA and triples NFA. */
    public static final int MIN_ME_DFA_TR = 6;

    /** The kind of FA for recognizion with DFA and triples NFA. */
    public static final int DFA_TR = 7;

    /** The kind of FA for recognizion with NFA and triples NFA. */
    public static final int NFA_TR = 8;

    /** The number of states of the minimized me-dfa. */
    int minMeDfaStartStates;

    /** The kind of FA for recognizion with DFA and forwards initial states optimization. */
    public static final int DFA_F = 9;

    /** The kind of FA for recognizion with DFA and backwards initial states optimization. */
    public static final int DFA_B = 10;

    /** The kind of FA for recognizion with DFA and forwards and backwards initial states optimization. */
    public static final int DFA_FB = 11;

    /** The kind of FA for recognizion with minimized ME-DFA and backwards initial states. */
    public static final int MIN_ME_DFA_B = 12;

    /** The kind of FA for recognizion with non-minimized ME-DFA. */
    public static final int NME_DFA = 13;

    /** The kind of FA for recognizion with non-minimized ME-DFA and backwards initial states. */
    public static final int NME_DFA_B = 14;

    public boolean compile(String re){
        return compile(re,0);
    }
    public boolean compile(String re, int kind){
        TRACE(A,"compile re: %s kind %s\n",Str.strQuoted(re),kind);
        this.error = false;
        this.re = re;
        this.dfaKind = kind;

        doit: {
            TRACE(A,"compile building ast\n");
            if (buildAst() == null){
                this.error = true;
                break doit;
            }
            if (getsym() != -1){      // whole re not consumed
                this.error = true;
            }
            if (this.error){
                break doit;
            }

            if (kind == NFA || kind == DFA || kind == MIN_ME_DFA || kind == MIN_ME_DFA_B ||
                kind == NME_DFA || kind == NME_DFA_B ||
                kind == DFA_F || kind == DFA_B || kind == DFA_FB){
                TRACE(A,"compile digrams %s\n",this.astRoot!=null);
                computeAstBS(this.astRoot);              // compute ini, fin, dig
                TRACE(A,"compile build gmy nfa\n");
                this.nfa = new GMYNfa();
                ((GMYNfa)this.nfa).build();
                #ifdef DEBUG
                if ((FL_A & trc) != 0){
                    this.nfa.trace();
                }
                #endif
                TRACE(A,"compile build char subclasses\n");
                if (!buildSymClass()){
                    this.error = true;
                    return false;
                }
                if (kind == DFA || kind == DFA_F || kind == DFA_B || kind == DFA_FB){
                    TRACE(A,"compile build dfa\n");
                    this.dfa = new Dfa();
                    this.dfa.trc = this.trc;
                    this.dfa.build(false);   // build dfa
                } else if (kind == MIN_ME_DFA || kind == MIN_ME_DFA_B ||
                    kind == NME_DFA || kind == NME_DFA_B){
                    int savekind = kind;
                    TRACE(A,"compile build dfa\n");
                    this.dfa = new Dfa();
                    this.dfa.trc = this.trc;
                    this.dfa.build(true);    // build dfa
                    #ifdef MEFA_TO_DFA;
                    // check if the number of states of the plain DFA is lower
                    // than the number of initial states of the min ME-DFA
                    minMeDfaStartStates = this.dfa.start1.length;
                    TRACE(A,"compile build min dfa\n");
                    this.dfaKind = DFA;
                    Dfa d = new Dfa();
                    d.trc = this.trc;
                    d.build(false);      // build minimized dfa
                    if (this.dfa.start1.length > d.stateNr){
                        // lower: then use the plain DFA
                        kind = DFA;
                        this.dfa = d;
                    } else {
                        kind = savekind;
                        this.dfaKind = kind;
                    }
                    #endif
                }
                #ifdef DEBUG
                if (kind != NFA){
                    if ((FL_A & trc) != 0){
                        this.dfa.trace();
                    }
                }
                #endif
                return !this.error;
            }

            TRACE(A,"compile build triples starting\n");
            TRACE(A,"compile digrams %s\n",this.astRoot!=null);
            computeAstDig(this.astRoot);              // compute ini, fin, dig
            computeNgrams(this.astRoot);

            if (kind == NFA_TR || kind == MIN_ME_DFA_TR ||
                kind == CE_DFA || kind == SFA){  // remove tags
                // this does not produce a nfa in which for each symbol there is only one state:
                // it produces a nfa in which for each triple there is a state
                TRACE(A,"compile remove numbering of metasymbols\n");
                BSATripleData[] newtable = new BSATripleData[this.triplesNr];
                int n = 0;
                for (int i = 0; i < this.triplesNr; i++){
                    BSATripleData tri = this.triplesTable[i];
                    if (tri == null) continue;
                    boolean found = false;
                    for (int j = 0; j < n; j++){
                        BSATripleData ntri = newtable[j];
                        if (ntri.startsymbol == tri.startsymbol && ntri.endsymbol == tri.endsymbol){
                            found = true;
                            break;
                        }
                    }
                    if (!found){
                        newtable[n++] = tri;
                    }
                }
                this.triplesNr = n;
                this.triplesTable = Arrays.copyOf(newtable,n);
            }
            TRACE(A,"compile build triples nfa\n");
            this.nfa = new Nfa();
            this.nfa.buildTriplesNfa();
            #ifdef DEBUG
            if ((FL_A & trc) != 0){
                this.nfa.trace();
                traceTriples();
            }
            #endif
            TRACE(A,"compile build char subclasses\n");
            if (!buildSymClass()){
                this.error = true;
                return false;
            }
            buildTripleStarting();

            // compute the group numbers
            int gnum = 1;
            for (int i = 0; i < this.astMap.length; i++){
                AstNode ast = this.astMap[i];
                if (ast == null) continue;
                if (ast.kind == A_GRO && ast.pos == ast.seq){
                    gnum++;
                }
            }
            this.groupNumbers = new int[gnum];
            gnum = 0;
            this.groupNumbers[gnum++] = astToBSele(astRoot,ELECLOSE);
            for (int i = 0; i < astMap.length; i++){
                AstNode ast = astMap[i];
                if (ast == null) continue;
                if (ast.kind == A_GRO && ast.pos == ast.seq){
                    this.groupNumbers[gnum++] = astToBSele(ast,ELECLOSE);
                }
            }
            #ifdef DEBUG
            if ((FL_A & trc) != 0){
                traceGroups();
            }
            #endif
            if (kind == NFA_TR){                // recognizion only with nfa
                TRACE(A,"compile done\n");
                return !this.error;
            }

            TRACE(A,"compile build dfa\n");
            if (kind == CE_DFA){
                this.dfa = new CeDfa();
                this.dfa.trc = this.trc;
                ((CeDfa)this.dfa).buildCeDfa();
                TRACE(A,"compile done\n");
                return !this.error;
            }
            if (kind == SFA){
                this.dfa = new Sfa();
                this.dfa.trc = this.trc;
                ((Sfa)this.dfa).buildSfa();
                TRACE(A,"compile done\n");
                return !this.error;
            }
            this.dfa = new Dfa();
            this.dfa.trc = this.trc;
            if (kind != ME_DFA){             // recognizion only
                if (kind == MIN_ME_DFA_TR){  // recognize with me-dfa
                    this.dfa.build(true);    // build me-dfa
                } else {
                    this.dfa.build(false);   // build dfa
                }
                #ifdef DEBUG
                if ((FL_A & trc) != 0){
                    Trc.out.printf("dfa:\n");
                    this.dfa.trace();
                }
                #endif
                TRACE(A,"compile done\n");
                return !this.error;
            }
            #ifdef BUILDER_REVDFA
            #ifdef ALL_STARTSTATES
            this.dfa.build(false);
            #else
            this.dfa.build(true);    // build also the multi-entry ones
            #endif
            #else
            this.dfa.build(true);    // build also the multi-entry ones
            #endif

            // the reverse dfa
            TRACE(A,"compile build reverse dfa\n");
            this.revdfa = new Dfa();
            this.revdfa.trc = this.trc;
            #ifdef BUILDER_REVDFA
            #ifdef ALL_STARTSTATES
            this.revdfa.buildReverse(false);
            #else
            this.revdfa.buildReverse(true);    // build also the multi-entry ones
            #endif
            #else
            this.revdfa.buildReverse(true);    // build also the multi-entry ones
            #endif
            #ifdef DEBUG
            if ((FL_A & this.trc) != 0){
                Trc.out.printf("compile dfa\n");
                this.dfa.trace();
                Trc.out.printf("compile reverse dfa\n");
                this.revdfa.trace();
            }
            #endif
            TRACE(A,"compile done\n");
        }
        return !this.error;
    }

    /**
     * Trace the table of groups.
     */

    public void traceGroups(){
        Trc.out.printf("groups\n");
        for (int i = 0; i < this.groupNumbers.length; i++){
            Trc.out.printf("%s: %s\n",i,BSeleToString(this.groupNumbers[i]));
        }
    }

    /**
     * Trace all the tables.
     */

    public void trace(){
        Trc.out.printf("---nfa---\n");
        this.nfa.trace();
        Trc.out.printf("---triples---\n");
        traceTriples();
        Trc.out.printf("---starting---\n");
        traceTripleStarting();
        // tstable, base, check
        Trc.out.printf("---groups---\n");
        traceGroups();
        if (this.dfa != null){
            Trc.out.printf("---dfa---\n");
            this.dfa.trace();
        }
        if (this.revdfa != null){
            Trc.out.printf("---reverse dfa---\n");
            this.revdfa.trace();
        }
    }

    /** A set of integers, represented with bitstrings. */

    class IntSetBit implements Cloneable {

        /** The array to hold the bits. */
        long[] arr;

        /**
         * Construct a set.
         *
         * @return     set
         */

        IntSetBit(){
            this.arr = new long[(nfa.stateNr+63)>>>6];
        }

        /**
         * Construct a set containin the specified bitstring.
         *
         * @param      arr array of the bistring
         * @return     set
         */
         
        IntSetBit(long[] arr){
            this.arr = arr;
        }

        /**
         * Construct a set containin the specified element.
         *
         * @param      elem element
         * @return     set
         */
         
        IntSetBit(int elem){
            this.arr = new long[(nfa.stateNr+63)>>>6];
            this.arr[elem >>> 6] |= 1L << (elem & 0x3f);
        }

        /**
         * Construct a set containin the same elements as the specified set.
         *
         * @param      set other set
         * @return     set
         */
         
        IntSetBit(IntSetBit other){
            this.arr = new long[(nfa.stateNr+63)>>>6];
            assign(other);
        }

        /**
         * Compute the hash code.
         *
         * @return     hash code
         */

        public int hashCode(){
            int h = 0;
            for (int i = 0; i < this.arr.length; i++){
                h = (int)(h*31 + this.arr[i]);
            }
            return h;
        }

        /**
         * Tell if this set is equal to the specified other one.
         *
         * @param      other other set
         * @return     <code>true</code> if equal, <code>false</code> otherwise
         */

        public boolean equals(Object other){
            return equals((IntSetBit)other);
        }
        boolean equals(IntSetBit other){
            for (int i = 0; i < this.arr.length; i++){
                if (this.arr[i] != other.arr[i]) return false;
            }
            return true;
        }

        /**
         * Deliver a clone of this set.
         *
         * @return     clone
         */

        public Object clone(){
            IntSetBit t = null;
            try {
                t = (IntSetBit)super.clone();
                t.arr = (long[])this.arr.clone();
            } catch (CloneNotSupportedException e){
            }
            return t;
        }

        /**
         * Assign this set to contain the same elements of the specified other one.
         *
         * @param      other other set
         */

        void assign(IntSetBit other){
            System.arraycopy(other.arr,0,this.arr,0,this.arr.length);
        }

        /**
         * Add the specified element to this set.
         *
         * @param      elem element
         */

        void add(int elem){
            this.arr[elem >>> 6] |= 1L << (elem & 0x3f);
        }

        /**
         * Add the elements of the specified set to this one.
         *
         * @param      other other set
         */

        void add(IntSetBit other){
            if (other == null) return;
            for (int i = 0; i < this.arr.length; i++){
                this.arr[i] |= other.arr[i];
            }
        }

        /**
         * Do the intersection of this set with the specified other one: keep in
         * this set only the elements that belong also to the specified other set.
         *
         * @param      other other set
         */

        void and(IntSetBit other){
            if (other == null) return;
            for (int i = 0; i < this.arr.length; i++){
                this.arr[i] &= other.arr[i];
            }
        }

        /**
         * Do the intersection of this set with the specified bitstring: keep in
         * this set only the elements that belong also to the specified bitstring.
         *
         * @param      other bitstring
         * @param      off start index in the bitstring
         */

        void and(long[] other, int off){
            if (other == null) return;
            for (int i = 0, j = off; i < this.arr.length; i++, j++){
                this.arr[i] &= other[j];
            }
        }

        /**
         * Tell if this set contains the specified element.
         *
         * @param      el element
         * @return     <code>true</code> if it does, <code>false</code> otherwise
         */
         
        boolean contains(int el){
            return (this.arr[el >>> 6] & (1L << (el & 0x3f))) != 0;
        }

        /**
         * Tell if this set contains all the element sof the specified other set.
         *
         * @param      other other set
         * @return     <code>true</code> if it does, <code>false</code> otherwise
         */
         
        boolean contains(IntSetBit other){
            if (other == null) return true;
            for (int i = 0; i < this.arr.length; i++){
                if ((this.arr[i] | other.arr[i]) != this.arr[i]) return false;
            }
            return true;
        }

        /**
         * Remove from this set the specified element.
         *
         * @param      el element
         */
         
        void sub(int el){
            this.arr[el >>> 6] &= ~(1L << (el & 0x3f));
        }

        /**
         * Remove all the elements from this set.
         */
         
        void clear(){
            Arrays.fill(this.arr,0L);
        }

        /**
         * Deliver a string representing this set.
         *
         * @return     string
         */
         
        public String toString(){
            String res = "";
            for (int i = 0; i < this.arr.length<<6; i++){
                if ((this.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    if (res.length() != 0) res += " ";
                    res += "" + i;
                }
            }
            return "{" + res + "}";
        }

        /**
         * Tell if this set is empty.
         *
         * @return     <code>true</code> if it is, <code>false</code> otherwise
         */
         
        boolean isEmpty(){
            boolean res = true;
            for (int i = 0; i < this.arr.length; i++){
                if (this.arr[i] != 0){
                    return false;
                }
            }
            return true;
        }

        /**
         * Tell if this the intersection of thie set with the specifed one is not empty,
         * i.e. if there is at least one element present in both sets.
         *
         * @param      set other set
         * @return     <code>true</code> if it is, <code>false</code> otherwise
         */
         
        boolean intersects(IntSetBit set){
            boolean res = false;
            for (int i = 0; i < this.arr.length; i++){
                long val = this.arr[i] & set.arr[i];
                if (val != 0){
                    return true;
                }
            }
            return false;
        }

        /**
         * Deliver an array containing the elements of this set.
         *
         * @return     array
         */
         
        int[] toArray(){
            int n = 0;
            for (int i = 0; i < this.arr.length<<6; i++){
                if ((this.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    n++;
                }
            }
            int[] res = new int[n];
            n = 0;
            for (int i = 0; i < this.arr.length<<6; i++){
                if ((this.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    res[n++] = i;
                }
            }
            return res;
        }

        /**
         * Deliver the number of elements of this set.
         *
         * @return     cardinality
         */
         
        int card(){
            int n = 0;
            for (int i = 0; i < this.arr.length<<6; i++){
                if ((this.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    n++;
                }
            }
            return n;
        }

        /**
         * Deliver the element of this set if it contains only one, and -1 otherwise.
         *
         * @return     element, -1 if the set contains none or several
         */
         
        int singleton(){
            int res = -1;
            int n = 0;
            for (int i = 0; i < this.arr.length<<6; i++){
                if ((this.arr[i >>> 6] & (1L << (i & 0x3f))) != 0){
                    n++;
                    res = i;
                }
            }
            return n == 1 ? res : -1;
        }
    }

    /** Iterators over an IntBitSet. */
    
    #define function FOREACH_IS(set){
        var str = "for (int nstate = 0; nstate < " + set + ".arr.length<<6; nstate++){";
        str += "if ((" + set + ".arr[nstate >>> 6] & (1L << (nstate & 0x3f))) == 0) continue;";
        return str;
    };
    #define function ENDFOR_IS(){
        return "}";
    };

    //----- The parser -----

    /** The text. */
    String text;

    /**
     * Parse the text using the specified number of threads.
     *
     * @param      text text
     * @param      t number of threads: 0 = sequential, 1+ ne. of threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    public boolean parse(String text, int t){
        if (t == 0){
            return matchSeq(text,false);
        }
        return matchPar(text,t,false);
    }

    /**
     * Recognize the text using the specified number of threads.
     *
     * @param      text text
     * @param      t number of threads: 0 = sequential, 1+ ne. of threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    public boolean match(String text, int t){
        if (t == 0){
            return matchSeq(text,true);
        }
        return matchPar(text,t,true);
    }

    /**
     * Parse the text using the sequential algorithm.
     *
     * @param      text text
     * @param      rec <code>true</code> to perform only recognizion, <code>false</code> otherwise
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    public boolean matchSeq(String text){
        return matchSeq(text,false);
    }
    public boolean matchSeq(String text, boolean rec){
        TRACE(MP,"matchSeq %s\n",Str.strQuoted(text));
        TRACE(Q,"matchSeq\n");
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            // this.traceAstMap();
            this.nfa.trace();
            Trc.out.printf("triples starting\n");
            for (int j = 0; j < this.tripleStartingNr; j++){
                Trc.out.printf("    %s: %s\n",j,Arrays.toString(this.tripleStarting[j]));
            }
            Trc.out.printf("dfa\n");
            this.dfa.trace();
            Trc.out.printf("revdfa\n");
            this.revdfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        #ifdef MEASURE
        this.measure = new Measure(1);
        this.measure.nrChunks = 1;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = 1;
        DagBuilder htb = new DagBuilder(64,"m");
        htb.synch = false;
        this.dagHtb = htb;
        #ifdef MEASURE
        this.measure.htb = htb;
        #endif

        long[] tmpbsarr = new long[this.maxbs];
        IntSetBit tmpset = new IntSetBit();
        if (text.length() == 0){                     // special case for the empty string
            IntSetBit init = transit(0,BOT);         // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    tmpset.add(nstate);
                    res = true;
                }
            ENDFOR_IS();
            if (res){
                this.dag = new long[1];
                htb.dag = this.dag;
                intSetToDag(tmpset,0,tmpbsarr);
                #ifdef DEBUG
                if (((FL_P|FL_Q) & this.trc) != 0){
                    Trc.out.printf("matchSeq dag: %s\n",dagToString());
                    traceDag();
                }
                #endif
            }
            return res;
        }

        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif
        int start = 0;
        int end = text.length();

        this.dag = new long[text.length()+1];
        htb.dag = this.dag;
        IntSetBit reached = null;

        int cur = 0;
        for (int j = start; j < end; j++){
            TRACE(M,"--- char %s at %s curstate %s\n",text.charAt(j),j,cur);
            this.dag[j] = cur;
            TRACE(Q,"dag[%s]: %s\n",j,this.dag[j]);
            int ch = text.charAt(j);
            int bas = this.dfa.base[cur];
            int startt = bas+subclass(ch);
            int ele = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
            if (ele < 0){
                this.cursor = j;
                TRACE(MQ,"matchSeq failed at %s\n",this.cursor);
                return false;
            }
            cur = ele;
        }
        this.dag[end] = cur;
        TRACE(Q,"last dag[%s]: %s cur %s\n",end,this.dag[end],cur);
        if (!this.dfa.table[cur].accepting){
            this.cursor = end;
            TRACE(MQ,"matchSeq failed at %s\n",this.cursor);
            return false;
        }
        if (rec) return true;
        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        // now we have a dag in which there are states that are reached by
        // the starting ones, but some could not reach the end ones: work
        // backwards and remove them: keep the states that reach the end ones,
        // and remove the ones that do not

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        Dfa revdfa = this.revdfa;
        int state = 0;
        IntSetBit backstates = (IntSetBit)this.dfa.table[cur].nfaStates.clone();
        for (int j = end; j >= start; j--){
            int ch = j >= this.text.length() ? EOF : text.charAt(j);
            TRACE(M,"back col %s %s state %s fwd states %s rev states %s %s\n",
                j,ch,state,backstates,revdfa.table[state].number,revdfa.table[state].nfaStates);
            backstates.and(revdfa.table[state].nfaStates);
            intSetToDag(backstates,j,tmpbsarr);
            TRACE(M,"   dag[%s]: acc %s %s %s\n",
                j,text.charAt(end-1),
                dagElemToString(this.dag,j,2,htb),
                dagElemToString(this.dag,j,0,htb));
            TRACE(Q,"dag[%s]: %s\n",j,dagElToString(dag[j],htb));
            if (j == 0) break;
            ch = j-1 >= this.text.length() ? EOF : text.charAt(j-1);
            int bas = revdfa.base[state];
            int startt = bas+subclass(ch);
            int newstate = revdfa.check[startt] == bas ? revdfa.trtable[startt] : -1;
            TRACE(Q,"transition state %s subclass %s next %s\n",state,subclass(ch),newstate);
            state = newstate;
            if (j > 0) cur = (int)this.dag[j-1];
            TRACE(M,"  at pos %s, new states %s %s\n",j,state,revdfa.table[state].nfaStates);
            backstates = (IntSetBit)this.dfa.table[cur].nfaStates.clone();
        }
        #ifdef DEBUG
        if (((FL_P|FL_Q) & this.trc) != 0){
            Trc.out.printf("matchSeq dag: %s\n",dagToString());
            traceDag();
        }
        #endif

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("dag:\n");
            traceDag();
        }
        checkDag(htb);
        #endif
        
        #ifdef DEBUG
        if (((FL_P|FL_Q) & this.trc) != 0){
            Trc.out.printf("matchSeq dag: %s\n",dagToString());
            traceDag();
        }
        #endif
        TRACE(MQ,"matchSeq success\n");
        #ifdef MEASURE
        this.measure.timePar[5] = System.nanoTime();
        this.measure.timePar[6] = System.nanoTime();
        this.measure.dagStatis();
        #endif
        return true;
    }
    
    // Parallel execution

    /** A synchronized counter. */

    private static class Counter {

        /** The counter. */
        int counter;

        #ifdef LOAD_BALANCE
        /** The max value. */
        int max;

        /**
         * Deliver a new counter with the specified max value.
         *
         * @param      max max value
         * @return     counter
         */

        Counter(int max){
            this.max = max;
        }
        #endif
        
        #ifdef LOAD_BALANCE
        /**
         * Deliver the value of the counter, and intrements it.
         *
         * @return     value, -1 if maximum reached
         */
         
        synchronized int get(){
            if (this.counter == this.max) return -1;
            return this.counter++;
        }
        #else
        /**
         * Deliver the value of the counter, and intrements it.
         *
         * @return     value
         */
         
        synchronized int get(){
            return this.counter++;
        }
        #endif
    }

    /**
     * Start the number of specified threads executing each the specified method,
     * and waits for the completion of all of them.
     *
     * @param      P number of threads
     * @param      meth method
     * @return     <code>true</code> if all threads ended successfully, <code>false </code> otherwise
     */
        
    private boolean parallelExec(int P, Callable<Boolean> meth){
        boolean res = true;
        List<Callable<Boolean>> callableTasks = new ArrayList<>();
        for (int i = 0; i < P; i++){
            callableTasks.add(meth);
        }
        ExecutorService executor = Executors.newFixedThreadPool(P);
        List<Future<Boolean>> futures = null;
        try {
            futures = executor.invokeAll(callableTasks);
        } catch (InterruptedException exc){
            System.out.printf("%s\n",exc);
        }

        /*
        ThreadPoolExecutor pool = (ThreadPoolExecutor) executor;
        System.out.println("Core threads: " + pool.getCorePoolSize());
        System.out.println("Largest executions: "
           + pool.getLargestPoolSize());
        System.out.println("Maximum allowed threads: "
           + pool.getMaximumPoolSize());
        System.out.println("Current threads in pool: "
           + pool.getPoolSize());
        System.out.println("Currently executing threads: "
           + pool.getActiveCount());
        System.out.println("Total number of threads(ever scheduled): "
           + pool.getTaskCount());
        */

        // then wait for all of them to terminate and get results
        executor.shutdown();
        try {
            if (!executor.awaitTermination(1000, TimeUnit.MILLISECONDS)){
                executor .shutdownNow();
            } 
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
        TRACE(MQ,"all tasks done\n");
        try {
            for (Future<Boolean> f : futures){
                Boolean result = f.get();
                TRACE(M,"result %s\n",result);
                if (!result){
                    res = false;
                    break;
                }
            }
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        return res;
    }

    /** The measures. */
    
    class Measure {

        /** The number of threads. */
        int nrThreads;

        /** The number of chunks. */
        int nrChunks;

        /** Whether recognizion only is done. */
        boolean recognizionOnly;

        /** The start time of matchParFwd for each P. */
        long[] timeStartFwd;

        /** The end time of matchParFwd for each P. */
        long[] timeEndFwd;

        /** The start time of buildCleanDag matchParFwd for each P. */
        long[] timeStartBwd;

        /** The end time of buildCleanDag matchParFwd for each P. */
        long[] timeEndBwd;

        /** The length of chunks for each P. */
        int[] sizeChunk;

        /** The nr of operations in matchParFwd for each P. */
        int[] nrOpFwd;

        /** The nr of operations in buildClean for each P. */
        int[] nrOpBwd;

        /** The intermediate times: 0 start, 1 init fwd, 2: start matchParFwd,
         *  3: end matchParFwd, 4 end sew and start bwd, 5 end bwd, 6 end. */
        long[] timePar;

        /** The dag hash table and the reference to to dag in it. */
        DagBuilder htb;

        /** The nr of forward operations for each dag column. */
        int[] nrOpByCol;

        /** The nr of start states by chunk. */
        int[] chunkStart;

        /** The text. */
        String text;

        /** The rate of long dag elements over total. */
        double longRate;

        /** The average cardinality of state sets in columns. */
        double aveCard;

        /** The average nr of states in the forward pass for each chunk. */
        double[] aveStChunk;

        /** The average nr of states that survives in the forward pass for each chunk. */
        int[] parsesSurvived;

        /** The lengths of the parses done by each reachers. */
        int[][] parsesLen;

        /** The transitions done by each reachers. */
        int[] nrtrans;

        /** The footprint for each chunk. */
        int[] footPrint;

        /** The initial states of all chunks. */
        int initialStates;

        /**
         * Construct a measure object for the specified number of chunks.
         *
         * @param      P number of chunks
         */
         
        Measure (int P){
            this.timeStartFwd = new long[P];
            this.timeEndFwd = new long[P];
            this.timeStartBwd = new long[P];
            this.timeEndBwd = new long[P];
            this.sizeChunk = new int[P];
            this.nrOpFwd = new int[P];
            this.nrOpBwd = new int[P];
            this.timePar = new long[7];
            this.text = ReParallel.this.text;
            this.nrOpByCol = new int[this.text.length()+1];
            this.chunkStart = new int[P];
            this.aveStChunk = new double[P];
            this.parsesSurvived = new int[P];
            this.parsesLen = new int[P][];
            this.nrtrans = new int[P];
            this.footPrint = new int[P];
        }

        /**
         * Store in this measure object the statistics of the dag.
         */
         
        void dagStatis(){
            int longs = 0;
            long totcard = 0;
            for (int i = 0; i < htb.dag.length; i++){
                if (htb.dag[i] < 0) longs++;
                totcard += cardDag(i);
            }
            this.longRate = (double)longs/htb.dag.length;
            this.aveCard = (double)totcard/htb.dag.length;
        }

        /**
         * Trace this object.
         */

        public void trace(){
            Trc.out.printf("nfa states %s dfa states %s\n",nfa.stateNr,dfa.stateNr);
            Trc.out.printf("threads %s chunks %s chunk size %s%s\n",this.nrThreads,this.nrChunks,
                Arrays.toString(this.sizeChunk),this.recognizionOnly ? "recognizion only" : "");
            Trc.out.printf("time tot %s reachers %s builders %s\n",
                (this.timePar[6]-this.timePar[0])/1000000,
                (this.timePar[3]-this.timePar[2])/1000000,
                (this.timePar[5]-this.timePar[4])/1000000);
            Trc.out.printf("reachers op %s\n",Arrays.toString(this.nrOpFwd));
            Trc.out.printf("builders op %s\n",Arrays.toString(this.nrOpBwd));
            if (this.nrChunks > 1){
                Trc.out.printf("chunk start states %s ave .2f\n",Arrays.toString(this.chunkStart),this.aveStChunk);
                Trc.out.printf("chunk parses survived %s\n",Arrays.toString(this.parsesSurvived));
            }
            Trc.out.printf("dag long rate %.2f dag ave card %.2f\n",this.longRate,this.aveCard);
            Trc.out.printf("nr of transitions %s\n",Arrays.toString(this.nrtrans));
        }
    }

    /** The measure object. */
    Measure measure;

    /** The number of threads. */
    int nrThreads;

    /** The number of chunks. */
    int nrChunks;

    /** Whether recognizion only is done. */
    boolean recognizionOnly;

    /**
     * Seek a point in the text in an interval of the chunk start that has fewer starting
     * states with respect to the chunk start.
     *
     * @param      idx index in the text where the chunk starts
     * @param      chunk number of the chunk
     * @return     point
     */

    int seekGoodPoint(int idx, int chunk){
        int bspan = 0;
        int fspan = chunk / 5;
        int min = Integer.MAX_VALUE;
        int start = idx-bspan;
        if (start < 0) start = 0;
        int end = idx+fspan;
        if (end > this.text.length()) end = this.text.length();
        int res = idx;
        for (int i = start; i < end; i++){
            char ch = this.text.charAt(i);
            int tsn = startSet(ch);
            if (tsn == 0) break;               // character not in sigma
            int n = this.tripleStarting[tsn].length;
            if (n < min){
                min = n;
                res = i;
            }
        }
        return res;
    }

    /** The start indexes of chunks. */
    int[] startChunk;

    /**
     * Deliver the start index of the specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @return     index
     */

    int startChunk(int pi, int P){
        return this.startChunk[pi];
    }

    /**
     * Deliver the end index (last text position + 1) of the specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @return     index
     */

    int endChunk(int pi, int P){
        return pi == P-1 ? this.text.length() : this.startChunk[pi+1];
    }

    /** Whether parsing is called during testing. */
    boolean testing;        // whether it is called in testing

    /**
     * Deliver the number of threads and chunks for the specified text length,
     * minimum chunk size and cores.
     *
     * @param      L length of text
     * @param      M minimum chunk size
     * @param      P number of cores
     * @param      D <code>true</code> if in testing, <code>false</code> otherwise
     * @param      B <code>true</code> if load balancing, <code>false</code> otherwise
     * @return     number of threads, which is the same as the number of chunks
     */

    record ThCh(int nt, int nc){};
    
    static ThCh nrThreads(int L, int M, int P, boolean D, boolean B){
        int T = Math.min(L/M,P);    // number of threads
        int N = 0;                  // number of chunks
        if (D){                     // in testing
            T = 2;
            if (L < 2 || T > P) T = 1;
            N = T;
        } else if (L < M){
            T = 1;
            N = 1;
        } else {
            N = T;
            if (B){
                if ((L/N)/4 < 1){
                    T = 1;
                    N = 1;
                } else {
                    N *= 4;
                }
            }
        }
        return new ThCh(T,N);
    }

    /** The minimum length of a chunk for parallelism to pay off. */
    private static final int MIN_CHUNK_LEN = 1024;

    /**
     * Parse the text using the parallel algorithm.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: all cores, 1+ number of threads
     * @param      rec <code>true</code> to perform recognizion only, <code>false</code> otherwise
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    #ifdef BUILDER_REVDFA
    #else
    boolean matchPar(String text, int nrproc){
        return matchPar(text,nrproc,false);
    }
    boolean matchPar(String text, int nrproc, boolean rec){
        TRACE(MPQ,"matchPar %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            this.traceAstMap();
            this.nfa.trace();
            Trc.out.printf("triples starting\n");
            for (int j = 0; j < this.tripleStartingNr; j++){
                Trc.out.printf("    %s: %s\n",j,Arrays.toString(this.tripleStarting[j]));
            }
            Trc.out.printf("dfa\n");
            this.dfa.trace();
            Trc.out.printf("revdfa\n");
            this.revdfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();
        
        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks

        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = rec;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = rec;
        DagBuilder htb = new DagBuilder(64,"m");
        htb.synch = true;
        this.dagHtb = htb;
        #ifdef MEASURE
        this.measure.htb = htb;
        #endif
        long[] tmpbsarr = new long[this.maxbs];
        IntSetBit tmpset = new IntSetBit();
        if (this.text.length() == 0){                     // special case for the empty string
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    tmpset.add(nstate);
                    res = true;
                }
            ENDFOR_IS();
            if (res){
                this.dag = new long[1];
                htb.dag = this.dag;
                intSetToDag(tmpset,0,tmpbsarr);
                #ifdef DEBUG
                if (((FL_P|FL_Q) & this.trc) != 0){
                    Trc.out.printf("matchSeq dag: %s\n",dagToString());
                    traceDag();
                }
                #endif
            }
            return res;
        }

        TRACE(MPQ,"matchPar ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start of chunks
        this.startChunk = new int[nrChunks];    // index of chunk start in text
        TRACE(Q,"matchPar nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = seekGoodPoint(start,chunk);
                if (this.startChunk[i] <= this.startChunk[i-1]){   // avoid overlap
                    this.startChunk[i] = this.startChunk[i-1]+1;
                }
            }
        }

        // use -1 to tell that there are no states
        int[][] L = new int[nrChunks][];                  // current states
        // determine the start states of all the chunks
        for (int i = 0; i < nrChunks; i++){
            L[i] = new int[this.nfa.stateNr];
            Arrays.fill(L[i],-1);
            int n = 0;
            if (i == 0){          // first chunk, use only the real start states
                FOREACH_IS(this.dfa.table[0].nfaStates);
                    L[i][nstate] = this.dfa.startStates[nstate];
                    n++;
                ENDFOR_IS();
            } else {
                for (int j = 0; j < this.nfa.stateNr; j++){
                    L[i][j] = this.dfa.startStates[j];
                    if (L[i][j] >= 0) n++;
                }
            }
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
            #ifdef MEASURE
            this.measure.chunkStart[i] = n;
            #endif
        }

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward start states:\n");
            traceL(L);
        }
        #endif

        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif
        if (nrproc == 1 && testing){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!matchParFwd(i,nrChunks,L)){
                    TRACE(M,"matchPar failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            this.measure.nrThreads = 1;
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return matchParFwd(cnt,nrChunks,L);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return matchParFwd(cnt.get(),nrChunks,L);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"matchPar failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached states by segment:\n");
            traceL(L);
        }
        #endif

        TRACE(MPQ,"matchPar ---- sewing\n");

        // here we have array L: one vector, for each segment;
        // each element of the vector is a state:
        // the element i-th contains the state reached by the state i-th,
        // a start state for the segment.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L vector contains the state reached by transitions done with
        // the last character of the segment.

        int[] startdfastates = new int[nrChunks];
        IntSetBit Ltemp = transit(0,BOT);          // initial
        TRACE(M,"matchPar initial %s\n",Ltemp);
        // make the union of the sets of states reached by the ones in Ltemp
        for (int k = 0; k < nrChunks; k++){
            int[] Lk = L[k];
            TRACE(M,"matchPar segm %s Ltemp %s\n",k,Ltemp);
            IntSetBit next = new IntSetBit();
            FOREACH_IS(Ltemp);
                // get the ones reached by it
                if (Lk[nstate] >= 0){
                    next.add(this.dfa.table[Lk[nstate]].nfaStates);
                }
            ENDFOR_IS();
            // here Ltemp is a dfa state
            Dfa.State newst = this.dfa.new State();
            newst.nfaStates = Ltemp;
            newst = this.dfa.search(newst);
            startdfastates[k] = newst.number;
            TRACE(M,"matchPar start dfa state for chunk %s: %s\n",k,startdfastates[k]);

            Ltemp = next;     // then use the reached states as the current set
            TRACE(M,"matchPar sew forward segment %s reaches %s\n",k,next);
            if (Ltemp.isEmpty()){
                this.cursor = endChunk(k,nrChunks)-1;
                res = false;
                break;
            }
            // remove the states in the next L that are not reached
            if (k < nrChunks-1){
                int[] Lk1 = L[k+1];
                boolean[] keep = new boolean[this.nfa.stateNr];
                FOREACH_IS(Ltemp);
                    keep[nstate] = true;
                ENDFOR_IS();
                for (int nstate = 0; nstate < keep.length; nstate++){
                    if (!keep[nstate]){
                        Lk1[nstate] = -1;
                    }
                }
            }
        }
        TRACE(M,"matchPar sew forward segment end %s\n",Ltemp);

        // Ltemp here contains the states reached by the last segment,
        // check that it contains at least an accepting state
        FOREACH_IS(Ltemp);
            TRACE(M,"matchPar --- %s\n",nstate);
            if (this.nfa.table[nstate].accepting){
                res = true;
                break;
            }
        ENDFOR_IS();

        TRACE(M,"matchPar ---- end forward sewing, accepted %s\n",res);
        if (!res){
            TRACE(M,"matchPar res %s\n",res);
            return res;
        }
        if (rec){      // recognizion
            return res;
        }

        // clean also the L of the initial segment
        IntSetBit first = transit(0,BOT);   // states reached by bot
        boolean[] keep = new boolean[this.nfa.stateNr];
        FOREACH_IS(first);
            keep[nstate] = true;
        ENDFOR_IS();
        for (int nstate = 0; nstate < keep.length; nstate++){
            if (!keep[nstate]){
                L[0][nstate] = -1;
            }
        }
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward reached states:\n");
            traceL(L);
        }
        #endif

        // sew backwards
        TRACE(M,"matchPar ------- sew backwards\n");
        // start with the L of the last segment, and build the set of the final
        // states reached by it
        IntSetBit backbs = new IntSetBit();
        int ns = this.nfa.stateNr;
        for (int i = 0; i < ns; i++){                // take all the nfa states reached
            int Lpi = L[nrChunks-1][i];
            if (Lpi < 0) continue;
            backbs.add(this.dfa.table[Lpi].nfaStates);
        }
        backbs.and(this.revdfa.table[0].nfaStates);  // remove the non-final ones
        if (!backbs.isEmpty()){
            res = true;
        }
        TRACE(M,"matchPar finals %s\n",backbs);
        this.dag = new long[this.text.length()+1];
        htb.dag = this.dag;
        TRACE(P,"matchPar last dag column ");
        // last column of dag
        intSetToDag(backbs,this.dag.length-1,tmpbsarr);
        TRACE(M,"matchPar dag[%s] finals %s\n",this.dag.length-1,
            dagElemToString(this.dag,this.dag.length-1,0,htb));
        TRACE(Q,"last dag[%s]: %s\n",this.dag.length-1,
            dagElToString(this.dag[this.dag.length-1],htb));

        // then take the last segment, and remove from its L sets the states that are not in back,
        // compute then the set of states that have then nonempty L lists, to become the new back

        IntSetBit[][] N = new IntSetBit[nrChunks][];      // vectors with nfa states
        IntSetBit reached = null;
        for (int k = nrChunks-1; k >= 0; k--){
            TRACE(M,"matchPar ------- sew backwards segm %s\n",k);
            N[k] = new IntSetBit[this.nfa.stateNr];
            IntSetBit newbackbs = new IntSetBit();
            for (int i = 0; i < ns; i++){
                if (L[k][i] < 0) continue;
                IntSetBit ls = (IntSetBit)this.dfa.table[L[k][i]].nfaStates.clone();
                ls.and(backbs);
                if (!ls.isEmpty()){
                    TRACE(M,"matchPar ------- sew backwards newback set %s\n",i);
                    newbackbs.add(i);
                    N[k][i] = ls;
                } else {
                    N[k][i] = null;
                }
            }
            TRACE(M,"  segm %s back %s new %s\n",k,backbs,newbackbs);
            backbs = newbackbs;
        }

        // at this point we have the start and end states of each segment as they are
        // in the clean dag; use now them to obtain the clean dag
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("backwards reached states by segment:\n");
            traceL(L);
        }
        if ((FL_P & this.trc) != 0){
            Trc.out.printf("clean states by segment:\n");
            traceL(L);
        }
        #endif

        // clean each segment: build a sequence of bitstrings, one for
        // each string position, with bits telling what triples out of
        // tripleStarting are part of an accepting path
        TRACE(MPQ,"matchPar ------- build dag\n");

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        if (nrproc == 1 && testing){
            for (int i = 0; i < nrChunks; i++){
                buildCleanDag(i,nrChunks,N,startdfastates);
            }
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt1 = new Counter(nrChunks);
            Callable<Boolean> clean = () -> {
                buildCleanDag(cnt1,nrChunks,N,startdfastates);
                return true;
            };
            #else
            final Counter cnt1 = new Counter();
            Callable<Boolean> clean = () -> {
                buildCleanDag(cnt1.get(),nrChunks,N,startdfastates);
                return true;
            };
            #endif
            parallelExec(P,clean);
        }
        #ifdef DEBUG
        if (((FL_M|FL_P|FL_Q) & this.trc) != 0){
            Trc.out.printf("before --------------------dag:\n");
            showDag(this.dag);
        }
        #endif
        #ifdef MEASURE
        this.measure.timePar[5] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M|FL_P|FL_Q) & this.trc) != 0){
            Trc.out.printf("clean dag:\n");
            traceDag();
            showDag(0,this.dag.length,this.dagHtb);
        }
        #endif

        TRACE(M,"matchPar res %s\n",res);
        #ifdef MEASURE
        this.measure.timePar[6] = System.nanoTime();
        this.measure.dagStatis();
        #endif
        return res;
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the forward pass over the text taking chunks from the queue until it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean matchParFwd(Counter cnt, int P, int[][] L){
        TRACE(Q,"matchParFwd\n");
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            if (!matchParFwd(pi,P,L)) return false;
        }
        return true;
    }
    #endif
     
    /**
     * Make the forward pass over the text executing the reader on the specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    /* Here we start with a vector of (start) states, each element is a dfa state
     * initially containing only the same state, and at each character we make a transition
     * replacing it with the state reached by it
     */

    private boolean matchParFwd(int pi, int P, int[][] L){
        TRACE(MQ,"matchParFwd segment %s\n",pi);
        #ifdef MEASURE
        this.measure.timeStartFwd[pi] = System.nanoTime();
        #endif

        int[] Lpi = L[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);
        #ifdef MEASURE
        this.measure.sizeChunk[pi] = end-start;
        #endif

        // initialize
        // The starting vector has an entry for all the states.
        // The entry is a set with the state itself.

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            for (int i = 0; i < Lpi.length; i++){
                if (Lpi[i] < 0) continue;
                TRACE(M,"  initial states %s: Lpi[%s] %s\n",i,i,Lpi[i]);
            }
        }
        #endif

        TRACE(M,"matchParFwd text piece %s-%s\n",start,end);

        #ifdef MEASURE
        int[] lengths = new int[Lpi.length];
        int li = 0;
        #endif
        int parses = 0;
        for (int i = 0; i < Lpi.length; i++){
            if (Lpi[i] < 0) continue;
            int state = Lpi[i];                   // initial state
            TRACE(MQ,"matchParFwd %s processing Lp[%s] state %s char %s %s\n",
                pi,i,state,this.text.charAt(start),toPrintable(this.text.charAt(start)));
            int j = start;
            for (; j < end; j++){
                int ch = this.text.charAt(j);
                int bas = this.dfa.base[state];
                int startt = bas+subclass(ch);
                state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
                TRACE(M,"matchParFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),state);
                if (state < 0) break;
            }
            if (state >= 0){      // end state reached
                TRACE(MQ,"matchParFwd %s parse %s-th successful\n",pi,i);
                // keep sequence
                parses++;
            } else {
                TRACE(MQ,"matchParFwd %s parse %s-th failed at %s\n",pi,i,j);
                #ifdef MEASURE
                this.measure.nrtrans[pi]++;   // rekon also the failed transition
                #endif
            }
            Lpi[i] = state;
            #ifdef MEASURE
            lengths[li++] = j-start+1;
            this.measure.aveStChunk[pi] += j;
            this.measure.nrtrans[pi] += j-start+1;
            #endif
        }
        #ifdef MEASURE
        this.measure.parsesSurvived[pi] += parses;
        #endif
        if (parses == 0){
            // none successful
            this.cursor = start;
            return false;
        }
        #ifdef MEASURE
        this.measure.parsesLen[pi] = Arrays.copyOf(lengths,li);
        #endif

        TRACE(M,"matchParFwd %s done\n",pi);
        #ifdef MEASURE
        this.measure.timeEndFwd[pi] = System.nanoTime();
        this.measure.aveStChunk[pi] /= (double)(end-start);
        #endif
        return true;
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the second pass over the text taking chunks from the queue until it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @param      tmpbsarr temporary array
     * @param      startdfastates start dfa states for all chunks
     */

    private void buildCleanDag(Counter cnt, int P, IntSetBit[][] L, int[] startdfastates){
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            buildCleanDag(pi,P,L,startdfastates);
        }
    }
    #endif

    /**
     * Make the second pass executing the builder on the specified chunk producing the dag.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @param      tmpbsarr temporary array
     * @param      startdfastates start dfa states for all chunks
     */

    private void buildCleanDag(int pi, int P, IntSetBit[][] L, int[] startdfastates){
        #ifdef MEASURE
        this.measure.timeStartBwd[pi] = System.nanoTime();
        #endif
        long[] tmpbsarr = new long[this.maxbs];
        IntSetBit[] Li = L[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);

        TRACE(MP,"buildCleanDag segment %s text piece %s-%s\n",pi,start,end);
        DagBuilder htb = this.dagHtb;

        // build the bitstring of each column with the reached triples,
        // and then remove the ones that do not reach the end states
        // The start states for this segment are the ones for which there
        // is a set of reached states in its L.
        // N.B. there is no cleaning in the forward pass: cleaning is needed only
        // across segments
        int ns = this.nfa.stateNr;

        IntSetBit curstates = new IntSetBit();        // build set of start states
        TRACE(MPQ,"buildCleanDag forward dfa start state %s %s\n",
            startdfastates[pi],this.dfa.table[startdfastates[pi]].nfaStates);

        int state = startdfastates[pi];
        for (int j = start; j < end; j++){
            dag[j] = state;
            TRACE(M,"buildCleanDag forward dfa state at: %s %s %s\n",
                j,state,this.dfa.table[state].nfaStates);
            int ch = this.text.charAt(j);
            int bas = this.dfa.base[state];
            int startt = bas+subclass(ch);
            state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
        }
        TRACE(M,"buildCleanDag forward dfa last state at: %s %s %s\n",
            end,state,this.dfa.table[state].nfaStates);

        // now we have a dag in which there are states that are reached by
        // the starting ones, but some of them might not reach the end ones: work
        // backwards and remove them: keep the states that reach the end ones,
        // and remove the ones that do not

        // take the bitstring of last reached states: the ones in the L of this segment
        curstates.clear();
        for (int j = 0; j < Li.length; j++){
            if (Li[j] == null) continue;
            curstates.add(Li[j]);
            #ifdef MEASURE
            this.measure.nrOpBwd[pi]++;
            #endif
        }
        IntSetBit last = curstates;
        curstates = new IntSetBit();

        TRACE(MPQ,"buildCleanDag back end states %s\n",last);

        Hstate hstate = new Hstate(128,(nfa.stateNr+63)>>>6);
        for (int j = end-1; j >= start; j--){
            int ch = this.text.charAt(j);
            int acc = j > 0 ? this.text.charAt(j-1) : BOT;
            // visit each element of the dag built so far, the nfa states and
            // remove the ones that do not reach last states
            // last: current post-reacheable
            // from: current reached (kept in dag)
            // for each state in from, take its reacheable and if they intersect with last
            // then keep it
            IntSetBit from = dfa.table[(int)this.dag[j]].nfaStates;
            int idx = hstate.search(last.arr);
            if (idx == 0){     // not found
                revtransit(last,curstates);   // reached from current post-reacheable last
                hstate.add(last.arr,curstates.arr);
            } else {
                hstate.store(idx,curstates.arr);
            }
            curstates.and(from);
            intSetToDag(curstates,j,tmpbsarr);
            TRACE(M,"  dag[%s] %s\n",j,this.dag[j]);
            TRACE(Q,"dag[%s]: res: %s\n",j,
                dagElToString(dag[j],htb));
            TRACE(M,"  at pos %s, new states %s from %s\n",j,curstates,from);
            IntSetBit tmp = last;
            last = curstates;
            curstates = tmp;
        }
        #ifdef MEASURE
        this.measure.footPrint[pi] = hstate.footPrint();
        #endif
        
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("dag piece:\n");
            showDag(0,this.dag.length,htb);
        }
        #endif
        #ifdef MEASURE
        this.measure.timeEndBwd[pi] = System.nanoTime();
        #endif
    }

    /** Already computed transitions. */

    class Hstate {

        // the elements have the following format in the table:
        //    +0  reserved  (because elements pointers are indexes in table, and 0 = null
        //    +1  hlink
        //    +2  element key, element value
        //    ..  next element

        /** The hash directory. */
        int[] hdir;

        /** The table to hold the elements. */
        long[] table;

        /** The current index in the table. */
        int tableIdx;

        /** The number of elements. */
        int elemNr;

        /** The size of elements (without hash link). */
        int elSize;

        /** The size of the key in elements. */
        int elKeySize;

        /** The last hash value computed. */
        int lastHfunct;

        /**
         * Construct an hash table with the specified directory and element size.
         *
         * @param      size director size (use a multiple of 2)
         * @param      elKeySize size of the key of elements, and also that of their value
         */

        Hstate(int dirsize, int elKeySize){
            this.hdir = new int[dirsize];
            this.table = new long[1000];
            this.tableIdx = 1;     // 0 means null
            this.elSize = elKeySize*2;
            this.elKeySize = elKeySize;
        }

        /**
         * Tell if in this hash table an element with the specified key is present.
         *
         * @param      arr key
         * @return     index of the element if present, 0 otherwise
         */

        int search(long[] arr){
            int res = 0;
            int len = this.elSize;
            long hfunct = 0;
            for (int i = 0; i < this.elKeySize; i++){
                hfunct = hfunct * 31 + (int)arr[i];
            }
            hfunct &= this.hdir.length - 1;
            this.lastHfunct = (int)hfunct;
            add: for (int z = this.hdir[(int)hfunct]; z > 0; z = (int)this.table[z]){
                for (int i = 0, j = z+1; i < this.elKeySize; i++, j++){
                    if (arr[i] != this.table[j]){    // not found
                        continue add;
                    }
                }
                TRACE(M,"search found %s\n",elemStr(z));
                return z+1+this.elKeySize;
            }
            return 0;
        }

        /**
         * Add an element with the specified key and value.
         *
         * @param      key key
         * @param      val value
         * @return     index of the added element
         */

        int add(long[] key, long[] val){
            int len = this.elSize;
            ensure(len+1);
            System.arraycopy(key,0,this.table,this.tableIdx+1,this.elKeySize);
            int el = this.tableIdx;
            this.table[el] = this.hdir[lastHfunct];  // insert at beginning
            this.hdir[lastHfunct] = el;
            System.arraycopy(val,0,this.table,this.tableIdx+1+this.elKeySize,this.elKeySize);
            this.tableIdx += len+1;
            this.elemNr++;
            return el + this.elKeySize + 1;
        }

        /**
         * Store the specified value of an element in the specified array.
         *
         * @param      idx index of the value in the table
         * @param      val return array
         */

        void store(int idx, long[] val){
            System.arraycopy(this.table,idx,val,0,this.elKeySize);
        }

        /**
         * Ensure that the table is wide enough to contain an element with a value
         * with the specified length.
         *
         * @param      len length of the value
         */

        void ensure(int len){
            if (this.table.length - this.tableIdx < len){
                long newlen = this.table.length << 1;
                if (this.tableIdx + len >= newlen) newlen = this.tableIdx + len;
                if (newlen > Integer.MAX_VALUE){
                    System.out.printf("hash table overflow\n");
                }
                this.table = Arrays.copyOf(this.table,(int)newlen);
            }
        }

        /**
         * Trace this hash table.
         */

        void trace(){
            int len = this.hdir.length;
            for (int row = 0; row < len; row++){  // scan all chains
                for (int el = this.hdir[row]; el != 0; el = (int)this.table[el]){ // scan the chain
                    Trc.out.printf("(el %s: o %s): %s\n",
                        el,this.table[el],
                        Arrays.toString(Arrays.copyOfRange(
                            this.table,el+1,el+1+this.elKeySize)));
                }
            }
            Trc.out.printf("hdir %s\n",Arrays.toString(this.hdir));
            Trc.out.printf("table %s\n",Arrays.toString(Arrays.copyOf(this.table,this.tableIdx)));
        }

        /**
         * Deliver a string representing the specified element.
         *
         * @param      el index of the element
         * @return     string
         */

        String elemStr(int el){
            int idx = el+1;
            int len = this.elKeySize;
            String str = String.format("el %s: o %s [",el,idx);
            for (int i = 0; i < len; i++){
                str += " " + this.table[idx+i];
            }
            return str + "]";
        }

        /**
         * Deliver the footprint as nr of bytes of this table.
         *
         * @return     footprint
         */

        int footPrint(){
            return this.hdir.length*4 + 4 + this.table.length*8 + 4;
        }
    }
    #endif

    /**
     * Trace the L vectors.
     *
     * @param      L L vectors
     */

    void traceL(int[][] L){
        for (int k = 0; k < L.length; k++){
            int start = startChunk(k,L.length);
            int end = endChunk(k,L.length);
            if (L[k] == null) continue;
            Trc.out.printf("  segment %s: %s-%s\n",k,start,end);
            for (int i = 0; i < L[k].length; i++){
                if (L[k][i] < 0) continue;
                Trc.out.printf("  state %s: reaches L[%s][%s]: %s %s\n",
                    i,k,i,this.dfa.table[L[k][i]].number,this.dfa.table[L[k][i]].nfaStates);
            }
        }
    }

    #ifdef BUILDER_REVDFA
    /**
     * Parse the text using the parallel algorithm.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: default 2, < 0 recognizion with -nrproc threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    /* The start and end states are as follows (e.g. for 2 chunks):
     *
     *       chunk 0        chunk 1
     *
     *      |     a      |   |     b      c      |    text
     *      |  0 ---> 1  |   |  1 ---> 2 ---> 3  |    forward scan
     *      | {4}    {1} |   | {2}    {2}    {3} |    nfa states
     *      |            |   |                   |
     *      |  3 <--- 2  |   |  2 <--- 1 <--- 0  |    backwards scan
     *      | {4}    {1} |   | {2}    {2}    {3} |    nfa states
     *
     *            0                1               3  fwdstates
     *            2                0               0  bwdstates
     *
     * If we take instead only the multi-entry dfa states, we start each chunk with
     * all such states, in L and R indexes that are the nfa states.
     * This means that we compute for each nfa state N the dfa state D reached at the end
     * of the chunk, representing a set ND of nfa states.
     * When sewing, we start with chunk 0, and make the union U_0 of all its ND's of
     * the nfa start states (which are the reached nfa states of the chunk).
     * Note that U is represented by a dfa state.
     * Then we move to the next chunk, and make the union U_1 of all its ND's of U_0,
     * and do it for all chunks.
     * Likewise, we do a similar thing for the reverse dfa.
     * Eventually, we compute the start dfa and end revdfa states for each chunk much
     * the same as if we used instead all the dfa states.
     *
     * More precisely:
     *
     *    1. build the vectors L, one for each chunk, i-th element, where i is a NFA
     *       state, contains the corresponding ME-FA state.
     *       Build the vectors R, same as L, but using the reverse ME-FA
     *    2. execute the reachers, one for each chunk that takes its L vector and makes
     *       a run for each of its elements (using the ME-FA), storing the reached
     *       states in L (i.e. ending havong replaced the start states with the states
     *       reached at the end of the chunk).
     *       Reachers do the same backwards using the R vectors and the reverse ME-FA.
     *    3. sew: process the L vectors in sequence: take vector L[0] and take for each
     *       element (a ME-FA state) the NFA states that it represent. Make the union of
     *       all such NFA states, and find the ME-FA states that represents such a union.
     *       Store it as the reached ME-FA state of the chunk.
     *       Then take L[1] and in it take the elements whose indexes are the NFA states
     *       just computed for L[0], and do the same, ending in the reached ME-FA state
     *       for chunk 1. Do the same for the other chunks, and also for the R vectors.
     *       This ends up with a sequence of ME-FA states, one for each chunk, the
     *       end state of that chunk, and another sequence of reverse ME-FA states, the
     *       start state of it.
     *
     *            L[i]                             L[i+1]
     *            NFA ME-FA                        NFA ME-FA
     *            1:   m1    {nx,ny...}            1:  m1    {nx,ny...} 
     *            2:   m2    {ni,nk...}   .------->2:  m2    {ni,nk...}
     *            ..                      |
     *            n:   mn    {nj,nl...}   |  .---->n:  mn    {nj,nl...}
     *                       ----------   |  |               ----------
     *                       union:     {na,nb...}           union {...}
     *                          v                              v
     *                       forward ME-FA state             forward ME-FA state
     *              
     *    4. execute the builders, one for each chunk that takes its start ME-FA state
     *       and makes a run on the chunk recording the visited ME-FA states, and
     *       makes a reverse run starting from its reverse ME-FA state, and for each
     *       chunk element (column) intersecting the NFA states that the ME-FA state
     *       of that column represents with the ones that the reverse ME-FA states
     *       (of the same column represents), and store it as the DAG of that column.
     *    N.B. here the ME-FA is a superset of the DFA: it is the DFA augmented with the
     *       singleton states for the NFA states, and the reverse ME-FA likwise.
     *       This avoids to keep both a ME-FA and a DFA (and likewise for the reverse one).
     */

    boolean matchPar(String text, int nrproc){
        return matchPar(text,nrproc,false);
    }
    boolean matchPar(String text, int nrproc, boolean rec){
        TRACE(MPQ,"matchPar %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            this.traceAstMap();
            Trc.out.printf("matchPar nfa\n");
            this.nfa.trace();
            Trc.out.printf("triples starting\n");
            for (int j = 0; j < this.tripleStartingNr; j++){
                Trc.out.printf("    %s: %s\n",j,Arrays.toString(this.tripleStarting[j]));
            }
            Trc.out.printf("matchPar me-dfa\n");
            this.dfa.trace();
            Trc.out.printf("matchPar revdfa\n");
            this.revdfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();
        
        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks

        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = rec;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = rec;
        DagBuilder htb = new DagBuilder(64,"m");
        htb.synch = true;
        this.dagHtb = htb;
        #ifdef MEASURE
        this.measure.htb = htb;
        #endif
        long[] tmpbsarr = new long[this.maxbs];
        IntSetBit tmpset = new IntSetBit();
        if (this.text.length() == 0){                     // special case for the empty string
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    tmpset.add(nstate);
                    res = true;
                }
            ENDFOR_IS();
            if (res && !rec){
                this.dag = new long[1];
                htb.dag = this.dag;
                intSetToDag(tmpset,0,tmpbsarr);
                #ifdef DEBUG
                if (((FL_P|FL_Q) & this.trc) != 0){
                    Trc.out.printf("matchSeq dag: %s\n",dagToString());
                    traceDag();
                }
                #endif
            }
            return res;
        }

        TRACE(MPQ,"matchPar ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start indexes of chunks
        this.startChunk = new int[nrChunks];
        TRACE(Q,"matchPar nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = seekGoodPoint(start,chunk);
                if (this.startChunk[i] <= this.startChunk[i-1]){   // avoid overlap
                    this.startChunk[i] = this.startChunk[i-1]+1;
                }
            }
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
        }

        // here take the dfa start states, all if ALL_STARTSTATES or only the
        // multi-entry ones. Note that in the latter case the L and R vectors
        // contain dfa states in the elements having as indexes the nfa states

        // use -1 to tell that there are no states
        // determine the forward start states of all the chunks
        int[][] L = new int[nrChunks][];                  // current forward states
        for (int i = 0; i < nrChunks; i++){
            #ifdef ALL_STARTSTATES
            L[i] = new int[this.dfa.strictStateNr];
            Arrays.fill(L[i],-1);
            int n = 0;
            if (i == 0){          // first chunk
                L[i][0] = 0;
                n = 1;
            } else {
                for (int k = 0; k < L[i].length; k++){
                    L[i][k] = k;
                }
                n = L[i].length;
            }
            #else
            L[i] = new int[this.nfa.stateNr];
            Arrays.fill(L[i],-1);
            int n = 0;
            if (i == 0){          // first chunk, use only the real start states
                FOREACH_IS(this.dfa.table[0].nfaStates);
                    L[i][nstate] = this.dfa.startStates[nstate];
                    n++;
                ENDFOR_IS();
            } else {
                for (int j = 0; j < this.nfa.stateNr; j++){
                    L[i][j] = this.dfa.startStates[j];
                    if (L[i][j] >= 0) n++;
                }
            }
            #endif
            #ifdef MEASURE
            this.measure.chunkStart[i] = n;
            #endif
        }
        // determine the backwards start states of all the chunks
        int[][] R = new int[nrChunks][];                  // current backwards states
        if (!rec){
            for (int i = 0; i < nrChunks; i++){
                #ifdef ALL_STARTSTATES
                R[i] = new int[this.revdfa.strictStateNr];
                Arrays.fill(R[i],-1);
                if (i == nrChunks-1){          // last chunk
                    R[i][0] = 0;
                } else {
                    for (int k = 0; k < R[i].length; k++){
                        R[i][k] = k;
                    }
                }
                #else
                R[i] = new int[this.revdfa.stateNr];
                Arrays.fill(R[i],-1);
                if (i == nrChunks-1){          // last chunk
                    FOREACH_IS(this.revdfa.table[0].nfaStates);
                        R[i][nstate] = this.revdfa.startStates[nstate];
                    ENDFOR_IS();
                } else {
                    for (int j = 0; j < this.nfa.stateNr; j++){
                        R[i][j] = this.revdfa.startStates[j];
                    }
                }
                #endif
            }
        }

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward start states:\n");
            traceL(L);
            Trc.out.printf("backwards start states:\n");
            traceR(R);
        }
        #endif

        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif
        if (nrproc == 1 && testing || simulate){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!matchParFwd(i,nrChunks,L,R,rec)){
                    TRACE(M,"matchPar failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            if (simulate){
                this.measure.nrThreads = P;
            } else {
                this.measure.nrThreads = 1;
            }
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return matchParFwd(cnt,nrChunks,L,R,rec);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return matchParFwd(cnt.get(),nrChunks,L,parses,rec);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"matchPar failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached forward states by chunk:\n");
            traceL(L);
            Trc.out.printf("reached backwards states by chunk:\n");
            traceR(R);
        }
        #endif

        TRACE(MPQ,"matchPar ---- sewing\n");

        // here we have array L: one vector, for each segment;
        // each element of the vector is a state:
        // the element i-th contains the state reached by the state i-th,
        // a start state for the segment.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L vector contains the state reached by transitions done with
        // the last character of the segment.

        res = true;
        int[] fwdstates = new int[nrChunks+1];
        #ifdef ALL_STARTSTATES
        int Ltemp = 0;
        TRACE(M,"matchPar initial fwd %s\n",Ltemp);
        for (int k = 0; k < nrChunks; k++){
            fwdstates[k] = Ltemp;
            TRACE(M,"matchPar segm %s Ltemp %s\n",k,Ltemp);
            Ltemp = L[k][Ltemp];
            if (Ltemp < 0){
                res = false;
                break;
            }
        }
        fwdstates[nrChunks] = Ltemp;
        if (!this.dfa.table[Ltemp].accepting){
            res = false;
        }
        #else
        IntSetBit Ltemp = transit(0,BOT);          // initial

        TRACE(M,"matchPar initial fwd %s\n",Ltemp);
        Dfa.State newst = this.dfa.new State();
        for (int k = 0; k < nrChunks; k++){
            int[] Lk = L[k];
            TRACE(M,"matchPar segm %s Ltemp %s\n",k,Ltemp);
            IntSetBit next = new IntSetBit();
            FOREACH_IS(Ltemp);
                // get the ones reached by it
                if (Lk[nstate] >= 0){
                    next.add(this.dfa.table[Lk[nstate]].nfaStates);
                }
            ENDFOR_IS();
            // here Ltemp is a dfa state
            newst.nfaStates = Ltemp;
            fwdstates[k] = this.dfa.search(newst).number;
            TRACE(M,"matchPar start dfa state for chunk %s: %s\n",k,fwdstates[k]);
            Ltemp = next;     // then use the reached states as the current set
            TRACE(M,"matchPar sew forward segment %s reaches %s\n",k,next);
            if (Ltemp.isEmpty()){
                this.cursor = endChunk(k,nrChunks)-1;
                res = false;
                break;
            }
        }
        newst.nfaStates = Ltemp;
        fwdstates[nrChunks] = this.dfa.search(newst).number;

        if (res){
            res = false;
            // Ltemp here contains the states reached by the last segment,
            // check that it contains at least an accepting state
            FOREACH_IS(Ltemp);
                TRACE(M,"matchPar --- %s\n",nstate);
                if (this.nfa.table[nstate].accepting){
                    res = true;
                    break;
                }
            ENDFOR_IS();
        }

        #endif
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward start states by chunk:\n");
            for (int i = 0; i < fwdstates.length; i++){
                Trc.out.printf("  %s: %s dfa %s %s\n",
                    i,chunkToString(i,nrChunks),fwdstates[i],
                    this.dfa.table[fwdstates[i]].nfaStates);
            }
        }
        #endif

        if (rec){      // recognizion
            TRACE(M,"matchPar recognize %s\n",res);
            return res;
        }

        int[] bwdstates = new int[nrChunks+1];
        #ifdef ALL_STARTSTATES
        int Rtemp = 0;
        bwdstates[nrChunks] = Rtemp;
        TRACE(M,"matchPar initial bwd %s\n",Rtemp);
        for (int k = nrChunks-1; k >= 0; k--){
            bwdstates[k] = Rtemp;
            Rtemp = R[k][Rtemp];
            if (Rtemp < 0){
                res = false;
                break;
            }
            TRACE(M,"matchPar segm %s Rtemp %s\n",k,Rtemp);
        }
        #else
        IntSetBit Rtemp = this.revdfa.table[0].nfaStates;          // initial
        bwdstates[nrChunks] = 0;
        TRACE(M,"matchPar initial bwd %s\n",Rtemp);
        for (int k = nrChunks-1; k >= 0; k--){
            int[] Rk = R[k];
            TRACE(M,"matchPar segm %s Rtemp %s\n",k,Rtemp);
            IntSetBit next = new IntSetBit();
            FOREACH_IS(Rtemp);
                // get the ones reached by it
                if (Rk[nstate] >= 0){
                    next.add(this.revdfa.table[Rk[nstate]].nfaStates);
                }
            ENDFOR_IS();
            // here Rtemp is a dfa state
            newst.nfaStates = Rtemp;
            bwdstates[k] = this.revdfa.search(newst).number;
            TRACE(M,"matchPar start revdfa state for chunk %s: %s\n",k,bwdstates[k]);

            Rtemp = next;     // then use the reached states as the current set
            TRACE(M,"matchPar sew backwards segment %s reaches %s\n",k,next);
            if (Rtemp.isEmpty()){
                this.cursor = endChunk(k,nrChunks)-1;
                res = false;
                break;
            }
        }
        #endif
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("backwards start states by chunk:\n");
            for (int i = 0; i < bwdstates.length; i++){
                Trc.out.printf("  %s: %s revdfa %s %s\n",
                    i,chunkToString(i,nrChunks),bwdstates[i],
                    this.revdfa.table[bwdstates[i]].nfaStates);
            }
        }
        #endif

        TRACE(M,"matchPar ---- end sewing, accepted %s\n",res);
        if (!res){
            TRACE(M,"matchPar res %s\n",res);
            return res;
        }

        this.dag = new long[this.text.length()+1];
        htb.dag = this.dag;
        TRACE(MQ,"matchPar last dag column ");
        // last column of dag
        IntSetBit curstates = new IntSetBit();
        curstates.assign(this.dfa.table[fwdstates[fwdstates.length-1]].nfaStates);
        curstates.and(this.revdfa.table[bwdstates[bwdstates.length-1]].nfaStates);
        TRACE(P,"matchPar last dag column %s",curstates);
        intSetToDag(curstates,this.dag.length-1,tmpbsarr);
        TRACE(M,"matchPar dag[%s] finals %s\n",this.dag.length-1,
            dagElemToString(this.dag,this.dag.length-1,0,htb));
        TRACE(Q,"last dag[%s]: %s\n",this.dag.length-1,
            dagElToString(this.dag[this.dag.length-1],htb));

        // clean each segment: build a sequence of bitstrings, one for
        // each string position, with bits telling what triples out of
        // tripleStarting are part of an accepting path
        TRACE(MPQ,"matchPar ------- build dag\n");

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        if (nrproc == 1 && testing || simulate){
            for (int i = 0; i < nrChunks; i++){
                buildCleanDag(i,nrChunks,fwdstates,bwdstates);
            }
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt1 = new Counter(nrChunks);
            Callable<Boolean> clean = () -> {
                buildCleanDag(cnt1,nrChunks,fwdstates,bwdstates);
                return true;
            };
            #else
            final Counter cnt1 = new Counter();
            Callable<Boolean> clean = () -> {
                buildCleanDag(cnt1.get(),nrChunks,fwdstates,bwdstates);
                return true;
            };
            #endif
            parallelExec(P,clean);
        }
        #ifdef DEBUG
        if (((FL_M|FL_P|FL_Q) & this.trc) != 0){
            Trc.out.printf("before --------------------dag:\n");
            showDag(this.dag);
        }
        #endif
        #ifdef MEASURE
        this.measure.timePar[5] = System.nanoTime();
        #endif


        TRACE(M,"matchPar res %s\n",res);
        #ifdef MEASURE
        this.measure.timePar[6] = System.nanoTime();
        this.measure.dagStatis();
        #endif
        return res;
    }

    static boolean simulate;
    boolean matchParSim(String text, int nrproc){
        this.simulate = true;
        boolean res = matchPar(text,nrproc,false);
        this.simulate = false;
        return res;
    }

    /**
     * Deliver a string representing the start and end indexes of the specified chunk.
     *
     * @param      k number of the chunk
     * @param      nr number of chunks
     * @return     string
     */

    String chunkToString(int k, int nr){
        if (k >= nr) return "" + this.text.length();
        int start = startChunk(k,nr);
        int end = endChunk(k,nr);
        return start + "-" + end;
    }

    /**
     * Trace the R vectors.
     *
     * @param      R R vectors
     */

    void traceR(int[][] R){
        if (R == null) return;
        for (int k = 0; k < R.length; k++){
            int start = startChunk(k,R.length);
            int end = endChunk(k,R.length);
            if (R[k] == null) continue;
            Trc.out.printf("  segment %s: %s-%s\n",k,start,end);
            for (int i = 0; i < R[k].length; i++){
                if (R[k][i] < 0) continue;
                Trc.out.printf("  state %s: reaches R[%s][%s]: %s %s\n",
                    i,k,i,this.revdfa.table[R[k][i]].number,this.revdfa.table[R[k][i]].nfaStates);
            }
        }
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the forward and backwards passes over the text taking chunks from the queue until
     * it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @param      R R vectors
     * @param      rec <code>true</code> for recognizion only, <code>false</code> otherwise
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean matchParFwd(Counter cnt, int P, int[][] L, int[][] R, boolean rec){
        TRACE(Q,"matchParFwd\n");
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            if (!matchParFwd(pi,P,L,R,rec)) return false;
        }
        return true;
    }
    #endif

    /**
     * Make the forward and backwards passes over the text executing the reader on the
     * specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @param      R R vectors
     * @param      rec <code>true</code> for recognizion only, <code>false</code> otherwise
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean matchParFwd(int pi, int P, int[][] L, int[][] R, boolean rec){
        TRACE(MQ,"matchParFwd segment %s\n",pi);
        #ifdef MEASURE
        this.measure.timeStartFwd[pi] = System.nanoTime();
        #endif

        int[] Lpi = L[pi];
        int[] Rpi = R[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);
        #ifdef MEASURE
        this.measure.sizeChunk[pi] = end-start;
        #endif

        // The starting vector contains the dfa states to start the matching.

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            for (int i = 0; i < Lpi.length; i++){
                if (Lpi[i] < 0) continue;
                TRACE(M,"  start states %s: Lpi[%s] %s\n",i,i,Lpi[i]);
            }
            if (!rec){
                for (int i = 0; i < Rpi.length; i++){
                    if (Rpi[i] < 0) continue;
                    TRACE(M,"  end states %s: Rpi[%s] %s\n",i,i,Rpi[i]);
                }
            }
        }
        #endif

        TRACE(M,"matchParFwd text piece %s-%s\n",start,end);

        TRACE(M,"matchParFwd forward scan\n");
        #ifdef MEASURE
        int[] lengths = new int[Lpi.length];
        int li = 0;
        #endif
        int parses = 0;
        for (int i = 0; i < Lpi.length; i++){
            if (Lpi[i] < 0) continue;
            int state = Lpi[i];                   // initial state
            TRACE(MQ,"matchParFwd %s processing Lp[%s] state %s char %s %s\n",
                pi,i,state,this.text.charAt(start),toPrintable(this.text.charAt(start)));
            int j = start;
            for (; j < end; j++){
                int ch = this.text.charAt(j);
                int bas = this.dfa.base[state];
                int startt = bas+subclass(ch);
                state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
                TRACE(M,"matchParFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),state);
                if (state < 0) break;
            }
            if (state >= 0){      // end state reached
                TRACE(MQ,"matchParFwd %s parse %s-th successful\n",pi,i);
                // keep sequence
                parses++;
            } else {
                TRACE(MQ,"matchParFwd %s parse %s-th failed at %s\n",pi,i,j);
                #ifdef MEASURE
                this.measure.nrtrans[pi]++;   // rekon also the failed transition
                #endif
            }
            Lpi[i] = state;
            #ifdef MEASURE
            lengths[li++] = j-start+1;
            this.measure.aveStChunk[pi] += j;
            this.measure.nrtrans[pi] += j-start+1;
            #endif
        }
        #ifdef MEASURE
        this.measure.parsesSurvived[pi] += parses;
        #endif
        if (parses == 0){
            // none successful
            this.cursor = start;
            return false;
        }
        #ifdef MEASURE
        this.measure.parsesLen[pi] = Arrays.copyOf(lengths,li);
        #endif

        if (rec) return true;
        
        TRACE(M,"matchParFwd backwards scan\n");
        for (int i = 0; i < Rpi.length; i++){
            if (Rpi[i] < 0) continue;
            int state = Rpi[i];                   // initial state
            TRACE(MQ,"matchParFwd %s processing Rp[%s] state %s char %s %s\n",
                pi,i,state,this.text.charAt(start),toPrintable(this.text.charAt(start)));
            int j = end-1;
            for (; j >= start; j--){
                int ch = this.text.charAt(j);
                int bas = this.revdfa.base[state];
                int startt = bas+subclass(ch);
                state = this.revdfa.check[startt] == bas ? this.revdfa.trtable[startt] : -1;
                TRACE(M,"matchParFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),state);
                if (state < 0) break;
            }
            if (state >= 0){      // end state reached
                TRACE(MQ,"matchParFwd %s parse %s-th successful\n",pi,i);
                // keep sequence
                parses++;
            } else {
                TRACE(MQ,"matchParFwd %s parse %s-th failed at %s\n",pi,i,j);
                #ifdef MEASURE
                this.measure.nrtrans[pi]++;   // rekon also the failed transition
                #endif
            }
            #ifdef MEASURE
            this.measure.nrtrans[pi] += j-start+1;
            #endif
            Rpi[i] = state;
        }

        TRACE(M,"matchParFwd %s done\n",pi);
        #ifdef MEASURE
        this.measure.timeEndFwd[pi] = System.nanoTime();
        this.measure.aveStChunk[pi] /= (double)(end-start);
        #endif
        return true;
    }

    #ifdef LOAD_BALANCE
    /**
     * Execute the builders taking chunks from the queue until it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      fwdstates forward start states for all chunks
     * @param      bwdstates backwards start states for all chunks
     */

    private void buildCleanDag(Counter cnt, int P, int[] fwdstates, int[] bwdstates){
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            buildCleanDag(pi,P,fwdstates,bwdstates);
        }
    }
    #endif

    /**
     * Execute the builder on the specified chunk with the specified start states.
     *
     * @param      pi number of chunk
     * @param      P number of chunks
     * @param      fwdstates forward start states for all chunks
     * @param      bwdstates backwards start states for all chunks
     */

    private void buildCleanDag(int pi, int P, int[] fwdstates, int[] bwdstates){
        #ifdef MEASURE
        this.measure.timeStartBwd[pi] = System.nanoTime();
        #endif

        int start = startChunk(pi,P);
        int end = endChunk(pi,P);

        TRACE(MP,"buildCleanDag segment %s text piece %s-%s\n",pi,start,end);
        DagBuilder htb = this.dagHtb;

        // build the bitstring of each column with the reached triples,
        // obtained by intersecting the forward and backward states
        // Make a forward pass recording the forward dfa states.
        int ns = this.nfa.stateNr;

        TRACE(MPQ,"buildCleanDag forward dfa start state %s %s\n",
            fwdstates[pi],this.dfa.table[fwdstates[pi]].nfaStates);

        int state = fwdstates[pi];
        for (int j = start; j < end; j++){
            dag[j] = state;
            TRACE(M,"buildCleanDag forward dfa state at: %s %s %s\n",
                j,state,this.dfa.table[state].nfaStates);
            int ch = this.text.charAt(j);
            int bas = this.dfa.base[state];
            int startt = bas+subclass(ch);
            state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
        }
        TRACE(M,"buildCleanDag forward dfa last state at: %s %s %s\n",
            end,state,this.dfa.table[state].nfaStates);
        #ifdef MEASURE
        this.measure.nrtrans[pi] += end-start;
        #endif

        // Make a backward pass intersecting the forward and backwards states

        long[] tmpbsarr = new long[this.maxbs];
        IntSetBit curstates = new IntSetBit();        // build set of start states
        state = bwdstates[pi];
        for (int j = end-1; j >= start; j--){
            int ch = this.text.charAt(j);
            int bas = this.revdfa.base[state];
            int startt = bas+subclass(ch);
            state = this.revdfa.check[startt] == bas ? this.revdfa.trtable[startt] : -1;
            TRACE(M,"buildCleanDag at: %s forward dfa state %s %s backward dfa state %s %s\n",
                j,(int)dag[j],this.dfa.table[(int)dag[j]].nfaStates,
                state,this.revdfa.table[state].nfaStates);
            curstates.assign(this.dfa.table[(int)dag[j]].nfaStates);
            curstates.and(this.revdfa.table[state].nfaStates);
            intSetToDag(curstates,j,tmpbsarr);
            TRACE(M,"buildCleanDag1 dag[%s] %s\n",j,
                dagElemToString(this.dag,j,0,htb));
            TRACE(Q,"dag[%s]: %s\n",j,
                dagElToString(this.dag[j],htb));
        }
        #ifdef MEASURE
        this.measure.nrtrans[pi] += end-start;
        #endif
        
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("dag piece:\n");
            showDag(0,this.dag.length,htb);
        }
        #endif
        #ifdef MEASURE
        this.measure.timeEndBwd[pi] = System.nanoTime();
        #endif
    }
    #endif


    //------- The DAG ----

    /* The dag:
     *
     * text       a         b        c      -|
     *         |        |        |        |         |
     * dag     |<|-,,a> | <a,,b> | <b,,c> | <c,,-|> |
     *         |<|-,,a> | <a,,b> | <b,,c> | <c,,-|> |
     *
     * In each column, the dag has a set of triples, that is a subset of the whole
     * tripleStarting (for that column), represented as a vector of bits telling whether
     * each element in the set is present or absent.
     * N.B. all the triples in a column have the same unmarked first symbol and the
     * same unmarked third one.
     * The triples that are present in a column are a subset of the ones that start
     * with the same unmarked symbol, which is the one of the text of the previous colum.
     * See, e.g. the column above for "b", which contains triples that start with "a".
     * Each column contains a short, the tells the set of the triples present in it.
     * A triple T with ending symbol E it is linked to all triples with their starting symbol
     * equal to E. Such triples lie in the next column.
     * This is similar to the nfa, apart from representing the triples with their indexes in
     * tripleStarting tables.
     *
     * Note that if most of the triplestarting vectors are longer than 64, then almost all
     * the dag elements are in the hash. This means that with complex REs this representation
     * might make parsing slow, but I do not see what other one can be used.
     *
     * This is similar to the threading of states of the ReTdfa, but done in a different
     * way, and it is done only when a dfa is used. ReTdfa uses a dfa, and keeps the links
     * between configurations inside each dfa state. Here, that information is kept in the nfa.
     */

    /** The dag. */
    long[] dag;

    /** The hash table for overly long dag elements. */
    DagBuilder dagHtb;

    /** The hash tables for large sets of triples. */
    
    // It rehashes the table when it becomes cluttered, otherwise it becomes slow.
    
    class DagBuilder {

        // the elements are kept in the table:
        //    +0  reserved  (because elements pointers are indexes in table, and 0 = null
        //    +1  hlink
        //    +2  length
        //    +3  element data, length values
        //    ..  next element

        /** The name of the table (for tracing).*/
        String name;

        /** The hash directory.*/
        int[] hdir;

        /** The table to hold the elements.*/
        long[] table;

        /** The current index in the table.*/
        int tableIdx;

        /** The number of elements.*/
        int elemNr;

        /** The number of add's done.*/
        int nrAdd;

        /** The number of addUnique's done.*/
        int nrAddUni;

        /** The fill treshold.*/
        int threshold;

        /** The load factor.*/
        float loadFactor = 2f;

        /** Whether the accesses must be synchronized. */
        private boolean synch = true;

        /** The reference to the dag.*/
        long[] dag;
        
        /**
         * Construct an hash table with the specified directory size and name.
         *
         * @param      size director size (use a multiple of 2)
         * @param      name name of the table
         * @return     hash table
         */
        
        DagBuilder(int size, String name){
            this.name = name;
            this.hdir = new int[size];
            this.table = new long[1000];
            this.tableIdx = 1;     // 0 means null
            this.threshold = (int)(size * this.loadFactor);
        }
        
        /**
         * Deliver the number of elements in this table.
         *
         * @return     number of elements
         */
        
        int size(){
            return this.elemNr;
        }

        /**
         * Add an element with the specified value if not already present.
         *
         * @param      arr value
         * @param      len length of the value
         * @return     index of the element
         */
        
        int addUnique(long[] arr, int len){
            if (this.synch){
                return addUniqueSynch(arr,len);
            }
            return addUniqueUnsynch(arr,len);
        }
        synchronized int addUniqueSynch(long[] arr, int len){
            return addUniqueUnsynch(arr,len);
        }
        int addUniqueUnsynch(long[] arr, int len){
            this.nrAdd++;
            TRACE(M,"addUnique arr %s len %s\n",dagHex(Arrays.copyOf(arr,len)),len);
            int res = 0;
            addu: {
                // search
                int hfunct = 0;
                for (int i = 0; i < len; i++){
                    hfunct = hfunct * 31 + (int)arr[i];
                }
                hfunct &= this.hdir.length - 1;
                add: for (int z = this.hdir[hfunct]; z > 0; z = (int)this.table[z]){
                    if (this.table[z+1] != len) continue;
                    for (int i = 0, j = z+2; i < len; i++, j++){
                        if (arr[i] != this.table[j]){    // not found
                            break add;
                        }
                    }
                    res = z;
                    TRACE(M,"addUnique found %s\n",elemStr(z));
                    break addu;
                }

                if (this.elemNr > this.threshold){         // directory too crowded
                    rehash();
                }

                // not found, add
                ensure(len+2);
                this.table[this.tableIdx+1] = len;
                System.arraycopy(arr,0,this.table,this.tableIdx+2,len);
                int el = this.tableIdx;
                this.table[el] = this.hdir[hfunct];  // insert at beginning
                this.hdir[hfunct] = el;
                this.tableIdx += len+2;
                this.elemNr++;
                TRACE(M,"addUnique added %s\n",elemStr(res));
                res = el;
                this.nrAddUni++;
            }
            #ifdef BS_SHORT
            if ((res & ~INLINE_MASK_BS) != 0){
                System.out.printf("hash table overflow %x %x\n",res,INLINE_MASK_BS);
                new Throwable().printStackTrace(Trc.out);
                System.exit(1);
            }
            #endif
            return res;
        }

        /**
         * Ensure that the table is wide enough to contain an element with a value
         * with the specified length.
         *
         * @param      len length of the value
         */

        void ensure(int len){
            if (this.table.length - this.tableIdx < len){
                long newlen = this.table.length << 1;
                if (this.tableIdx + len >= newlen) newlen = this.tableIdx + len;
                if (newlen > Integer.MAX_VALUE){
                    System.out.printf("hash table overflow\n");
                }
                this.table = Arrays.copyOf(this.table,(int)newlen);
            }
        }

        /**
         * Trace this hash table.
         */

        void trace(){
            int len = this.hdir.length;
            for (int row = 0; row < len; row++){  // scan all chains
                for (int el = this.hdir[row]; el != 0; el = (int)this.table[el]){ // scan the chain
                    Trc.out.printf("(el %s: o %s l %s): %s\n",
                        el,this.table[el],this.table[el+1],
                        Arrays.toString(Arrays.copyOfRange(
                            this.table,el+2,el+(int)this.table[el+1])));
                }
            }
            Trc.out.printf("hdir %s\n",Arrays.toString(this.hdir));
            Trc.out.printf("table %s\n",Arrays.toString(Arrays.copyOf(this.table,this.tableIdx)));
        }

        /**
         * Deliver a string representing the specified element.
         *
         * @param      el index of the element
         * @return     string
         */

        String elemStr(int el){
            int idx = el+2;
            int len = (int)this.table[el+1];
            String str = String.format("el %s: o %s l %s [",el,idx,len);
            for (int i = 0; i < len; i++){
                str += " " + this.table[idx+i];
            }
            return str + "]";
        }

        /**
         * Rehash this hash table.
         */

        void rehash(){
            int newHdirLen = this.hdir.length << 1;
            if (newHdirLen < 0){
                System.out.printf("hash table overflow\n");
                new Throwable().printStackTrace(Trc.out);
                System.exit(1);
            }
            int[] old = this.hdir;
            this.hdir = new int[newHdirLen];

            // scan elements
            for (int row = 0; row < old.length; row++){  // scan all chains
                for (int el = this.hdir[row]; el != 0; el = (int)this.table[el]){ // scan the chain
                    int idx = el+2;
                    int len = (int)this.table[el+1];
                    int hfunct = 0;
                    for (int j = 0; j < len; j++){
                        hfunct = hfunct * 31 + (int)this.table[idx+j];
                    }
                    hfunct &= newHdirLen;
                    this.table[el] = this.hdir[hfunct];  // insert at beginning
                    this.hdir[hfunct] = el;
                }
            }
            this.threshold = (int)(newHdirLen * this.loadFactor);
        }

        /**
         * Deliver the footprint as nr of bytes of this table.
         *
         * @return     footprint
         */

        int footPrint(){
            return this.hdir.length*4 + 4 + this.table.length*8 + 4;
        }
    }

    /**
     * Add a new dag element at the specifed column for the specified set of triples.
     *
     * @param      set set of triples
     * @param      j dag column
     * @param      over <code>true</code> if the element must be intersected with the one
     *             in the dag (at the same position), <code>false</code> otherwise
     * @param      arr temporary reusable array
     */

    void intSetToDag(IntSetBit set, int j, long[] arr){
        TRACE(MP,"intSetToDag %s %s\n",set,j);
        long[] trset = null;
        int acc = j > 0 ? text.charAt(j-1) : BOT;
        long res = 0;
        int sn = startSet(acc);
        int[] starting = this.tripleStarting[sn];
        int len = starting.length;
        TRACE(M,"intSetToDag starting %s %s len %s\n",
            sn,Arrays.toString(starting),len);
        int ln = 0;

        // compute the set, in the representation of the triplestarting
        if (len > INLINE_BS){
            ln = (len + SIZE_BS - 1) / SIZE_BS;
            for (int z = 0; z < ln; z++){
                arr[z] = 0;
            }
            FOREACH_IS(set);
                // seek the triple of the state nr in tripleStarting
                int bas = this.base[nstate];
                int start = bas+sn;
                int idx = this.check[start] == bas ? this.tstable[start] : -1;
                TRACE(M,"intSetToDag triple %s in starting %s len %s inline %s\n",
                    nstate,idx,len,INLINE_BS);
                arr[idx>>>SHIFTS_BS] |= BS_BIT(idx);
            ENDFOR_IS();
            // put in hash table
            res = (long)(this.dagHtb.addUnique(arr,ln) | HIGH_BS);
        } else {
            FOREACH_IS(set);
                // seek the triple of the state nr in tripleStarting
                int bas = this.base[nstate];
                int start = bas+sn;
                int idx = this.check[start] == bas ? this.tstable[start] : -1;
                TRACE(M,"intSetToDag triple %s in starting %s len %s inline %s\n",
                    nstate,idx,len,INLINE_BS);
                res |= BS_B(idx);
            ENDFOR_IS();
        }

        this.dagHtb.dag[j] = res;
        #ifdef DEBUG
        if ((FL_P & this.trc) != 0){
            showDag(j,j+1,this.dagHtb);
        }
        #endif
    }

    /**
     * Tell if the specified element is present in the specified dag element.
     *
     * @param      elem dag element
     * @param      bit element
     * @param      d dag hash table
     * @return     <code>true</code> if it is, <code>false</code> otherwise
     */

    boolean getDag(long elem, int bit, DagBuilder d){
        if (elem > 0){
            return (elem & BS_B(bit)) != 0;
        }
        int idx = BS_LONG(elem & INLINE_MASK_BS)+2;
        long val = d.table[idx + (bit>>>SHIFTS_BS)] & BS_BIT(bit);
        return val != 0;
    }

    /**
     * Deliver a string representing the dag.
     *
     * @return     string
     */

    public String dagToString(){
        String res = "";
        for (int i = 0; i < this.dag.length; i++){
            if (i > 0) res += ",";
            res += dagElemToString(this.dag,i,3,this.dagHtb);
        }
        return res;
    }

    /**
     * Deliver a string representing the specified dag element.
     *
     * @param      dag reference to the dag
     * @param      i dag column
     * @param      what: 0 triples, 1: triples indexes, 2: nfa states, 3: short triples
     * @param      d dag hash table
     * @return     string
     */

    String dagElemToString(long[] dag, int i, int what, DagBuilder d){
        int ch = (i == 0) ? BOT : text.charAt(i-1);
        String str = null;
        str = dagElemToString(dag[i],ch,what,d);
        return str;
    }

    /**
     * Deliver a string representing the specified dag element.
     *
     * @param      ele dag element
     * @param      what: 0 triples, 1: triples indexes, 2: nfa states, 3: short triples
     * @param      d dag hash table
     * @return     string
     */

    String dagElemToString(long ele, int sym, int what, DagBuilder d){
        // TRACE(A,"dagElemToString %x sym %s\n",ele,this.symClassTable[sym]);
        String res = "";
        if (ele == 0) return res;
        boolean first = true;
        #ifdef DEBUG
        foreachbsCheck(ele,sym,d);
        #endif
        FOREACH_BS(ele,sym,d);
            int tn = _tn;
            BSATripleData tri = this.triplesTable[tn];
            if (!first) res += "|";
            first = false;
            if (what == 0){
                res += tn + ":" + tri.toString();
            } else if (what == 3){
                res += tripleToBrief(tri);
            } else {
                if (what == 1){
                    res += "" + tn;
                } else {
                    for (int s = 0; s < this.nfa.table.length; s++){
                        if (this.nfa.table[s].tnum == tn){
                            res += "" + s;
                            break;
                        }
                    }
                }
            }
        ENDFORBS();
        return res;
    }

    /**
     * Deliver the number of triples present in the specified dag element.
     *
     * @param      idx dag column
     * @return     number of triples
     */

    int cardDag(int idx){
        long set = this.dag[idx];
        if (set == 0) return 0;
        int res = 0;
        int ch = (idx == 0) ? BOT : text.charAt(idx-1);
        FOREACH_BS(set,ch,this.dagHtb);
            res++;
        ENDFORBS();
        return res;
    }

    /**
     * Deliver an array containing the number of the triples present in the
     * specified dag element.
     *
     * @param      idx dag column
     * @return     array
     */

    int[] dagElToArray(int idx){
        long set = this.dag[idx];
        if (set == 0) return null;
        int ch = (idx == 0) ? BOT : text.charAt(idx-1);
        int[] arr = new int[cardDag(idx)];
        int i = 0;
        FOREACH_BS(set,ch,this.dagHtb);
            arr[i++] = _tn;
        ENDFORBS();
        return arr;
    }

    /**
     * Deliver a string representing the number of the triples present in the
     * specified dag element.
     *
     * @param      idx dag column
     * @return     string
     */

    String dagBitsToString(int idx){
        String str = "";
        long set = this.dag[idx];
        if (set == 0) return str;
        int ch = (idx == 0) ? BOT : text.charAt(idx-1);
        FOREACH_BS(set,ch,this.dagHtb);
            str += " " + _j;
        ENDFORBS();
        return str;
    }

    /**
     * Deliver a set containing the triples present in the specified dag element.
     *
     * @param      idx dag column
     * @return     set
     */

    IntSetBit dagElToIntSetBit(int idx){
        long set = this.dag[idx];
        if (set == 0) return null;
        int ch = (idx == 0) ? BOT : text.charAt(idx-1);
        IntSetBit res = new IntSetBit();
        int i = 0;
        FOREACH_BS(set,ch,this.dagHtb);
            res.add(_tn);
        ENDFORBS();
        return res;
    }

    /**
     * Trace the dag.
     */

    void traceDag(){
        for (int i = 0; i < this.dag.length; i++){
            int ch = (i == this.text.length()) ? EOF : this.text.charAt(i);
            Trc.out.printf("%s: char %s %s 0x%x states %s starting %s triples %s\n",
                i,ch,toPrintable(ch),
                this.dag[i],dagElToIntSetBit(i),dagBitsToString(i),
                dagElemToString(this.dag,i,0,this.dagHtb));
        }
        showDag(0,this.dag.length,this.dagHtb);
    }

    /**
     * Deliver a string representing the specified character, with a printable
     * representation when the character is not printable.
     *
     * @param      ch character
     * @return     string
     */

    static String toPrintable(int ch){
        if (ch < '!' || ch > '~'){
            return String.format("\\u%04x",(int)ch);
        }
        return String.valueOf((char)ch);
    }

    /**
     * Trace the specified piece of the dag.
     *
     * @param      start start column
     * @param      end end column
     * @param      htb dag hash table
     */

    public void showDag(int start, int end, DagBuilder htb){
        for (int i = start; i < end; i++){
            Trc.out.printf("%s ",htb.name);
            long el = 0;
            el = htb.dag[i];
            if (el >= 0){
                Trc.out.printf("%s: %s\n",i,el);
            } else {
                el &= INLINE_MASK_BS;
                int idx = (int)el+2;
                long[] arr = Arrays.copyOfRange(htb.table,idx,idx+(int)htb.table[(int)el+1]);
                Trc.out.printf("%s: *%s %s\n",i,el,dagHex(arr));
            }
        }
    }

    /**
     * Trace the raw values of the specified dag.
     *
     * @param      dag reference to the dag
     */

    public void showDag(long[] dag){
        for (int i = 0; i < dag.length; i++){
            Trc.out.printf("... dag[%s]: %s\n",i,dag[i]);
        }
    }

    /**
     * Deliver a string representing the specified dag element in hexadecimal format.
     *
     * @param      val dag element
     * @param      htb dag hash table
     * @return     string
     */

    public String dagElToString(Number val, DagBuilder htb){
        String res = htb.name;
        res += " ";
        long el = val.longValue();
        if (el >= 0){
            res += el;
        } else {
            el &= INLINE_MASK_BS;
            int idx = (int)el+2;
            long[] arr = Arrays.copyOfRange(htb.table,idx,idx+(int)htb.table[(int)el+1]);
            res += "*" + el + " " + dagHex(arr);
        }
        return res;
    }

    /**
     * Deliver a string representing the specified dag element in hexadecimal format.
     *
     * @param      j dag column
     * @param      htb dag hash table
     * @return     string
     */

    public static String dagEljToString(int j, DagBuilder htb){
        String res = htb.name;
        long el = htb.dag[j];
        res += " ";
        if (el >= 0){
            res += el;
        } else {
            el &= INLINE_MASK_BS;
            int idx = (int)el+2;
            long[] arr = Arrays.copyOfRange(htb.table,idx,idx+(int)htb.table[(int)el+1]);
            res += "*" + el + " " + dagHex(arr);
        }
        return res;
    }

    /**
     * Deliver a string with a short representation of the dag.
     *
     * @param      htb dag hash table
     * @return     string
     */

    public static String dagShort(DagBuilder htb){
        String str = "[";
        for (int i = 0; i < htb.dag.length; i++){
            if (i > 0) str += ", ";
            str += dagEljToString(i,htb);
        }
        return str + "]";
    }

    /**
     * Deliver a string with an hexadecimal representation of the dag.
     *
     * @param      arr array of the dag
     * @return     string
     */

    static String dagHex(long[] arr){
        return dagHex(arr,arr.length);
    }

    /**
     * Deliver a string with an hexadecimal representation of the dag.
     *
     * @param      arr array of the dag
     * @param      len its length
     * @return     string
     */

    static String dagHex(long[] arr, int len){
        String str = "[";
        for (int j = 0; j < len; j++){
            if (j > 0) str += ", ";
            str += String.format("%x",arr[j]);
        }
        str += "]";
        return str;
    }

    /**
     * Check the consistency of the dag.
     *
     * @param      htb dag hash table
     */

    void checkDag(DagBuilder htb){
        int nrLong = 0;
        for (int i = 0; i < this.dag.length; i++){
            if (!checkDagEl(i,htb)) break;
        }
    }

    /**
     * Check the consistency of the specified piece of dag.
     *
     * @param      start start column
     * @param      end end column
     */

    void checkDag(int start, int end, DagBuilder htb){
        for (int i = start; i < end; i++){
            if (!checkDagEl(i,htb)) break;
        }
    }

    /**
     * Check the consistency of the specified element of dag.
     * 
     * @param      i dag column
     * @param      htb dag hash table
     */

    boolean checkDagEl(int i, DagBuilder htb){
        int err = 0;
        int ch = (i == 0) ? BOT : text.charAt(i-1);
        doit: {
            long d = 0;
            if (i >= htb.dag.length){
                err = 1;
                break doit;
            }            
            d = htb.dag[i];
            if (d == 0){
                err = 2;
                break doit;
            }            
            int sn = startSet(ch);
            int tslen = this.tripleStarting[sn].length;
            if (d > 0){
                if (tslen > INLINE_BS){
                    Trc.out.printf("dag error col %s inine not enough %s\n",i,tslen);
                    err = 3;
                    break doit;
                }
            } else {
                if (tslen < INLINE_BS){
                    Trc.out.printf("dag error col %s long set not needed %s\n",i,tslen);
                    err = 4;
                    break doit;
                }
                if (htb.table == null){
                    err = 5;
                    break doit;
                }
            }
        } // doit
        if (err > 0){
            Trc.out.printf("dag error %s\n",err);
            new Throwable().printStackTrace(Trc.out);
            System.exit(1);
        }
        return err == 0;
    }

    /**
     * Compare the specified dags.
     *
     * @param      ht1 first dag hash table
     * @param      ht2 second dag hash table
     * @return     <code>true</code> if equal, <code>false</code> otherwise
     */

    static boolean compareDag(Object ht1, Object ht2){
        DagBuilder htb1 = (DagBuilder)ht1;
        DagBuilder htb2 = (DagBuilder)ht2;
        long[] d1 = htb1.dag;
        long[] d2 = htb2.dag;

        int err = 0;
        doit: {
            if (d1.length != d2.length){
                err = 1;
                break doit;
            }
            for (int i = 0; i < d1.length; i++){
                if (d1[i] == 0 || d2[i] == 0){
                    err = 10;
                    break doit;
                }
                if (d1[i] > 0){
                    if (d2[i] < 0){
                        err = 2;
                        break doit;
                    }
                    if (d1[i] != d2[i]){
                        err = 3;
                        break doit;
                    }
                 } else {
                    if (d2[i] > 0){
                        err = 4;
                        break doit;
                    }
                    if (htb1.table == null){
                        err = 5;
                        break doit;
                    }
                    if (htb2.table == null){
                        err = 50;
                        break doit;
                    }
                    int d1i = BS_LONG(d1[i] & INLINE_MASK_BS);
                    int d2i = BS_LONG(d2[i] & INLINE_MASK_BS);
                    int idx1 = d1i+2;
                    int idx2 = d2i+2;
                    if (idx1 >= htb1.table.length){
                        err = 51;
                        break doit;
                    }
                    if (idx2 >= htb2.table.length){
                        err = 52;
                        break doit;
                    }
                    if (htb1.table[d1i+1] != htb2.table[d2i+1]){
                        err = 6;
                        break doit;
                    }
                    long[] tab1 = Arrays.copyOfRange(htb1.table,idx1,idx1+(int)htb1.table[d1i+1]);
                    long[] tab2 = Arrays.copyOfRange(htb2.table,idx2,idx2+(int)htb2.table[d2i+1]);
                    if (!Arrays.equals(tab1,tab2)){
                        err = 7;
                        break doit;
                    }
                }
            }
        } // doit
        if (err > 0){
            Trc.out.printf("dag diff %s %s %s\n",err,dagShort(htb1),dagShort(htb2));
            // new Throwable().printStackTrace(Trc.out);
        }
        return err == 0;
    }

    /**
     * Deliver a string representing the dag as a graph in the ShowGraph format.
     *
     * @return     string
     */

    String dagToGraph(){
        TRACE(T,"dagToGraph\n");
        Graph g = new Graph(Graph.DIRECTED);
        g.name = "dag";
        // create all nodes
        Node[][] nodes = new Node[dag.length][];
        for (int i = 0; i < dag.length; i++){
            int ch = (i == 0) ? BOT : text.charAt(i-1);
            int[] arr = dagElToArray(i);
            nodes[i] = new Node[arr.length];
            for (int j = 0; j < arr.length; j++){
                nodes[i][j] = g.newNode("\"" + arr[j] + ":" +
                    this.triplesTable[arr[j]].toString() + i + "," + j + "\"" + "#" + i);
                TRACE(T,"node[%s][%s] %s state %s\n",i,j,nodes[i][j],arr[j]);
            }
        }
        // create then the edges
        int[] prev = dagElToArray(0);
        for (int i = 1; i < dag.length; i++){
            char ch = text.charAt(i-1);
            int[] arr = dagElToArray(i);
            int[] curr = dagElToArray(i);
            for (int j = 0; j < curr.length; j++){
                int tn = curr[j];
                BSATripleData tsucc = this.triplesTable[tn];
                TRACE(T,"tsucc %s\n",tsucc.toString());
                for (int k = 0; k < prev.length; k++){
                    int tp = prev[k];
                    BSATripleData tprev = this.triplesTable[tp];
                    TRACE(T,"tprev %s\n",tprev.toString());
                    if (tprev.endsymbol == tsucc.startsymbol){   // linked
                        g.newEdge(nodes[i-1][k],nodes[i][j],"\"" + ch + "\"",true);
                        TRACE(T,"edge [%s][%s] --%s--> [%s][%s]\n",i-1,k,ch,i,j);
                    }
                }
            }
            prev = curr;
        }
        return g.toString();
    }

    //-------- Access to dag --------------
    
    /** A mark on the dag graph. */

    private static class TrSet implements Cloneable {

        /** Set of marks: columns and triple nrs. */
        Set<int[]> set;

        #ifdef DEBUG
        /** Paths of triples. */
        List<Integer> path = new LinkedList<Integer>();
        #endif

        /**
         * Construct a mark object.
         * 
         * @return     object
         */

        TrSet(){
            this.set = new HashSet<int[]>();
        }

        /**
         * Deliver a string representation of this object.
         * 
         * @return     string
         */

        public String toString(){
            String str = "[";
            for (int[] a : this.set){
                if (str.length() > 1) str += " ";
                str += "col:" + a[0] + ",tr:" + a[1];
            }
            str += "]";
            return "open triple: " + str;
        }

        /**
         * Add a new mark with the specified column an triple numbers.
         * 
         * @param      col column number
         * @param      tn triple number
         */

        void add(int col, int tn){
            if (this.set == null){
                this.set = new HashSet<int[]>();
            }
            this.set.add(new int[]{col,tn});
            #ifdef DEBUG
            this.path.add(tn);
            #endif
        }

        /**
         * Tell if there are no marks in this object.
         * 
         * @return     <code>true</code> if there are no marks, <code>false</code> otherwise
         */

        boolean isEmpty(){
            return this.set.isEmpty();
        }

        /**
         * Deliver a clone of this object.
         * 
         * @return     reference to the clone
         */

        TrSet cloneTr(){
            TrSet res = new TrSet();
            res.set = new HashSet<int[]>();
            res.set.addAll(this.set);
            #ifdef DEBUG
            res.path = new LinkedList<Integer>();
            res.path.addAll(this.path);
            #endif
            return res;
        }

        /**
         * Remove all the marks.
         */

        void clear(){
            this.set.clear();
            #ifdef DEBUG
            this.path.clear();
            #endif
        }
    }

    /** A match. */
    
    public static class Match {

        /** The start index of the matched substring. */
        int start;

        /** The end index of the matched substring. */
        int end;

        /** The number of the triple. */
        int triple;

        /** The number of the enclosing parenthesis. */
        int paren;

        /**
         * Construct a match object with the specified start and end indexes.
         * 
         * @param      start start index
         * @param      end end index
         * @return     object
         */

        Match(int s, int e){
            this(s,e,-1,-1);
        }

        /**
         * Construct a match object with the specified start and end indexes, and
         * triple number and enclosing parenthesis.
         * 
         * @param      start start index
         * @param      end end index
         * @param      t triple number
         * @param      p enclosing parenthesis
         * @return     object
         */

        Match(int s, int e, int t, int p){
            this.start = s;
            this.end = e;
            this.triple = t;
            this.paren = p;
        }

        /**
         * Deliver a string representation of this object.
         * 
         * @return     string
         */

        public String toString(){
            return this.start + "-" + this.end + ":" + this.triple + "(" + this.paren;
        }

        /**
         * Tell if this mark is equal to the specified other one.
         * 
         * @param      other other mark
         * @return     <code>true</code> if it is, <code>false</code> otherwise
         */

        public boolean equals(Match other){
            return this.start == other.start && this.end == other.end && this.triple == other.triple;
        }
        public boolean equals(Object other){
            return equals((Match)other);
        }

        /**
         * Deliver the hash code of this mark.
         * 
         * @return     hash code
         */

        public int hashCode(){
            return this.start * 31 + this.end;
        }

        /**
         * Compare this mark with the other specified one.
         * 
         * @param      other other mark
         * @return     -1 if it precedes the other, 0 if equal, 1 if it follow the other
         */

        public int compareTo(Match other){
            int res = 0;
            if (this.start != other.start){
                res = this.start - other.start;
            } else if (this.end != other.end){
                res = this.end - other.end;
            } else {
                res = this.triple - other.triple;
            }
            return res;
        }
    }

    /*
     * There are two methods here that can extract data from the dag, both deliver lists of
     * pairs of indexes (offsets) in the text of substrings:
     *
     *    getMatches():    extract offsets of strings that match a group, or a group inside another
     *    getChildren():   extract offsets of the children of a match
     *
     * - getMatches() is typically called to get the matches of a desired group, and then called
     *   again to get the ones of the desired groups in it. This is the same as visiting a forest.
     *   It is also useful to get the matches of an inner group, wherever it is in the text.
     * - getChildren() serves instead to access the dag as a forest without using groups.
     *   It relies on getMatches().
     *
     * - to seek the indexes in the text that match the specified group, the dag is visited
     *   from the specified start index to the end one, marking the triple that contains
     *   the open of the group, and carrying along the mark over the triples linked to it
     *   until the matching close is found. At that point the indexes are recorded, and filed
     *   to be reported at the end.
     * - when a match is not passed as argument, or one with no triple, all the matches of
     *   the specified group are returned.
     *   When instead a match is passed, the open is recognized only if it lies in a
     *   path from a triple corresponding to the specified group.
     * - to get the matches of a group enclosed in a specified one, the triple of the specified
     *   match is searched in the start column of the match and if it contains the open of the
     *   group, it is handed down, and if not containing the desired open, an empty mark is
     *   handed down. The latter serves because the desired group could lie some columns after
     *   the start.
     * - the marks are instances of TrSet. getMatches keeps a vector of TrSet for the current
     *   column, and another for the next. At the end of the processing of a column, it swaps
     *   the vectors. The marks are placed in the vectors at the same position they have in
     *   tripleStarting.
     * - when processing a triple in a column, it hands down the mark (if any) to the triples
     *   linked to is in the next column, and then so on to the next ones until a close is found,
     *   in which case, if the triple containing it has the token, then it means that there
     *   is another before in a path for the open.
     *   When visiting a triple, if it has a mark, it hands it down anyway to the linked ones.
     *   Handing down terminates eventually when the close has been found.
     * - a special case is the opening and closing of a group in the same triple. This occurs
     *   when the group matches the empty string. This is catered for when a desired open is
     *   found, checking that the open is in the same triple (and then recording a match).
     * - when a path bifurcate, i.e. a triple has several successors, each successor gets
     *   a copy of the mark (if any).
     * - when paths join, i.e. several triples have a same successor, all the data of all
     *   such triples are merged in a single one.
     *   This is why marks have a set of (column,triple-nr) in them.
     * - a close closes all opens. This is so because they cannot be nested. E.g. a )1 closes
     *   all (1 opens (that are on converging paths). This happens, e.g. in "((a|aa))*" aaaa
     * - there are cases in which in a same column we have a triple with the desired open
     *   and another triple with the desired close.
     *   That close does not pair the open. This is handled by checking whether they occur in
     *   the same triple. If they do, a new match is recorded, and no mark is handed down.
     *   Otherwise they occur in different triples (of the same column), and then their marks
     *   are different.
     *
     * - in order to navigate the tree, getChildren returns the n-th son of the specified
     *   match. For sub-res that are not groups, the nth-ast son can be searched, but for
     *   sub-res that are groups, the ast has only one son, so we must search the sons in
     *   the tree. For the asts whose sons are alternatives, the one that is present is returned.
     *   First it takes the enclosing match and, if the ast is an alternative, it determines the
     *   number of the son ast looking to the dag.
     *   For groups it returns all the bodies.
     *
     * - when there are several matches for the same group at the same place in the text
     *   (i.e. the text is ambiguous), all the matches are returned.
     *   getMatches (a|ab)(c|bc) text abc delivers two matches for the first group.
     *   One can then be passed to getMatches, which returns for it "a" and "bc", and
     *   when called with the other return "ab" and "c".
     *   Matches have the triple number in them, which allows getMatches to start at the
     *   offset start, but consider only that triple.
     * - getMatches (.*)abc(.*) with text xxxabcxxabc matches both, which is what one expects.
     */

    /**
     * Deliver the children of the specified match.
     *
     * @param      piece match
     * @return     list of matches of the children
     */

    public List<Match> getChildren(Match piece){
        TRACE(T,"getChildren piece %s\n",piece);
        #ifdef DEBUG
        if ((FL_T & this.trc) != 0){
            traceAst();
        }
        #endif
        int paren = 0;
        int tn = 0;
        if (piece != null && piece.paren >= 0){
            paren = piece.paren;
            tn = piece.triple;
        } else {
            // no match specified, in case there are several ambiguous ones,
            // take all triples that start with (0
            List<Match> res = new LinkedList<Match>();
            for (int i = 0; i < this.triplesNr; i++){
                BSATripleData tri = this.triplesTable[i];
                if (tri == null) continue;
                int start = tri.startsymbol;
                AstNode ast = BSeleToAst(start);
                if (ast == this.botAst){
                    piece = new Match(0,this.text.length(),i,0);
                    res.addAll(getChildren(piece));
                }
            }
            return res;
        }
        TRACE(T,"getChildren triple %s paren %s\n",tn,paren);
        // paren is the number of a parenthesis, and then also that of an ast
        AstNode ast = this.astMap[paren];
        if (ast.kind == A_ALT){
            BSATripleData tri = this.triplesTable[tn];
            BSsymbol tag = this.tagsTable[tri.tag];
            for (int j = 0; j < tag.length(); j++){
                // find the open
                ast = BSeleToAst(tag.arr[j]);
                if (ast.pos == ast.pos){  // found
                    return getMatchesNode(piece,astToBSele(ast,ELECLOSE));
                }
            }
        } else {
            List<Match> res = new LinkedList<Match>();
            if (ast.son != null){
                for (AstNode a = ast.son; a != null; a = a.bro){
                    res.addAll(getMatchesNode(piece,astToBSele(a,ELECLOSE)));
                }
            }
            return res;
        }
        return getMatchesNode(piece,astToBSele(ast,ELECLOSE));
    }

    /**
     * Deliver the list of matches of the group inside the specified match.
     *
     * @param      piece match
     * @param      group number of the group
     * @return     list of matches
     */

    public List<Match> getMatches(Match piece, int group){
        if (group >= this.groupNumbers.length){   // illegal group
            return null;
        }
        int close = this.groupNumbers[group];
        return getMatchesNode(piece,close);
    }

    /**
     * Deliver the list of matches of the closed parenthesis inside the specified match.
     *
     * @param      piece match
     * @param      close closed parenthesis
     * @return     list of matches
     */

    public List<Match> getMatchesNode(Match piece, int close){
        TRACE(T,"getMatches piece %s group %s\n",piece,close);
        #ifdef DEBUG
        if ((FL_T & this.trc) != 0){
            traceTriples();
            traceGroups();
            Trc.out.printf("dag\n");
            traceDag();
            Trc.out.printf("numbered RE: %s\n",this.astRoot.toNumRE());
        }
        #endif

        List<Match> res = new LinkedList<Match>();
        TRACE(T,"getMatches close %s\n",close);
        int open = (close & ~ELECLOSEB) | ELEOPENB;
        int openNr = BSeleToAstNum(open);
        TrSet[] tsetscurr = new TrSet[this.triplesNr];
        TrSet[] tsetsnext = new TrSet[this.triplesNr];
        TRACE(T,"getMatches close %s\n",BSeleToString(close));
        boolean init = true;
        int pstart = 0;
        int pend = this.dag.length;
        if (piece == null){
            init = false;
        } else {
            pstart = piece.start;
            pend = piece.end + 1;
            if (piece.triple < 0){    // no triple in it, only bounds
                init = false;
                piece = null;
            }
        }
        TRACE(T,"getMatches start %s end %s\n",pstart,pend);
        for (int i = pstart; i < pend; i++){
            int ch = i < this.text.length() ? this.text.charAt(i) : EOF;
            TRACE(T,"\ndag col %s char %s nr triples %s\n",i,ch,cardDag(i));
            #ifdef DEBUG
            if ((FL_T & this.trc) != 0){
                traceTriplesTrSets(tsetscurr,i);
            }
            #endif
            int acc = i == 0 ? BOT : this.text.charAt(i-1);
            FOREACH_BS(this.dag[i],acc,this.dagHtb);
                BSATripleData tri = this.triplesTable[_tn];
                if (init && (_tn != piece.triple)){
                    continue;
                }
                BSsymbol tag = this.tagsTable[tri.tag];
                int ts = _j;           // index of this triple in starting
                TRACE(T,"  visit %s: %s index in starting %s curr %s ts %s\n",
                    _tn,tri,_j,tsetscurr[ts],ts);
                for (int j = 0; j < tag.length(); j++){
                    TRACE(T,"      ele %s\n",BSeleToString(tag.arr[j]));
                    // check that it is an open and that the ast pos is the same
                    if (BSeleKind(tag.arr[j]) == ELEOPEN &&
                        BSeleToAst(tag.arr[j]).pos == BSeleToAst(open).pos){
                        if (piece != null){
                        }
                        if (paired(open,j,tag.arr)){
                            Match os = new Match(i,i,_tn,openNr);
                            TRACE(T,"      match added %s\n",os);
                            addMatch(res,os);
                            continue;
                        }
                        // add the column to the set
                        // tsetscurr is indexed with triplestarting numbers
                        TrSet tset = tsetscurr[ts];
                        if (tset == null){
                            tset = new TrSet();
                            tsetscurr[ts] = tset;
                        }
                        // N.B. there can be several in the same column
                        tset.add(i,_tn);
                        TRACE(T,"      col %s open found set for triple %s: %s\n",
                            i,nstate,tsetscurr[ts]);
                    }
                    cl: if (BSeleKind(tag.arr[j]) == ELECLOSE &&
                        BSeleToAst(tag.arr[j]).pos == BSeleToAst(close).pos){
                        // N.B. there can be several in the same column
                        // _tn triple number of the triple whose parenteses we are visiting
                        // tsetscurr[ts] is its set of matches
                        TRACE(T,"      close triple %s in current %s: %s\n",
                            _tn,ts,tsetscurr[ts]);
                        if (tsetscurr[ts] == null) continue;

                        // handle the case of a same numbered parenthesis is opened
                        // and closed in the same triple
                        if (paired(close,j,tag.arr)){
                            continue;
                        }

                        TRACE(T,"      col %s close found %s triple %s set card %s\n",
                            i,tag.toString(),_tn,tsetscurr[ts].set.size());
                        // record all the matches
                        for (int[] op : tsetscurr[ts].set){
                            Match os = new Match(op[0],i,op[1],openNr);
                            TRACE(T,"      match added %s\n",os);
                            addMatch(res,os);
                        }
                        TRACE(T,"      clear %s\n",tsetscurr[ts]);
                        tsetscurr[ts] = null;      // no longer handed down
                    }
                }
                if (init && tsetscurr[ts] == null){
                    tsetscurr[ts] = new TrSet();
                }
  
                // hand down to the linked triples in the column to the right
                // if a new set made, or a triple with a nonempty set found,
                // find the linked triple and handle the set down to it
                TrSet t = tsetscurr[ts];
                if (t != null && i < this.text.length()){
                    TRACE(T,"  getMatches hands down %s: %s\n",nstate,t);
                    // find the triples linked to it in the next list and
                    // hand down the token to them: they are the ones that have
                    // their start symbol equal to tri.endsymbol
                    // find the index of the triple in the tripleStarting of the next column                
                    Nfa.State st = this.nfa.table[nstate];
                    // first serves to reuse t the first time, and to clone it the next ones
                    boolean first = true;
                    for (Nfa.Arc tr = st.transList; tr != null; tr = tr.next){
                        int next = tr.nextState.number;
                        int idx = this.base[next];
                        int tsn = this.tstable[idx+startSet(ch)];
                        // check that the triple is present in the column
                        if (!getDag(this.dag[i+1],tsn,this.dagHtb)) continue;
                        if (first){
                            #ifdef DEBUG
                            t.path.add(_tn);
                            #endif
                            if (tsetsnext[tsn] != null){
                                tsetsnext[tsn].set.addAll(t.set);
                            } else {
                                tsetsnext[tsn] = t;
                            }
                            first = false;
                        } else {
                            if (tsetsnext[tsn] != null){
                                tsetsnext[tsn].set.addAll(t.set);
                            } else {
                                tsetsnext[tsn] = t.cloneTr();
                            }
                        }
                        TRACE(T,"      triple %s handed down to %s (starting %s) with match %s\n",
                            nstate,next,tsn,tsetsnext[tsn]);
                    }
                }
                tsetscurr[ts] = null;    // remove it
            ENDFORBS();
            #ifdef DEBUG
            if ((FL_T & trc) != 0){
                if (i+1 < this.dag.length){
                    Trc.out.printf("triples with matches for next column %s\n",i+1);
                    traceTriplesTrSets(tsetsnext,i+1);
                }
            }
            #endif

            TrSet[] tmp = tsetscurr;
            tsetscurr = tsetsnext;
            tsetsnext = tmp;
            init = false;
        }
        res.sort((Match o1, Match o2) -> o1.compareTo(o2));
        TRACE(T,"getMatches res %s\n",res);
        return res;
    }

    /**
     * Tell if at the specified index in the tag (parentheses of a triple) is
     * present an open and a close of the same specified parenthesis.
     *
     * @param      paren parenthesis
     * @param      idx start index in tag
     * @param      tag sequence of parentheses
     * @return     <code>true</code> if there is, <code>false</code> otherwise
     */

    private boolean paired(int paren, int idx, int[] tag){
        boolean res = false;
        doit: {
            int eleKind = BSeleKind(paren);
            if (eleKind == ELEOPEN){               // open, search forward
                int close = (paren & ~ELEOPENB) | ELECLOSEB;
                for (int i = idx+1; i < tag.length; i++){
                    if (tag[i] == close){          // found
                        res = true;
                        break doit;
                    }
                }
            } else {
                int open = (paren & ~ELECLOSEB) | ELEOPENB;
                for (int i = idx-1; i >= 0; i--){
                    if (tag[i] == open){          // found
                        res = true;
                        break doit;
                    }
                }
            }
        } // doit
        // TRACE(T,"paired %s from %s res %s\n",BSeleToString(paren),idx,res);
        return res;
    }       

    /**
     * Add a match to the specified list of matches if there is no equal one.
     * present an open and a close of the same specified parenthesis.
     *
     * @param      res list of matches
     * @param      off match to add
     */

    private void addMatch(List<Match> res, Match off){
        if (!res.contains(off)){
            res.add(off);
        }
        // TRACE(T,"addMatch %s add res %s\n",off,res);
    }

    /**
     * Trace the tree of matches of the dag.
     */

    public void traceTree(){
        traceTree(null,0,"");
    }

    /**
     * Trace the subtree tree of matches of the specified one.
     *
     * @param      match match
     * @param      lev nesting level
     */

    void traceTree(Match match, int lev, String fat){
        List<Match> matches = getChildren(match);
        int son = 0;
        for (Match m : matches){
            String str = "";
            if (this.groupNumbers != null){
                for (int i = 0; i < this.groupNumbers.length; i++){
                    if (BSeleToAstNum(this.groupNumbers[i]) == m.paren){
                        str += " group " + i;
                        break;
                    }
                }
            }
            Trc.out.printf("%s%s%s|%s| -- %s %s\n",indent(lev),
                fat,son,
                Str.strQuoted(this.text.substring(m.start,m.end)),m,str);
            traceTree(m,lev+1,fat+son+".");
            son++;
        }
    }
            
    /**
     * Trace the triples that are present in the specified dag column and that have
     * a mark.
     *
     * @param      vec vector of triple offsets, that parallels the tripleStarting for the column
     * @param      col column number
     */

    void traceTriplesTrSets(TrSet[] vect, int col){
        Trc.out.printf("triples with matches in column %s\n",col);
        int ch = (col == 0) ? BOT : this.text.charAt(col-1);
        FOREACH_BS(this.dag[col],ch,this.dagHtb);
            if (vect[_j] == null) continue;
            BSATripleData tri = this.triplesTable[_tn];
            Trc.out.printf("  %s: %s %s in curr %s\n",_tn,tri.toString(),vect[_j],_j);
        ENDFORBS();
        Trc.out.printf("end %s\n",col);
    }

    /**
     * Recognizes the text using the parallel algorithm.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: default 2, < 0 recognizion with -nrproc threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    // DFA, MIN_ME_DFA, ME_DFA, DFA_TR, DFA_F, DFA_B, DFA_FB, NME_DFA, NME_DFA_B
    boolean recPar(String text, int nrproc){
        TRACE(M,"recPar nrproc %s\n",nrproc);
        TRACE(PQ,"recPar %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("recPar nfa\n");
            this.nfa.trace();
            Trc.out.printf("recPar (me-)dfa\n");
            this.dfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();

        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks
        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = true;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = true;
        IntSetBit tmpset = new IntSetBit();
        if (this.text.length() == 0){                     // special case for the empty string
            if (this.nfa.gmy){
                return this.nfa.table[0].accepting;
            }
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    tmpset.add(nstate);
                    res = true;
                }
            ENDFOR_IS();
            return res;
        }

        TRACE(MPQ,"recPar ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start of chunks
        this.startChunk = new int[nrChunks];
        TRACE(Q,"recPar nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = chunk * i;
            }
        }
        #ifdef DEBUG
        for (int i = 0; i < nrChunks; i++){
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
        }
        #endif

        // use -1 to tell that there are no states
        // determine the forward start states of all the chunks
        int[][] L = new int[nrChunks][];                  // current forward states
        for (int i = 0; i < nrChunks; i++){
            TRACE(M,"initial states for chunk %s %s...%s\n",i,
                this.text.charAt(this.startChunk[i]),
                this.text.charAt(endChunk(i,nrChunks)-1));
            int n = 0;
            if (this.dfaKind == DFA || this.dfaKind == DFA_TR ||  // dfa
                this.dfaKind == DFA_F || this.dfaKind == DFA_B ||
                this.dfaKind == DFA_FB){
                L[i] = new int[this.dfa.strictStateNr];
                Arrays.fill(L[i],-1);
                if (i == 0){          // first chunk
                    L[i][0] = 0;
                    n = 1;
                } else {
                    // optimize reducing the initial states by removing the
                    // ones that cannot produce transitions or that cannot be
                    // reached with transitions from the previous chunk
                    if (this.dfaKind == DFA_F ||  // use only initial states that have an outgoing arc
                        // this could be precomputed
                        this.dfaKind == DFA_FB){       
                        int ch = this.text.charAt(this.startChunk[i]);
                        for (int k = 0; k < L[i].length; k++){
                            int bas = this.dfa.base[k];
                            int startt = bas+subclass(ch);
                            TRACE(Q,"initial states for chunk %s trans with %s to %s\n",
                                i,ch,this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1);
                            if (this.dfa.check[startt] == bas){
                                L[i][k] = k;
                            }
                        }
                    }
                    if (this.dfaKind == DFA_B ||       // use only initial states that have an incoming arc
                        this.dfaKind == DFA_FB){
                        // this could be precomputed
                        boolean[] vec = new boolean[L[i].length];
                        int ch = this.text.charAt(endChunk(i-1,nrChunks)-1);
                        TRACE(Q,"chunk %s prev %s: %s\n",i,endChunk(i-1,nrChunks),ch);
                        for (int k = 0; k < L[i].length; k++){
                            int bas = this.dfa.base[k];
                            int startt = bas+subclass(ch);
                            if (this.dfa.check[startt] == bas){
                                vec[this.dfa.trtable[startt]] = true;
                            }
                        }
                        for (int k = 0; k < L[i].length; k++){
                            if (vec[k]){
                                L[i][k] = k;
                            } else {
                                L[i][k] = -1;
                            }
                        }
                    }
                    if (this.dfaKind == DFA || this.dfaKind == DFA_TR){
                        for (int k = 0; k < L[i].length; k++){
                            L[i][k] = k;
                        }
                    }
                    n = L[i].length;
                }
            } else {                                      // me-dfa
                L[i] = new int[this.nfa.stateNr];
                Arrays.fill(L[i],-1);
                if (i == 0){          // first chunk, use only the real start states
                    for (int j = 0; j < this.dfa.start0.length; j++){
                        int nfast = this.dfa.start0[j];
                        L[i][nfast] = this.dfa.startStates[nfast];
                    }
                    n = this.dfa.start0.length;
                } else {
                    if (this.dfaKind == MIN_ME_DFA_B ||
                        this.dfaKind == NME_DFA_B){
                        IntSetBit reached = new IntSetBit();
                        int ch = this.text.charAt(endChunk(i-1,nrChunks)-1);
                        for (int j = 0; j < this.nfa.stateNr; j++){
                            // take the states reached with ch
                            // and then take the representatives, if the dfa has any
                            IntSetBit tra = transit(j,ch);
                            if (tra != null){
                                if (this.dfaKind == MIN_ME_DFA_B){
                                    int[] arr = tra.toArray();
                                    for (int a = 0; a < arr.length; a++){
                                        reached.add(this.dfa.nfaRepres[arr[a]]);
                                    }
                                } else {
                                    reached.add(tra);
                                }
                            }
                        }
                        // now reached contains all the nfa states with an incoming arc ch
                        TRACE(M,"   states with incoming %s: %s all start states: %s\n",
                            ch,reached,Arrays.toString(this.dfa.start1));
                        for (int j = 0; j < this.dfa.start1.length; j++){
                            int nfast = this.dfa.start1[j];             // nfa state
                            if (reached.contains(nfast)){      // reached
                                L[i][nfast] = this.dfa.startStates[nfast];
                            } else {
                                n++;
                            }
                        }
                    } else {
                        TRACE(M,"   all start states: %s\n",Arrays.toString(this.dfa.start1));
                        for (int j = 0; j < this.dfa.start1.length; j++){
                            int nfast = this.dfa.start1[j];             // nfa state
                            L[i][nfast] = this.dfa.startStates[nfast];  // corresponding mefa initial state
                        }
                        n = this.dfa.start1.length;
                    }
                }
            }
            #ifdef MEASURE
            this.measure.chunkStart[i] = n;
            #endif
        }

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward start states:\n");
            traceL(L);
        }
        #endif
        #ifdef MEASURE
        for (int k = 0; k < L.length; k++){
            for (int i = 0; i < L[k].length; i++){
                if (L[k][i] < 0) continue;
                this.measure.initialStates++;
            }
        }
        this.measure.timePar[2] = System.nanoTime();
        #endif
        if (nrproc == 1 && testing || simulate){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!recParFwd(i,nrChunks,L)){
                    TRACE(M,"recPar failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            if (simulate){
                this.measure.nrThreads = P;
            } else {
                this.measure.nrThreads = 1;
            }
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return recParFwd(cnt,nrChunks,L);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return recParFwd(cnt.get(),nrChunks,L,parses);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"recPar failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached forward states by chunk:\n");
            traceL(L);
        }
        #endif

        TRACE(MPQ,"recPar ---- sewing\n");

        // here we have array L: one vector, for each segment;
        // each element of the vector is a state:
        // the element i-th contains the state reached by the state i-th,
        // a start state for the segment.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L vector contains the state reached by transitions done with
        // the last character of the segment.

        res = true;
        if (this.dfaKind == DFA || this.dfaKind == DFA_TR ||       // dfa
            this.dfaKind == DFA_F || this.dfaKind == DFA_B || this.dfaKind == DFA_FB){
            int Ltemp = 0;
            TRACE(M,"matchPar initial fwd %s\n",Ltemp);
            for (int k = 0; k < nrChunks; k++){
                TRACE(M,"matchPar segm %s Ltemp %s\n",k,Ltemp);
                Ltemp = L[k][Ltemp];
                if (Ltemp < 0){
                    res = false;
                    break;
                }
            }
            if (!this.dfa.table[Ltemp].accepting){
                res = false;
            }
        } else {                       // me-dfa
            IntSetBit Ltemp = this.dfa.table[0].nfaStates;      // initial
            TRACE(M,"recPar initial fwd %s\n",Ltemp);
            Dfa.State newst = this.dfa.new State();
            for (int k = 0; k < nrChunks; k++){
                int[] Lk = L[k];
                TRACE(M,"recPar sewing segm %s Ltemp %s\n",k,Ltemp);
                IntSetBit next = new IntSetBit();
                FOREACH_IS(Ltemp);
                    // get the ones reached by it
                    if (Lk[nstate] >= 0){
                        next.add(this.dfa.table[Lk[nstate]].nfaStates);
                    }
                ENDFOR_IS();
                // here Ltemp is a dfa state
                newst.nfaStates = Ltemp;
                TRACE(Q,"recPar start dfa state for chunk %s\n",k);
                Ltemp = next;     // then use the reached states as the current set
                TRACE(Q,"recPar sew forward segment %s reaches %s\n",k,next);
                if (Ltemp.isEmpty()){
                    this.cursor = endChunk(k,nrChunks)-1;
                    res = false;
                    TRACE(Q,"recPar failed sewing chunl %s\n",k);
                    break;
                }
            }
            newst.nfaStates = Ltemp;
            if (res){
                res = false;
                // Ltemp here contains the states reached by the last segment,
                // check that it contains at least an accepting state
                FOREACH_IS(Ltemp);
                    TRACE(M,"matchPar --- %s\n",nstate);
                    if (this.nfa.table[nstate].accepting){
                        res = true;
                        break;
                    }
                ENDFOR_IS();
            }
        }
        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        TRACE(M,"recPar recognize %s\n",res);
        return res;
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the forward pass over the text taking chunks from the queue until
     * it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParFwd(Counter cnt, int P, int[][] L){
        TRACE(Q,"recParFwd\n");
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            if (!recParFwd(pi,P,L)) return false;
        }
        return true;
    }
    #endif

    /**
     * Make the forward pass over the text executing the reader on the
     * specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParFwd(int pi, int P, int[][] L){
        TRACE(MQ,"recParFwd segment %s\n",pi);
        #ifdef MEASURE
        this.measure.timeStartFwd[pi] = System.nanoTime();
        #endif

        int[] Lpi = L[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);
        #ifdef MEASURE
        this.measure.sizeChunk[pi] = end-start;
        #endif

        // The starting vector contains the dfa states to start the matching.

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            for (int i = 0; i < Lpi.length; i++){
                if (Lpi[i] < 0) continue;
                TRACE(M,"  start states %s: Lpi[%s] %s\n",i,i,Lpi[i]);
            }
        }
        #endif

        TRACE(M,"recParFwd text piece %s-%s\n",start,end);

        TRACE(M,"recParFwd forward scan\n");
        #ifdef MEASURE
        int[] lengths = new int[Lpi.length];
        int li = 0;
        #endif
        int parses = 0;
        for (int i = 0; i < Lpi.length; i++){
            if (Lpi[i] < 0) continue;
            int state = Lpi[i];                   // initial state
            TRACE(Q,"recParFwd %s processing Lp[%s] state %s char %s %s\n",
                pi,i,state,this.text.charAt(start),toPrintable(this.text.charAt(start)));
            int j = start;
            for (; j < end; j++){
                int ch = this.text.charAt(j);
                int bas = this.dfa.base[state];
                int startt = bas+subclass(ch);
                state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
                TRACE(Q,"recParFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),state);
                if (state < 0){
                    break;
                }
            }
            if (state >= 0){      // end state reached
                TRACE(MQ,"recParFwd %s parse %s-th successful\n",pi,i);
                // keep sequence
                parses++;
            } else {
                TRACE(MQ,"recParFwd %s parse %s-th failed at %s\n",pi,i,j);
                #ifdef MEASURE
                this.measure.nrtrans[pi]++;   // rekon also the failed transition
                #endif
            }
            Lpi[i] = state;
            #ifdef MEASURE
            lengths[li++] = j-start+1;
            this.measure.aveStChunk[pi] += j;
            this.measure.nrtrans[pi] += j-start+1;
            #endif
        }
        #ifdef MEASURE
        this.measure.parsesSurvived[pi] += parses;
        #endif
        if (parses == 0){
            // none successful
            this.cursor = start;
            return false;
        }
        #ifdef MEASURE
        this.measure.parsesLen[pi] = Arrays.copyOf(lengths,li);
        #endif

        return true;
    }

    /**
     * Deliver the number of the line of the specified index in the specified text.
     *
     * @param      text text
     * @param      index index
     * @return     line number
     */

    int lineNr(String text, int index){
        int line = 0;
        int startline = 0;
        for (int i = 0; i < index; i++){
            char c = this.text.charAt(i);
            if (c == '\r'){
                startline = i;
                line++;
                if (i < this.text.length()-1){
                    if (this.text.charAt(i+1) == '\n'){;
                        i++;
                    }
                }
            } else if (c == '\n'){
                startline = i;
                line++;
            }
        }
        return line;
    }

    /**
     * Recognizes the text using the parallel algorithm and the nfa.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: default 2, < 0 recognizion with -nrproc threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    boolean recParNfa(String text, int nrproc){
        TRACE(MPQ,"recParNfa %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("recPar nfa\n");
            this.nfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();
        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks
        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = true;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = true;
        if (this.text.length() == 0){                     // special case for the empty string
            if (this.nfa.gmy){
                return this.nfa.table[0].accepting;
            }
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    res = true;
                }
            ENDFOR_IS();
            return res;
        }
        TRACE(MPQ,"recParNfa ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start of chunks
        this.startChunk = new int[nrChunks];
        TRACE(Q,"recParNfa nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = chunk * i;
            }
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
        }

        // here we have then a vector L that has nfa states. For each of them a run on the nfa
        // is done, ending in a set of nfa states, that are united with the ones of the other
        // runs. At each character, transitions are done, reaching a set of nfa states. Then,
        // a transition is done for the next character on each of such states, making the union
        // with the reached states.

        // determine the forward start states of all the chunks
        IntSetBit[][] L = new IntSetBit[nrChunks][];                  // current forward states
        for (int i = 0; i < nrChunks; i++){
            int n = 0;
            L[i] = new IntSetBit[this.nfa.stateNr];
            if (i == 0){          // first chunk
                if (this.nfa.gmy){
                    L[i][0] = new IntSetBit(0);
                } else {
                    IntSetBit init = transit(0,BOT);              // initial
                    // take the states reached from the fake initial one
                    FOREACH_IS(init);
                        L[i][nstate] = new IntSetBit(nstate);
                    ENDFOR_IS();
                }
                n = 1;
            } else {
                for (int k = 0; k < L[i].length; k++){
                    L[i][k] = new IntSetBit(k);
                }
                n = L[i].length;
            }
            #ifdef MEASURE
            this.measure.chunkStart[i] = n;
            #endif
        }

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("forward start states:\n");
            traceL(L);
        }
        #endif
        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif

        if (nrproc == 1 && testing || simulate){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!recParNfaFwd(i,nrChunks,L)){
                    TRACE(M,"recPar failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            if (simulate){
                this.measure.nrThreads = P;
            } else {
                this.measure.nrThreads = 1;
            }
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return recParNfaFwd(cnt,nrChunks,L);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return recParNfaFwd(cnt.get(),nrChunks,L,parses);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"recPar failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached forward states by chunk:\n");
            traceL(L);
        }
        #endif

        TRACE(MPQ,"recParNfa ---- sewing\n");

        // here we have array L: one vector, for each segment;
        // each element of the vector is a set of states:
        // the element i-th contains the states reached by the state i-th,
        // a start state for the segment.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L vector contains the states reached by transitions done with
        // the last character of the segment.

        res = true;
        IntSetBit Ltemp = null;
        if (this.nfa.gmy){
            Ltemp = new IntSetBit(0);
        } else {
            Ltemp = transit(0,BOT);
        }
        TRACE(M,"matchParNfa initial fwd %s\n",Ltemp);
        for (int k = 0; k < nrChunks; k++){
            TRACE(M,"matchPar segm %s Ltemp %s\n",k,Ltemp);
            IntSetBit next = new IntSetBit();
            FOREACH_IS(Ltemp);
                // get the ones reached by it
                if (L[k][nstate] != null){
                    next.add(L[k][nstate]);
                }
            ENDFOR_IS();
            // here Ltemp is a set of nfa states
            Ltemp.assign(next);     // then use the reached states as the current set
            TRACE(M,"recPar sew forward segment %s reaches %s\n",k,Ltemp);
            if (Ltemp.isEmpty()){
                this.cursor = endChunk(k,nrChunks)-1;
                res = false;
                break;
            }
        }
        if (res){
            res = false;
            FOREACH_IS(Ltemp);
                if (this.nfa.table[nstate].accepting){
                    res = true;
                }
            ENDFOR_IS();
        }

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        TRACE(M,"recParNfa recognize %s\n",res);
        return res;
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the forward pass over the text taking chunks from the queue until
     * it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParNfaFwd(Counter cnt, int P, IntSetBit[][] L){
        TRACE(Q,"recParNfaFwd\n");
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            if (!recParNfaFwd(pi,P,L)) return false;
        }
        return true;
    }
    #endif

    /**
     * Make the forward pass over the text executing the reader on the
     * specified chunk using the nfa.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParNfaFwd(int pi, int P, IntSetBit[][] L){
        TRACE(MQ,"recParNfaFwd segment %s\n",pi);
        #ifdef MEASURE
        this.measure.timeStartFwd[pi] = System.nanoTime();
        #endif

        IntSetBit[] Lpi = L[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);
        #ifdef MEASURE
        this.measure.sizeChunk[pi] = end-start;
        #endif

        // The starting vector contains the dfa states to start the matching.

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            for (int i = 0; i < Lpi.length; i++){
                if (Lpi[i] == null) continue;
                TRACE(M,"  start states %s: Lpi[%s] %s\n",i,i,Lpi[i]);
            }
        }
        #endif

        TRACE(M,"recParNfaFwd text piece %s-%s\n",start,end);

        TRACE(M,"recParNfaFwd forward scan\n");
        #ifdef MEASURE
        int[] lengths = new int[Lpi.length];
        int li = 0;
        #endif
        int parses = 0;
        IntSetBit next = new IntSetBit();
        for (int i = 0; i < Lpi.length; i++){
            if (Lpi[i] == null) continue;
            IntSetBit states = Lpi[i];                   // initial states
            TRACE(MQ,"recParNfaFwd %s processing Lp[%s] states %s char %s %s\n",
                pi,i,states,this.text.charAt(start),toPrintable(this.text.charAt(start)));
            int j = start;
            for (; j < end; j++){
                int ch = this.text.charAt(j);
                int nr = transit(states,ch,next);
                #ifdef MEASURE
                lengths[li] += nr;
                this.measure.nrtrans[pi] += nr;
                #endif
                states.assign(next);
                TRACE(M,"recParNfaFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),states);
                if (states.isEmpty()) break;
            }
            if (!states.isEmpty()){      // end state reached
                TRACE(MQ,"recParNfaFwd %s parse %s-th successful\n",pi,i);
                // keep sequence
                parses++;
            } else {
                TRACE(MQ,"recParNfaFwd %s parse %s-th failed at %s\n",pi,i,j);
                #ifdef MEASURE
                this.measure.nrtrans[pi]++;   // rekon also the failed transition
                #endif
            }
            Lpi[i] = states;
            #ifdef MEASURE
            li++;
            this.measure.aveStChunk[pi] += j;
            #endif
        }
        #ifdef MEASURE
        this.measure.parsesSurvived[pi] += parses;
        #endif
        if (parses == 0){
            // none successful
            this.cursor = start;
            return false;
        }
        #ifdef MEASURE
        this.measure.parsesLen[pi] = Arrays.copyOf(lengths,li);
        #endif

        return true;
    }

    /**
     * Trace the L vectors.
     *
     * @param      L L vectors
     */

    void traceL(IntSetBit[][] L){
        for (int k = 0; k < L.length; k++){
            int start = startChunk(k,L.length);
            int end = endChunk(k,L.length);
            if (L[k] == null) continue;
            Trc.out.printf("  segment %s: %s-%s\n",k,start,end);
            for (int i = 0; i < L[k].length; i++){
                if (L[k][i] == null) continue;
                Trc.out.printf("  state %s: reaches L[%s][%s]: %s\n",
                    i,k,i,L[k][i]);
            }
        }
    }


    /**
     * Recognizes the text using the parallel algorithm and the cd-dfa.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: default 2, < 0 recognizion with -nrproc threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    /*
     * Recognizion is done as follows:
     *
     *    - the dfa is made as follows:
     *      - an initial state I is built with all the nfa states
     *      - it is visited, each of its nfa state taken, and the ones
     *        that have a same arc taken and a new nfa state built (as usual),
     *        representing all the nfa states that had such an arc.
     *        Each such nfa state is attributed with the state that originated it.
     *        E.g. a nfa state S1 in I with arcs a1 and a2 reaching nfa states
     *        S2 and S2 produces in the new dfa state S2{S1} and S3{S1}.
     *        All the other states of I are visited, and the same done.
     *        If a state Si reaches with the same arc S2, its origin set is updated
     *        adding Si.
     *        This allows to know what nfa states are reached by transitions starting
     *        from a state in I.
     *        To check that a chunk i can follow chunk i-1, we take the end dfa state
     *        of chunk i-1, and take the nfa states in it, let's call it S.
     *        Then we take the end state of chunk i, and in it the sets Tj of its nfa
     *        states. Then we take the nfa states j in it that have Tj intersect S not
     *        empty. This means that from a nfa state ending chunk i-1 there is a path in
     *        the nfa that reaches an end state in chunk i.
     *      - two states that have different origins are different
     *      - perhaps it is also possible to do it starting from the dfa without using
     *        the nfa states.
     */

    boolean recParCeDfa(String text, int nrproc){
        TRACE(MPQ,"recParCeDfa %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("recParCeDfa ce-dfa\n");
            this.dfa.trace();
            Trc.out.printf("recParCeDfa nfa\n");
            this.nfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();
        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks
        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = true;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = true;
        if (this.text.length() == 0){                     // special case for the empty string
            if (this.nfa.gmy){
                return this.nfa.table[0].accepting;
            }
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    res = true;
                }
            ENDFOR_IS();
            return res;
        }
        TRACE(MPQ,"recParCeDfa ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start of chunks
        this.startChunk = new int[nrChunks];
        TRACE(Q,"recParCeDfa nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = chunk * i;
            }
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
        }

        // determine the start states of all the chunks
        int[] L = new int[nrChunks];                  // current states
        for (int i = 0; i < nrChunks; i++){
            if (i == 0){          // first chunk
                L[i] = 0;
            } else {
                L[i] = this.dfa.startStates[1];
            }
            #ifdef MEASURE
            this.measure.chunkStart[i] = 1;
            #endif
        }
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("start states:\n");
            traceL(L);
        }
        #endif
        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif

        if (nrproc == 1 && testing || simulate){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!recParDfaFwd(i,nrChunks,L)){
                    TRACE(M,"recParCeDfa failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            if (simulate){
                this.measure.nrThreads = P;
            } else {
                this.measure.nrThreads = 1;
            }
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return recParDfaFwd(cnt,nrChunks,L);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return recParDfaFwd(cnt.get(),nrChunks,L,parses);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"recParCeDfa failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached states by chunk:\n");
            traceL(L);
        }
        #endif

        TRACE(MPQ,"recParCeDfa ---- sewing\n");

        // here we have array L: one vector, indexed with chunk number, telling the
        // state reached by the recognizion of the chunk.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L element contains the state reached by transitions done with
        // the last character of the segment.

        res = true;
        if (!this.dfa.table[L[nrChunks-1]].accepting){
            TRACE(M,"recParCeDfa not final\n");
            return false;
        }
        IntSetBit reached = this.dfa.table[L[0]].nfaStates;
        TRACE(M,"recParCeDfa sew chunk 0 end state %s %s\n",L[0],reached);
        for (int i = 1; i < nrChunks; i++){
            int nextstate = L[i];
            IntSetBit nextreached = new IntSetBit();
            Map<Integer,IntSetBit> orig = ((CeDfa.CeState)this.dfa.table[nextstate]).orig;
            TRACE(M,"recParCeDfa --- sew chunk %s end state %s orig %s\n",i,L[i],orig);
            for (Map.Entry<Integer,IntSetBit> entry : orig.entrySet()){
                int k = entry.getKey();
                IntSetBit v = entry.getValue();
                if (v.intersects(reached)){
                    nextreached.add(k);
                }
            }
            TRACE(M,"recParCeDfa sew chunk %s end state %s %s reached %s\n",
                i,L[i],this.dfa.table[L[i]].nfaStates,nextreached);
            reached = nextreached;
            if (reached.isEmpty()){
                TRACE(M,"recParCeDfa sew failed\n");
                res = false;
                break;
            }
        }

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        TRACE(M,"recParCeDfa recognize %s\n",res);
        return res;
    }

    #ifdef LOAD_BALANCE
    /**
     * Make the forward pass over the text taking chunks from the queue until
     * it becomes empty.
     *
     * @param      cnt queue of chunks
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParDfaFwd(Counter cnt, int P, int[] L){
        TRACE(Q,"recParDfaFwd\n");
        for (;;){
            int pi = cnt.get();
            if (pi < 0) break;
            if (!recParDfaFwd(pi,P,L)) return false;
        }
        return true;
    }
    #endif

    /**
     * Make the forward pass over the text executing the reader on the
     * specified chunk.
     *
     * @param      pi number of the chunk
     * @param      P number of chunks
     * @param      L L vectors
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    private boolean recParDfaFwd(int pi, int P, int[] L){
        TRACE(MQ,"recParDfaFwd segment %s\n",pi);
        #ifdef MEASURE
        this.measure.timeStartFwd[pi] = System.nanoTime();
        #endif

        int Lpi = L[pi];
        int start = startChunk(pi,P);
        int end = endChunk(pi,P);
        #ifdef MEASURE
        this.measure.sizeChunk[pi] = end-start;
        #endif

        // The starting element contains the dfa state to start the matching.

        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            TRACE(M,"  start state %s\n",Lpi);
        }
        #endif

        TRACE(M,"recParDfaFwd text piece %s-%s\n",start,end);

        TRACE(M,"recParDfaFwd scan\n");
        #ifdef MEASURE
        int[] lengths = new int[1];
        #endif
        int state = Lpi;                   // initial state
        TRACE(MQ,"recParDfaFwd %s processing state %s char %s %s\n",
            pi,state,this.text.charAt(start),toPrintable(this.text.charAt(start)));
        int j = start;
        for (; j < end; j++){
            int ch = this.text.charAt(j);
            int bas = this.dfa.base[state];
            int startt = bas+subclass(ch);
            state = this.dfa.check[startt] == bas ? this.dfa.trtable[startt] : -1;
            TRACE(M,"recParFwd %s at %s char %s %s next %s\n",pi,j,ch,toPrintable(ch),state);
            if (state < 0) break;
        }
        if (state >= 0){      // end state reached
            TRACE(MQ,"recParFwd %s recognized\n",pi);
        } else {
            TRACE(MQ,"recParFwd %s failed at %s\n",pi,j);
            this.cursor = start;
            return false;
        }
        L[pi] = state;
        #ifdef MEASURE
        lengths[0] = j-start+1;
        this.measure.aveStChunk[pi] += j;
        this.measure.parsesSurvived[pi] = 1;
        this.measure.parsesLen[pi] = Arrays.copyOf(lengths,1);
        this.measure.nrtrans[pi] = j-start+1;
        #endif

        return true;
    }

    /**
     * Trace the L vector.
     *
     * @param      L L vector
     */

    void traceL(int[] L){
        for (int k = 0; k < L.length; k++){
            int start = startChunk(k,L.length);
            int end = endChunk(k,L.length);
            Trc.out.printf("  segment %s: %s-%s reached %s\n",k,start,end,L[k]);
        }
    }

    /**
     * DFAs with several initial states, that allow to know the set of initial states
     * each state originates.
     */

    class CeDfa extends Dfa {

        /**
         * A state.
         */

        class CeState extends State {

            /** The map that make a state correspond to the ones it originated from. */
            Map<Integer,IntSetBit> orig;

            /** Whether this state is initial. */
            boolean initial;

            /**
             * Tell if this state is equal to the specified one.
             *
             * @param      other other state
             * @return     <code>true</code> if equal, <code>false</code> otherwise
             */

            public boolean equals(Object other){
                if (this == other) return true;
                if (other == null) return false;
                CeState oth = (CeState)other;
                if (!this.nfaStates.equals(oth.nfaStates)) return false;
                // compare the origins
                if ((this.orig == null) != (oth.orig == null)) return false;
                if (this.orig == null) return true;
                if (!this.orig.keySet().equals(oth.orig.keySet())) return false;
                for (Map.Entry<Integer,IntSetBit> entry : this.orig.entrySet()){
                    int k = entry.getKey();
                    IntSetBit v1 = entry.getValue();
                    IntSetBit v2 = oth.orig.get(k);
                    if ((v1 == null) != (v2 == null)) return false;
                    if (v1 == null) continue;
                    if (!v1.equals(v2)) return false;
                }
                return true;
            }

            /**
             * Trace this state.
             */

            void trace(){
                String status = "";
                if (this.initial) status += " initial";
                if (this.accepting) status += " final";
                Trc.out.printf("state: %s%s",this.number,status);
                Trc.out.printf(" %s orig %s\n",this.nfaStates,this.orig);
                if (this.transList != null){
                    Trc.out.printf("  transitions\n");
                    for (Arc t = this.transList; t != null; t = t.next){    // trace its transitions
                        Trc.out.printf("    %s\n",t.toString());
                    }
                }
            }
        }

        /**
         * Build the pilot of this DFA starting from the specified state.
         *
         * @param      starts starting state
         */

        void buildPilotCeDfa(State starts){
            TRACE(E,"buildPilotCeDfa\n");

            // visit the initial state and the ones generated after it
            // to create all other states
            IntSetBit rea = new IntSetBit();
            for (State cur = starts; cur != null; cur = (State)cur.suc){
                TRACE(E,"processing state: %s %s\n",cur.number,cur.nfaStates);
                // collect the symbols that make transitions of this state
                long shifts = 0;
                // scan all its NFA states
                int[] ns = cur.nfaStates.toArray();
                for (int i = 0; i < ns.length; i++){
                    shifts |= nfa.table[ns[i]].cset;
                }
                TRACE(E,"  shifts: %s %s\n",csetToString(shifts),longBsToString(shifts));
                for (int n = 0; n < 64; n++){                    // for all the shifts
                    if ((shifts & 1L << n) == 0) continue;
                    TRACE(E,"  shift: %s\n",n);
                    // n is the number of the char subclass
                    // determine the nfa states reached
                    rea.clear();
                    Map<Integer,IntSetBit> orig = new TreeMap<Integer,IntSetBit>();
                    for (int j = 0; j < ns.length; j++){
                        int i = ns[j];
                        // take the states reached from nstate with class n
                        Nfa.State s = nfa.table[i];
                        boolean match = (s.cset & (1L << n)) != 0;
                        if (match){
                            TRACE(E,"    nfa state %s shift %s match %s delta %s\n",
                                s.number,n,match,s.delta);
                            // from s all the arcs have the same label
                            rea.add(s.delta);
                            if (cur.number == 0) continue;    // for the first the origins not needed
                            if (((CeState)cur).initial){
                                // do it on all the reached states in s.delta
                                int[] srea = s.delta.toArray();
                                for (int ri = 0; ri < srea.length; ri++){
                                    IntSetBit ori = orig.get(srea[ri]);
                                    if (ori == null){
                                        ori = new IntSetBit();
                                        orig.put(srea[ri],ori);
                                    }
                                    ori.add(s.number);
                                }
                            } else {          // not initial, hand on the origins
                                if (((CeState)cur).orig == null) continue;
                                int[] srea = s.delta.toArray();
                                for (int ri = 0; ri < srea.length; ri++){
                                    IntSetBit ori = orig.get(srea[ri]);
                                    TRACE(E,"    from %s next state %s orig %s parent %s\n",
                                        s.number,srea[ri],ori,((CeState)cur).orig.get(s.number));
                                    if (ori == null){
                                        orig.put(srea[ri],((CeState)cur).orig.get(s.number));
                                    } else {
                                        // if not null merge
                                        ori = (IntSetBit)ori.clone();
                                        ori.add(((CeState)cur).orig.get(s.number));
                                        orig.put(srea[ri],ori);
                                    }
                                }
                                TRACE(E,"    orig %s\n",orig);
                            }
                        }
                    }
                    TRACE(E,"    reached %s with shift: %s\n",rea,n);
                    // if there are no states, the current is final
                    if (rea.isEmpty()){
                        cur.accepting = true;
                        continue;
                    }
                    // there is at least one state reached with n
                    CeState nextstate = new CeState();
                    nextstate.nfaStates = (IntSetBit)rea.clone();
                    if (!orig.isEmpty()) nextstate.orig = orig;
                    addUnique(nextstate);
                    nextstate = (CeState)this.lastAdded;
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    add: ");
                        nextstate.trace();
                    }
                    TRACE(E,"   adding trans to %s subclass %s\n",nextstate.number,n);
                    cur.addArc(new Arc(n,nextstate));
                    #ifdef DEBUG
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    next state: ");
                        nextstate.trace();
                    }
                    #endif
                }
            }
            minimizeDfa(true);
            this.table = new State[this.stateNr];
            // build table of states
            for (State s = this.head; s != null; s = s.suc){
                this.table[s.number] = s;
            }

            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("buildPilotCeDfa dfa:\n");
                trace();
            }
            #endif
        }

        /**
         * Build this DFA.
         */

        void buildCeDfa(){
            TRACE(E,"buildCeDfa, nfa:\n");
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                nfa.trace();
            }
            #endif
            this.startStates = new int[2];
            // build the first state
            State state = new CeState();
            IntSetBit rea = transit(0,ReParallel.BOT);
            state.nfaStates = rea;
            addUnique(state);                       // add a state with these items
            // ok, no orig in the initial one
            ((CeState)state).initial = true;
            this.startStates[0] = this.lastAdded.number;
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("first ce-dfa state: ");
                state.trace();
            }
            #endif
            buildPilotCeDfa(state);                 // build the pilot
            // build a state containing all nfa states
            state = new CeState();
            rea = new IntSetBit();
            for (int i = 1; i < nfa.table.length; i++){   // 0 fake
                rea.add(i);
                state.nfaStates = rea;
            }
            addUnique(state);                       // add a state with these items
            ((CeState)state).initial = true;
            this.startStates[1] = this.lastAdded.number;
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("first ce-dfa state with all nfa: ");
                state.trace();
            }
            #endif
            buildPilotCeDfa(state);                 // build the pilot
            compactTables();                        // produce the compact tables
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("end build cd-dfa\n");
                trace();
            }
            #endif
        }

        /**
         * Compact the tables of this dfa using a simple, but fast compacter.
         */

        void compactTables(){
            TRACE(E,"compactTables\n");
            int nsym = symClassTable.length + 1;
            int[][] tabs = new int[this.stateNr][];    // tables before compression
            // build the tables taking into account that the transitions are
            // already ordered by increasing symbol (by construction)
            for (int i = 0; i < this.stateNr; i++){
                // compute the number of arcs
                State s = this.table[i];
                int nval = 0;
                for (Arc t = s.transList; t != null; t = t.next){
                    nval++;
                }
                tabs[i] = new int[nval*2 + 1];
                int k = 0;
                tabs[i][k++] = nsym;  // length
                // compute the pairs (subclass,next-state)
                for (Arc t = s.transList; t != null; t = t.next){
                    tabs[i][k++] = t.sclass;
                    tabs[i][k++] = t.nextState.number;
                }
                #ifdef DEBUG
                if ((FL_D & trc) != 0){
                    Trc.out.printf("tab row: %s len %s",i,tabs[i][0]);
                    for (int j = 1; j < tabs[i].length; j += 2){
                        Trc.out.printf(" %s %s",tabs[i][j],tabs[i][j+1]);
                    }
                    Trc.out.printf("\n");
                }
                #endif
            }
            // now we have a table with a row for each triple and a column for
            // each triple-set and cells that tell the index in triple starting where
            // the triple-nr,triple-set-nr occurs
            SimpleCombVector comb = new SimpleCombVector(-1,
                SimpleCombVector.HOLES_ACCESSED |
                SimpleCombVector.FOLD_ROWS |
                SimpleCombVector.PAIRS);
            if ((FL_D & trc) != 0){
                // comb.settrc("ab");
            }
            comb.merge(tabs);
            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                comb.statistics();
            }
            #endif
            this.trtable = comb.tabMerged;
            this.base = comb.base;
            this.check = comb.check;

            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                Trc.out.printf("compact tables\n");
                for (int i = 0; i < this.stateNr; i++){
                    State s = this.table[i];
                    Trc.out.printf("%s:",i);
                    String sep = " ";
                    for (int j = 0; j < nsym; j++){
                        int bas = this.base[i];
                        int start = bas+j;
                        int ele = this.check[start] == bas ? this.trtable[start] : -1;
                        if (ele >= 0){
                            Trc.out.printf("%s%s: %s",sep,j,ele);
                            sep = "; ";
                        }
                    }
                }
            }
            #endif
        }
    }

    /**
     * Compressed representation of sparse matrices. This is a simple implementation
     * of a class that actually compresses them.
     */

    private static class SimpleCombVector {
        /** Holes accessed mode. */
        static final int HOLES_ACCESSED = 1;

        /** Fold rows mode. */
        static final int FOLD_ROWS = 2;

        /** Input rows in (index,value) pairs format mode. */
        static final int PAIRS = 4;

        /** The comb-vector mode. */
        public int mode;

        /** The comb-vector merge table. */
        public int[] tabMerged;

        /** The comb-vector base table. */
        public int[] base;

        /** The comb-vector check table. */
        public int[] check;

        /** The value which is considered the hole. */
        public int holeValue;

        /** The size. */
        public long size;

        /**
         * Construct a new <codeCombVector></code> with the specified hole value and mode.
         *
         * @param      hole hole value
         * @param      mode mode
         */

        SimpleCombVector(int hole, int mode){
            this.holeValue = hole;
            this.mode = mode;
        }

        /**
         * Compress the specified matrix.
         *
         * @param      tabs matrix
         */

        void merge(int[][] tabs){
            int len = 0;
            for (int i = 0; i < tabs.length; i++){
                len += tabs[i][0];
            }
            this.base = new int[tabs.length];
            Arrays.fill(this.base,-1);
            this.check = new int[len];
            Arrays.fill(this.check,-1);
            this.tabMerged = new int[len];
            Arrays.fill(this.tabMerged,this.holeValue);
            int loc = 0;
            for (int i = 0; i < tabs.length; i++){
                this.base[i] = loc;
                for (int j = 1; j < tabs[i].length; j++){
                    int k = tabs[i][j++];                // index
                    this.tabMerged[k+loc] = tabs[i][j];  // value
                    this.check[k+loc] = loc;
                }
                loc += tabs[i][0];
                this.size += (tabs[i].length - 1) / 2;   // supposing max compression
            }            
        }
        void statistics(){
        }
    }

    /*
     * This is a DFA (SFA) that pre-computes the moves of the DFA as done starting from
     * each if its states. The SFA is build from an initial state that contains a map,
     * indexed with the states of the DFA, that contains themselves. Then, taken a symbol,
     * it computes the reached state for each row of the map, making up a new one, that
     * is recorded in a new SFA state.
     * SFA states are different if they have different maps.
     * Thus, each state represents all the moves that the recognizer would do processing a chunk
     * starting from every DFA state. The moves are recorded in the SFA states.
     */

    /**
     * SFA objects, see Ryoma Sin’ya paper.
     */

    class Sfa extends Dfa {

        /** The underlying dfa. */
        Dfa dfa;

        /**
         * A state.
         */

        class SState extends State {

            /** The map that makes dfa states correspond to the reached ones. */
            int[] map;

            /**
             * Compute the hash code.
             *
             * @return     hash code
             */

            public int hashCode(){
                int h = 0;
                for (int i = 0; i < this.map.length; i++){
                    h = (int)(h*31 + this.map[i]);
                }
                return h;
            }

            /**
             * Tell if this state is equal to the specified other one.
             *
             * @param      other other state
             * @return     <code>true</code> if equal, <code>false</code> otherwise
             */

            public boolean equals(Object other){
                if (this == other) return true;
                if (other == null) return false;
                return Arrays.equals(this.map,((SState)other).map);
            }

            /**
             * Trace this state.
             */

            void trace(){
                String status = "";
                if (this.accepting) status += " final";
                Trc.out.printf("state: %s%s\n",this.number,status);
                for (int i = 0; i < this.map.length; i++){
                    Trc.out.printf("    %s -> %s\n",i,this.map[i] < 0 ? "nil" : this.map[i]);
                }
                if (this.transList != null){
                    Trc.out.printf("  transitions\n");
                    for (Arc t = this.transList; t != null; t = t.next){    // trace its transitions
                        Trc.out.printf("    %s\n",t.toString());
                    }
                }
            }
        }

        /**
         * Build the pilot of this SFA starting from the specified state.
         *
         * @param      starts starting state
         * @param      dfa underlying dfa
         */

        void buildPilotSfa(State starts, Dfa dfa){
            TRACE(E,"buildPilotSfa\n");

            // visit the initial state and the ones generated after it
            // to create all other states
            for (State cur = starts; cur != null; cur = (State)cur.suc){
                TRACE(E,"processing state: %s\n",cur.number);
                #ifdef DEBUG
                if ((FL_E & trc) != 0){
                    cur.trace();
                }
                #endif
                for (int n = 0; n < symClassTable.length; n++){        // for all the shifts
                    TRACE(E,"  shift: %s %s\n",n,subclassToString(n));
                    // n is the number of the char subclass
                    SState nextstate = new SState();
                    nextstate.map = new int[dfa.stateNr];
                    boolean reaches = false;
                    for (int j = 0; j < ((SState)cur).map.length; j++){
                        // take an element of the map
                        int rea = -1;
                        int tostate = ((SState)cur).map[j];
                        TRACE(E,"    row: %s -> %s\n",j,((SState)cur).map[j]);
                        int st = tostate;
                        if (st < 0) continue;
                        TRACE(E,"        state %s\n",st);
                        int bas = dfa.base[st];
                        int startt = bas+n;
                        st = dfa.check[startt] == bas ? dfa.trtable[startt] : -1;
                        TRACE(E,"        next state %s\n",st);
                        if (st >= 0){
                            rea = st;
                            TRACE(E,"      state %s reaches %s\n",tostate,st);
                            if (dfa.table[st].accepting){
                                nextstate.accepting = true;
                            }
                            reaches = true;
                        }
                        ((SState)nextstate).map[j] = rea;
                    }
                    if (!reaches) continue;
                    TRACE(E,"    reached %s with shift: %s\n",nextstate,n);
                    #ifdef DEBUG
                    if ((FL_E & trc) != 0){
                        nextstate.trace();
                    }
                    #endif
                    addUnique(nextstate);
                    nextstate = (SState)this.lastAdded;
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    add: ");
                        nextstate.trace();
                    }
                    TRACE(E,"   adding trans to %s subclass %s\n",nextstate.number,n);
                    cur.addArc(new Arc(n,nextstate));
                    #ifdef DEBUG
                    if ((FL_E & trc) != 0){
                        Trc.out.printf("    next state: ");
                        nextstate.trace();
                    }
                    #endif
                }
            }
            minimizeDfa(true);
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("buildPilotSfa dfa:\n");
                trace();
            }
            #endif
        }

        /**
         * Build this SFA.
         */

        void buildSfa(){
            TRACE(E,"buildSfa, nfa:\n");
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                nfa.trace();
            }
            #endif
            this.dfa = new Dfa();
            this.dfa.build(false);                           // build the pilot for the DFA
            /*
            // the example in the paper
            State state0 = this.dfa.new State();
            IntSetBit rea = transit(0,ReParallel.BOT);
            state0.nfaStates = rea;
            this.dfa.addUnique(state0);                          // add a state with these items
            State state1 = this.dfa.new State();
            rea = new IntSetBit(3);
            state1.nfaStates = rea;
            this.dfa.addUnique(state1);                          // add a state with these items
            State state2 = this.dfa.new State();
            rea = new IntSetBit(4);
            state2.nfaStates = rea;
            this.dfa.addUnique(state2);                          // add a state with these items
            state0.addArc(new Arc(3,state1));
            state0.addArc(new Arc(4,state2));
            state1.addArc(new Arc(3,state2));
            state1.addArc(new Arc(4,state0));
            state2.addArc(new Arc(3,state2));
            state2.addArc(new Arc(4,state2));
            this.dfa.table = new State[this.dfa.stateNr];
            // build table of states
            for (State s = this.dfa.head; s != null; s = s.suc){
                this.dfa.table[s.number] = s;
            }
            this.dfa.compactTables();                        // produce the compact tables
            this.dfa.trace();
            Trc.out.printf("subclasses\n");
            for (int i = 0; i < symClassTable.length; i++){
                Trc.out.printf("    %s: %s %s\n",i,symClassTable[i],symSetToString(symClassTable[i]));
            }
            */

            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("dfa:\n");
                this.dfa.trace();
            }
            #endif

            SState sstate = new SState();
            sstate.map = new int[this.dfa.stateNr];
            for (int i = 0; i < this.dfa.stateNr; i++){
                sstate.map[i] = i;
            }
            addUnique(sstate);                          // add a state with these items

            buildPilotSfa(sstate,this.dfa);             // build the pilot for the SFA

            compactTables();                       // produce the compact tables
            #ifdef DEBUG
            if ((FL_E & trc) != 0){
                Trc.out.printf("end build sfa\n");
                trace();
            }
            #endif
        }

        /**
         * Compact the tables of this dfa using a simple, but fast compacter.
         */

        void compactTables(){
            TRACE(E,"compactTables\n");
            int nsym = symClassTable.length + 1;
            int[][] tabs = new int[this.stateNr][];    // tables before compression
            // build the tables taking into account that the transitions are
            // already ordered by increasing symbol (by construction)
            for (int i = 0; i < this.stateNr; i++){
                // compute the number of arcs
                State s = this.table[i];
                int nval = 0;
                for (Arc t = s.transList; t != null; t = t.next){
                    nval++;
                }
                tabs[i] = new int[nval*2 + 1];
                int k = 0;
                tabs[i][k++] = nsym;  // length
                // compute the pairs (subclass,next-state)
                for (Arc t = s.transList; t != null; t = t.next){
                    tabs[i][k++] = t.sclass;
                    tabs[i][k++] = t.nextState.number;
                }
                #ifdef DEBUG
                if ((FL_D & trc) != 0){
                    Trc.out.printf("tab row: %s len %s",i,tabs[i][0]);
                    for (int j = 1; j < tabs[i].length; j += 2){
                        Trc.out.printf(" %s %s",tabs[i][j],tabs[i][j+1]);
                    }
                    Trc.out.printf("\n");
                }
                #endif
            }
            // now we have a table with a row for each triple and a column for
            // each triple-set and cells that tell the index in triple starting where
            // the triple-nr,triple-set-nr occurs
            SimpleCombVector comb = new SimpleCombVector(-1,
                SimpleCombVector.HOLES_ACCESSED |
                SimpleCombVector.FOLD_ROWS |
                SimpleCombVector.PAIRS);
            if ((FL_D & trc) != 0){
                // comb.settrc("ab");
            }
            comb.merge(tabs);
            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                comb.statistics();
            }
            #endif
            this.trtable = comb.tabMerged;
            this.base = comb.base;
            this.check = comb.check;

            #ifdef DEBUG
            if ((FL_D & trc) != 0){
                Trc.out.printf("compact tables\n");
                for (int i = 0; i < this.stateNr; i++){
                    State s = this.table[i];
                    Trc.out.printf("%s:",i);
                    String sep = " ";
                    for (int j = 0; j < nsym; j++){
                        int bas = this.base[i];
                        int start = bas+j;
                        int ele = this.check[start] == bas ? this.trtable[start] : -1;
                        if (ele >= 0){
                            Trc.out.printf("%s%s: %s",sep,j,ele);
                            sep = "; ";
                        }
                    }
                }
            }
            #endif
        }
    }

    /**
     * Recognizes the text using the parallel algorithm and the sfa.
     *
     * @param      text text
     * @param      nrproc number of threads to use, 0: default 2, < 0 recognizion with -nrproc threads
     * @return     <code>true</code> if successful, <code>false</code> otherwise
     */

    boolean recParSfa(String text, int nrproc){
        TRACE(MPQ,"recParSfa %s nrproc %s\n",Str.strQuoted(text),nrproc);
        this.text = text;
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("recParSfa sfa\n");
            this.dfa.trace();
            Trc.out.printf("recParSfa dfa\n");
            ((Sfa)this.dfa).dfa.trace();
        }
        #endif
        boolean res = false;
        this.cursor = 0;
        if (nrproc == 0) nrproc = Runtime.getRuntime().availableProcessors();
        #ifdef LOAD_BALANCE
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,true);
        #else
        ThCh tc = nrThreads(this.text.length(),MIN_CHUNK_LEN,nrproc,testing,false);
        #endif
        final int P = tc.nt();                         // number of processors
        final int nrChunks = tc.nc();                  // number of chunks
        #ifdef MEASURE
        this.measure = new Measure(nrChunks);
        this.measure.nrChunks = nrChunks;
        this.measure.recognizionOnly = true;
        this.measure.timePar[0] = System.nanoTime();
        #endif
        this.nrChunks = nrChunks;
        this.recognizionOnly = true;
        if (this.text.length() == 0){                     // special case for the empty string
            if (this.nfa.gmy){
                return this.nfa.table[0].accepting;
            }
            IntSetBit init = transit(0,BOT);              // initial
            // build the set of accepting states reached from the initial one
            FOREACH_IS(init);
                if (this.nfa.table[nstate].accepting){
                    res = true;
                }
            ENDFOR_IS();
            return res;
        }
        TRACE(MPQ,"recParSfa ---- forward pass\n");
        #ifdef MEASURE
        this.measure.timePar[1] = System.nanoTime();
        #endif
        int chunk = this.text.length()/nrChunks;
        // determine the start of chunks
        this.startChunk = new int[nrChunks];
        TRACE(Q,"recParSfa nr chunks %s processors %s\n",nrChunks,P);
        for (int i = 0; i < nrChunks; i++){
            int start = i * chunk;
            if (i == 0){
                this.startChunk[0] = 0;
            } else {
                this.startChunk[i] = chunk * i;
            }
            TRACE(Q,"chunk %s start %s end %s\n",
                i,startChunk(i,nrChunks),endChunk(i,nrChunks));
        }

        // determine the start states of all the chunks
        int[] L = new int[nrChunks];                  // current states
        for (int i = 0; i < nrChunks; i++){
            L[i] = 0;
            #ifdef MEASURE
            this.measure.chunkStart[i] = 1;
            #endif
        }
        #ifdef DEBUG
        if ((FL_M & this.trc) != 0){
            Trc.out.printf("start states:\n");
            traceL(L);
        }
        #endif
        #ifdef MEASURE
        this.measure.timePar[2] = System.nanoTime();
        #endif

        if (nrproc == 1 && testing || simulate){
            // simulate parallel execution
            for (int i = 0; i < nrChunks; i++){
                if (!recParDfaFwd(i,nrChunks,L)){
                    TRACE(M,"recParSfa failed\n");
                    return false;
                }
            }
            #ifdef MEASURE
            if (simulate){
                this.measure.nrThreads = P;
            } else {
                this.measure.nrThreads = 1;
            }
            #endif
            this.nrThreads = 1;
        } else {
            // create thread counter
            #ifdef LOAD_BALANCE
            final Counter cnt = new Counter(nrChunks);
            Callable<Boolean> match = () -> {
                return recParDfaFwd(cnt,nrChunks,L);
            };
            #else
            final Counter cnt = new Counter();
            Callable<Boolean> match = () -> {
                return recParDfaFwd(cnt.get(),nrChunks,L,parses);
            };
            #endif
            boolean b = parallelExec(P,match);
            if (!b){
                TRACE(M,"recParSfa failed\n");
                return false;
            }
            #ifdef MEASURE
            this.measure.nrThreads = P;
            #endif
            this.nrThreads = P;
        }

        #ifdef MEASURE
        this.measure.timePar[3] = System.nanoTime();
        #endif

        #ifdef DEBUG
        if (((FL_M | FL_P) & this.trc) != 0){
            Trc.out.printf("reached states by chunk:\n");
            traceL(L);
        }
        #endif

        TRACE(MPQ,"recParSfa ---- sewing\n");

        // here we have array L: one vector, indexed with chunk number, telling the
        // state reached by the recognizion of the chunk.
        // Segments (chunks) are nonempty slices of the input string. Each segment is a slice
        // starting at start (included) and ending at end (excluded).
        // Its L element contains the state reached by transitions done with
        // the last character of the segment.

        res = true;
        Sfa.SState reached = (Sfa.SState)this.dfa.table[L[0]];
        int sfin = reached.map[0];
        TRACE(M,"recParSfa sew chunk 0 end state %s\n",sfin);
        for (int i = 1; i < nrChunks; i++){
            reached = (Sfa.SState)this.dfa.table[L[i]];
            if (sfin < 0) break;
            sfin = reached.map[sfin];
        }
        if (sfin < 0 || !((Sfa)this.dfa).dfa.table[sfin].accepting){
            TRACE(M,"recParSfa not final\n");
            return false;
        }

        #ifdef MEASURE
        this.measure.timePar[4] = System.nanoTime();
        #endif
        TRACE(M,"recParSfa recognize %s\n",res);
        return res;
    }
}