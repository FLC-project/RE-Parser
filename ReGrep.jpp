/*
 * @(#)ReGrep.jpp       1.0 2023/03/01
 *
 * Copyright (c) 2023 Angelo Borsotti. All Rights Reserved.
 * This computer program is protected under Copyright.
 */

package pbsp;
import java.util.*;
import lbj.*;
import lbj.Cli.*;
import pbsp.ReParallel.*;


/**
 * The <code>ReGrep</code> class provides an utility to make searchs on a file
 * using the RE parser.
 *
 * @author  Angelo Borsotti
 * @version 1.0   14 April 2023
 */

/*
 * Run, e.g.:  java -cp ..;..\.. pbsp.ReGrep re text "0/1"
 *
 *    re   a file containing the regular expression (it can contain newlines), default
 *         file-type: .re
 *    text a file containing the text to be parsed, default file-type: .txt
 *    
 * ReGrep parses the input finding all the occurrences of strings that match the RE,
 * and then prints their substrings that match the specified paths, for all the
 * paths of a same match.
 * Paths have the syntax:
 *
 *     path|path|...         list of paths
 *     path = nr/nr/nr ...   where nr is the number of the son (0...n,*) starting from the root
 *                           of the parse tree of the match. * denotes all sons
 *
 * It supports also tree paths, e.g.:
 *
       1(1(2,3),2(2,4)),...  nodes 1/1/2, 1/1/3, 1/2/2, 1/2/4
 */

public class ReGrep {

#define DEBUG;

    //---------------- Tracing ---------------------

    #define function TRACE(fl,frm,a){
        if (!this.DEBUG) return;
        if (fl[0] == "\'" || fl[0] == "\""){
            fl = fl.substring(1,fl.length-1).toUpperCase();
        }
        var fls = "";
        if (fl.length == 1){
            fls = "FL_" + fl;
        } else {
            for (var i = 0; i < fl.length; i++){
                if (fls.length > 0) fls += "|";
                fls += "FL_" + fl[i];
            }
            fls = "(" + fls + ")";
        }
        var str = "if ((" + fls + " & trc) != 0){" +
            "Trc.out.printf(" + frm;
        for (var i = 2; i < arguments.length; i++){
            str += "," + arguments[i];
        }
        str += ");}"
        return str;
    };

    /*
     * Internal constants for trace flags
     */

    /** The trace flags. */
    static int trc;

    /**
     * The following trace flags are used:
     * <p><blockquote><pre>
     *    a   main trace
     *    b   detailed trace
     *    g   ast and groups
     *    m   matches
     *    p   parser trace
     *    q   query
     *    z   errors
     */

    static final int FL_A = 1 << ('a'-0x60);
    static final int FL_B = 1 << ('b'-0x60);
    static final int FL_G = 1 << ('g'-0x60);
    static final int FL_M = 1 << ('m'-0x60);
    static final int FL_P = 1 << ('p'-0x60);
    static final int FL_Q = 1 << ('q'-0x60);
    static final int FL_Z = 1 << ('z'-0x60);
    
    /**
     * Set the trace flags which are specified in the argument.
     * The string must contain only lowercase letters.
     * Upon return <code>trc</code> is the powerset of flags augmented
     * with the ones specified.
     *
     * @param      s string of flags
     */

    public static void settrc(String s){
        trc = 0;
        for (int i = 0; i < s.length(); i++){
            trc |= 1 << (s.charAt(i) - 0x60);
        }
    }

    /** The application name. */
    private static final String TNAME = "REGREP";

    /** The version. */
    private static final String VERSION = "V1.0";

    /**
     * Analyse the command syntactically and semantically. Set the
     * trace flags.
     *
     * @param     flags trace flags 
     */

    private static void checkCommand(String flags){
        for (int i = 0; i < flags.length(); i++){
            int f = Character.toLowerCase(flags.charAt(i)) - 0x60;
            if ((f < 0) || (31 < f)){
                error('F',"trace flag",null);
            }
        }
        settrc(flags);
    }

    /**
     * Print an error message and terminate execution.
     *
     * @param      k kind of message
     * @param      msg message
     * @param      exc exception
     */

    private static void error(char k, String msg, Throwable exc){
        String prg = null;
        try {
            prg = TNAME;
        } catch (Throwable th){
        }
        if (prg == null){                  // intrinsic verb not defined
            prg = TNAME;
            if (prg == null) prg = "";
        }
        boolean stacktr = (FL_Z & trc) != 0;
        if (msg != null){
            Failure.printMessage(System.err,loc,prg,
               k,msg,null,exc,stacktr);
        } else {
            if (exc instanceof Failure){
                Failure ex = (Failure)exc;
                ex.print(System.err,loc,stacktr);
            } else {
                Failure.printMessage(System.err,null,prg,
                   'F',"UNEXP, Unexpected error",null,exc,stacktr);
            }
        }                
        System.exit(1);                    // exit with error
    }

    /** The locale. */
    private static Locale loc;

    /** The regular expression. */
    private static ReParallel re;
    
    /**
     * Main program.
     *
     * @param      args vector of the arguments
     */

    public static void main(String[] args){
        Locale.setDefault(Locale.US);
        loc = Locale.getDefault();
        doit: try {
            if (args.length == 4){
                checkCommand(args[3]);
            }
            #ifdef DEBUG
            if ((FL_A & trc) != 0){
                for (int i = 0; i < args.length; i++){
                    Trc.out.printf("|%s|\n",squeeze(args[i],20));
                }
            }
            #endif
            testQuery();
            re = new ReParallel();
            if (args.length < 3){
                error('F',"command error",null);
            }

            IoStream inp = new IoStream(".re");           // init re stream
            String inpname = args[0];
            inp.open(inpname,IoStream.CHARS);
            long inplength = inp.length();
            CharsRow cr = new CharsRow();
            inp.read(cr,(int)inplength);
            String rex = cr.toString();
            inp.close();

            rex = "(.|\\\n)*(" + rex + ")(.|\\\n)*";
            if (!re.compile(rex)){
                error('F',"compile error at:  " + re.cursor + "|" + rex + "|",null);
                return;
            }
            #ifdef DEBUG
            if ((FL_B & trc) != 0){
                re.trace();
            }
            if ((FL_G & trc) != 0){
                Trc.out.printf("---AST---\n");
                re.traceAst();
            }
            #endif
            TRACE(A,"--- re compiled --- %s\n",squeeze(rex,20));

            String tree = args[2];
            List<int[]> paths = null;
            QNode qroot = null;

            if (tree.indexOf('/') >= 0){
                String num = "([0-9]+|\\*)";
                String node = "(" + num + "(\\/" + num + ")*)";
                String nodes = node + "(\\|" + node + ")*";
                ReParallel trex = new ReParallel();
                if (!trex.compile(nodes)){
                    error('F',"trex compile error at:  " + re.cursor + "|" + rex + "|",null);
                    return;
                }
                if (!trex.matchSeq(tree)){
                    int end = re.cursor + 20;
                    if (end >= tree.length()) end = tree.length();
                    error('F',"tree argument error at:  " + trex.cursor + "|" +
                        tree.substring(trex.cursor,end) + "|",null);
                }

                //trex.traceTree();

                paths = new LinkedList<int[]>();
                List<Match> firstnode = trex.getMatches(null,2);
                firstnode.addAll(trex.getMatches(null,5));
                int[] path = new int[firstnode.size()];
                TRACE(A,"%s\n",firstnode);
                int n = 0;
                for (Match m : firstnode){
                    String s = tree.substring(m.start,m.end);
                    if (s.equals("*")){
                        TRACE(A,"all children\n");
                        path[n++] = -1;
                    } else {
                        TRACE(A,"%s -- %s\n",s,
                            Integer.valueOf(s));
                        path[n++] = Integer.valueOf(s);
                    }
                }
                paths.add(path);

                boolean first = true;
                List<Match> top = trex.getMatches(null,8);
                for (Match t : top){
                    List<Match> othernode = trex.getMatches(t,9);
                    othernode.addAll(trex.getMatches(t,12));
                    path = new int[othernode.size()];
                    n = 0;
                    for (Match m : othernode){
                        String s = tree.substring(m.start,m.end);
                        if (s.equals("*")){
                            TRACE(A,"all children\n");
                            path[n++] = -1;
                        } else {
                            TRACE(A,"%s\n",s);
                            path[n++] = Integer.valueOf(s);
                        }
                    }
                    paths.add(path);
                }
                #ifdef DEBUG
                if ((FL_A & trc) != 0){
                    for (int[] p : paths){
                        Trc.out.printf("path %s\n",Arrays.toString(p));
                    }
                }
                #endif
                TRACE(A,"--- paths parsed ---\n");
            } else {
                ReGrep rg = new ReGrep();
                qroot = rg.parseQuery(tree);
                if (qroot == null){
                    error('F',"tree argument error at:  " + rg.cursor + "|" +
                        tree.substring(rg.cursor) + "|",null);
                }
            }

            inp = new IoStream(".txt");           // init text stream
            inpname = args[1];
            inp.open(inpname,IoStream.CHARS);
            inplength = inp.length();
            cr = new CharsRow();
            inp.read(cr,(int)inplength);
            String text = cr.toString();
            inp.close();
            TRACE(A,"--- text read --- len %s |%s|\n",
                text.length(),squeeze(text,20));

            #ifdef DEBUG
            if ((FL_P & trc) != 0){
                re.settrc("m");
            }
            #endif
            if (!re.matchSeq(text)){
                int end = re.cursor + 20;
                if (end >= text.length()) end = text.length();
                error('F',"match failed at:  " + re.cursor + "|" +
                    squeeze(text.substring(re.cursor,end),20) + "|",null);
            }
            TRACE(A,"--- text matched ---\n");

            #ifdef DEBUG
            if ((FL_B & trc) != 0){
                re.traceTree();
            }
            #endif
            List<Match> matches = getTopMatches(re,text);
            loop: for (Match m : matches){
                TRACE(M,"top match %s: %s children %s\n",
                    m,squeeze(text.substring(m.start,m.end),20),re.getChildren(m).size());
                String str = "";
                if (paths != null){
                    for (int[] p : paths){                    // for all the path|path...
                        TRACE(M,"  path %s\n",Arrays.toString(p));
                        Match pm = m;
                        List<Match> list = new LinkedList<Match>();
                        getPathMatches(p,0,pm,list);
                        for (Match ma : list){
                            TRACE(M,"    string %s\n",squeeze(text.substring(ma.start,ma.end),20));
                            if (str.length() > 0) str += "\n";
                            str += text.substring(ma.start,ma.end);
                        }
                    }
                } else {
                    List<Match> list = new LinkedList<Match>();
                    getTreeMatches(qroot,0,m,list);
                    for (Match ma : list){
                        TRACE(M,"    string %s\n",squeeze(text.substring(ma.start,ma.end),20));
                        if (str.length() > 0) str += "\n";
                        str += text.substring(ma.start,ma.end);
                    }
                }
                System.out.printf("%s\n",str);
            }
        } catch (Throwable exc){
            //exc.printStackTrace(Trc.out);
            error('F',"",exc);
        }
    }

    private static boolean getPathMatches(int[] p, int lev, Match pm, List<Match> list){
        TRACE(M,"%sgetPathMatches path %s lev %s node %s list %s\n",indent(lev),
            Arrays.toString(p),lev,pm,list);
        if (lev >= p.length){
            TRACE(M,"%sgetPathMatches done list %s\n",indent(lev),list);
            list.add(pm);
            return true;
        }
        boolean res = true;
        List<Match> plist = re.getChildren(pm);
        int childnr = p[lev];
        TRACE(M,"%sgetPathMatches children %s child %s\n",
            indent(lev),plist,childnr);
        if (childnr >= 0){
            if (childnr >= plist.size()){
                return false;    // error
            }
            res = getPathMatches(p,lev+1,plist.get(childnr),list);
        } else {                                      // *
            for (int i = 0; i < plist.size(); i++){
                res = getPathMatches(p,lev+1,plist.get(i),list);
                if (!res) break;
            }
        }
        TRACE(M,"%sgetPathMatches return %s\n",indent(lev),res);
        return res;
    }

// deliver the longest top matches
    private static LinkedList<Match> getTopMatches(ReParallel re, String text){
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        List<Match> matches = re.getMatches(null,2);  // group 0: root, 1: .*, 2: RE
        // determine the longest matches
        for (Match m : matches){
            TRACE(M,"top match %s: %s children %s\n",
                m,squeeze(text.substring(m.start,m.end),20),re.getChildren(m).size());
            Integer end = map.get(m.start);
            if (end == null){     // not found
                map.put(m.start,m.end);
            } else {
                if (m.end > end){
                    map.put(m.start,m.end);
                }
            }
        }
        // take only the longest matches
        LinkedList<Match> res = new LinkedList<Match>();
        for (Match m : matches){
            Integer end = map.get(m.start);
            if (m.end == end){
                res.add(m);
            }
        }
        TRACE(M,"getTopMatches res %s\n",res);
        return res;
    }

// for each top match walk the query tree and deliver the leaf matches

    private static boolean getTreeMatches(QNode qn, int lev, Match pm, List<Match> list){
        TRACE(M,"%sgetTreeMatches query %s lev %s node %s list %s\n",indent(lev),
            qn.toTree(),lev,pm,list);
        boolean res = true;
        List<Match> children = re.getChildren(pm);
        String bros = "";
        for (QNode a = qn; a != null; a = a.bro){
            if (a.child < 0){
                bros += " *";
            } else {
                bros += " " + a.child;
            }
        }
        String childs = "";
        for (int i = 0; i < children.size(); i++){
            childs += " " + i + ":" + children.get(i);
        }
        TRACE(M,"%sgetTreeMatches children %s brothers %s\n",indent(lev),childs,bros);

        if (children == null) return false;
// first time called with a top match and qroot, that is a brothers list
// each element in the list has a child node, meaning that such a child is the match
// to take if it is a leaf, otherwise to use to go down
        for (QNode a = qn; a != null; a = a.bro){
            if (a.son != null){
                if (a.child < 0){
                    for (int i = 0; i < children.size(); i++){
                        res = getTreeMatches(a.son,lev+1,children.get(i),list);
                        if (!res) break;
                    }
                } else {
                    getTreeMatches(a.son,lev+1,children.get(a.child),list);
                }
            } else {
                if (a.child < 0){
                    for (int i = 0; i < children.size(); i++){
                        list.add(children.get(i));
                    }
                } else {
                    if (a.child < children.size()){
                        list.add(children.get(a.child));
                        TRACE(M,"%sgetTreeMatches child %s leaf list %s\n",
                            indent(lev),a.child,list);
                    } else {
                        TRACE(M,"%sgetTreeMatches invalid child %s children %s\n",
                            indent(lev),a.child,children.size());
                        res = false;
                        break;
                    }
                }
            }
        }
        TRACE(M,"%sgetTreeMatches return %s\n",indent(lev),res);
        return res;
    }
    
    static String squeeze(String s, int n){
        String lit = Trc.strLit(s);
        int len = lit.length();
        if (len <= n) return lit;
        if (len < 9) return lit;
        int len1 = (n-3)/2;
        int len2 = n-len1-3;
        return lit.substring(0,len1) + "..." + lit.substring(len-len2);
    }

    /**
     * Deliver a string containing as many blanks as the specified level times 2.
     *
     * @param      lev level of indentation
     * @return     string
     */

    static String indent(int lev){
        String res = "";
        for (int i = 0; i < lev; i++){
            res += "  ";
        }
        return res;
    }


    /** A Query node, representing a subexpression. */

    class QNode {

        /** The serial number. */
        int seq;

        /** The reference to the brother. */
        QNode bro;

        /** The reference to the son. */
        QNode son;

        /** The reference to the father. */
        QNode fat;

        /** The number of the child. */
        int child;

        /** The index in the query string. */
        int cursor;

        /**
         * Deliver a string representing this node.
         *
         * @return     String
         */

        public String toString(){
            String str = "seq: " + this.seq;
            str += " " + this.child;
            if (this.bro != null){
                str += " bro: ";
                str += this.bro.seq;
            }
            if (this.son != null){
                str += " son: ";
                str += this.son.seq;
            }
            if (this.fat != null){
                str += " fat: ";
                str += this.fat.seq;
            }
            return str;
        }

        /**
         * Deliver a string representing the tree of this node.
         *
         * @return     String
         */

        public String toTree(){
            StringBuilder sb = new StringBuilder();
            toTree(sb,this);
            return sb.toString();
        }
        public void toTree(StringBuilder sb, QNode qn){
            for (QNode a = qn; a != null; a = a.bro){
                if (a != qn) sb.append(",");
                if (a.child < 0){
                    sb.append('*');
                } else {
                    sb.append(a.child);
                }
                if (a.son != null){
                    sb.append("(");
                    toTree(sb,a.son);
                    sb.append(")");
                }
            }
        }

        /**
         * Append the specified son as a son of this node.
         *
         * @param      son son
         */
         
        QNode addSon(QNode son){
            son.fat = this;
            if (this.son == null){
                this.son = son;
            } else {
                // find last brother and append the new one to it
                QNode prev = null;
                for (QNode t = this.son; t != null; t = t.bro){
                    prev = t;
                }
                prev.bro = son;
            }
            return son;
        }

        /**
         * Append the specified node as a brother of this node.
         *
         * @param      node node
         */
         
        QNode addBro(QNode node){
            // find last brother and append the new one to it
            QNode prev = null;
            for (QNode t = this; t != null; t = t.bro){
                prev = t;
            }
            prev.bro = node;
            return node;
        }
    }

    /**
     * Deliver a new query node with the specified child.
     *
     * @param      child child
     * @return     reference to the node
     */

    private QNode newQNode(int child){
        QNode node = new QNode();
        node.child = child;
        node.cursor = this.startToken;
        node.seq = this.seq++;
        TRACE(Q,"newQNode %s %s\n",node.seq,child);
        return node;
    }

    /**
     * Parse the specified query string and delivers a node that represents it.
     *
     * @param      q query string
     * @return     node
     */

    private QNode parseQuery(String q){
        this.query = q;
        this.seq = 0;
        this.error = false;
        this.cursor = 0;
        this.startToken = 0;
        QNode n = expression();
        if (n == null || this.error || this.getsym() != -1){    // error or whole query not consumed
            n = null;
        }
        TRACE(Q,"parseQuery expression end %s\n",n == null? "" : n.toTree());
        return n;
    }

    int cursor;
    int seq;
    String query;
    boolean error;

    /** The index of the start of a token in the query (as a string). */
    private int startToken;

    /*
     *   q ::= num [(q)] | q,q    num can also be * = all
     */
    
    /**
     * Parse an expression. It returns a Qnode that can have brothers.
     *
     * @return   node
     */

    private QNode expression(){
        TRACE(Q,"expression start at: %s query %s\n",this.cursor,this.query);
        QNode root = null;
        QNode curnode = null;
        doit: for (;;){
            int symv = getsym();
            char sym = (char)symv;
            if (symv < 0){
                this.error = true;
                return null;
            }
            int n = 0;
            if (sym == '*'){
                n = -1;
            } else {
                this.cursor--;
                n = getint();
                if (n < 0){
                    this.error = true;
                    return null;
                }
            }
            QNode node = newQNode(n);
            if (curnode == null){
                root = node;
            } else {
                // add brother
                curnode.addBro(node);
                TRACE(Q,"expression bro %s curnode %s\n",node.toTree(),curnode.toTree());
            }
            curnode = node;

            symv = getsym();
            sym = (char)symv;
            if (symv < 0) break;
            if (sym == '('){
                node = expression();
                curnode.addSon(node);
                TRACE(Q,"expression son %s curnode %s\n",node.toTree(),curnode.toTree());
                symv = getsym();
                sym = (char)symv;
                if (symv < 0 || sym != ')'){
                    this.error = true;
                    return null;
                }
                symv = getsym();
            }
            sym = (char)symv;
            if (symv < 0){
                break;
            }
            if (sym != ','){
                this.cursor--;
                break;
            }
        }
        TRACE(Q,"expression end at: %s %s query %s\n",
            this.cursor,root,root == null ? "" : root.toTree());
        return root;
    }

    /**
     * Skip whitespaces.
     *
     * @return     character, or -1 if no more available
     */

    private void gsep(){
        for (; this.cursor < this.query.length(); this.cursor++){
             if (this.query.charAt(this.cursor) != ' ') break;
        }
        this.startToken = this.cursor;
    }

    /**
     * Get an integer >= 0.
     *
     * @return     value, -1 if not present
     */

    private int getint(){
        TRACE(Q,"getint start at: %d\n",this.cursor);
        int res = 0;
        boolean found = false;
        for (;;){
            int cur = this.cursor;
            int symv = getsym();
            if (symv < 0) break;               // end of data
            if (this.cursor-cur > 1){          // number ended by spaces
                this.cursor--;
                break;
            }
            char c = (char)symv;
            if ((c < '0') || ('9' < c)){
                this.cursor--;
                break;
            }
            res *= 10;
            if (res > 0){
                found = false;
                break;
            }
            int digit = (int)c - '0';
            res -= digit;                     // use negative accumulators, ..
            if (res > 0){                     // .. which is larger than a ..
                found = false;                // .. positive one
                break;
            }
            found = true;
        }
        if (found){
            res = -res;
            if (res < 0){
                found = false;
            }
        }
        if (!found) res = -1;
        TRACE(Q,"getint res: %s cursor %s\n",res,this.cursor);
        return res;
    }

    /**
     * Get the next character from the RE skipping blanks.
     *
     * @return     character, or -1 if no more available
     */

    private int getsym(){
        TRACE(Q,"getsym cursor: %s query %s\n",this.cursor,this.query);
        int res;
        for (; this.cursor < this.query.length(); this.cursor++){
             if (this.query.charAt(this.cursor) != ' ') break;
        }
        if (this.cursor >= this.query.length()){   // eof
            res = -1;
        } else {
            res = this.query.charAt(this.cursor++);
        }
        TRACE(Q,"getsym ret cursor: %s query %s res %s %s\n",this.cursor,this.query,res,(char)res);
        return res;
    }

    /**
     * Get the next character from the query.
     *
     * @return     character, or -1 if no more available
     */

    private int getchar(){
        TRACE(Q,"getchar cursor: %s query %s\n",this.cursor,this.query);
        int res;
        if (this.cursor >= this.query.length()){   // eof
            res = -1;
        } else {
            res = this.query.charAt(this.cursor++);
        }
        TRACE(Q,"getchar ret cursor: %s query %s res %s %s\n",this.cursor,this.query,res,(char)res);
        return res;
    }

    /** The name of the feature under testing. */
    private static String featureName;

    /** The flag to enable the trace of the tests. */
    private static boolean ckshow = false;

    /** The number of tests failed. */
    private static int testErrors;

    /** The number of the test. */
    static int testId;

    /**
     * Start the testing of a feature. Record its name and trace it
     * if the tracing of tests is enabled.
     *
     * @param      s feature name
     */

    private static void feature(String s){
        featureName = s;
        if (ckshow) Trc.out.printf("%s\n",featureName);
    }

    /**
     * Trace a test of a feature.
     *
     * @param      t number of the test
     */

    private static void showTest(int t){
        testId = t;
        if (ckshow) Trc.out.printf("-- test %s %s ---\n",featureName,t);
    }

    /**
     * Report the failure of a test.
     *
     * @param      t number of the test
     */

    private static void trcfail(int t){
        Trc.out.printf("\n");
        Trc.out.printf("-- test %s %s failed---\n",featureName,t);
        testErrors++;
    }

    /**
     * Trace the specified message followed by the expected value and the actual one.
     *
     * @param      str message
     * @param      e expected value
     * @param      a actual value
     * @return     string
     */

    private static void trc(String s, String e, String a){
        Trc.out.printf("%s expected: |%s| actual: |%s|\n",s,e,a);
    }

    /**
     * Deliver the specified string with spaces removed.
     *
     * @param      str string
     * @return     string
     */

    private static String removeSpaces(String str){
        String s = "";
        for (int i = 0; i < str.length(); i++){
            if (str.charAt(i) == ' ') continue;
            s += str.charAt(i);
        }
        return s;
    }

    /** The ReGrep. */
    private static ReGrep rg;

    /**
     * Test that the tree built from the specified query generates the expected tree.
     *
     * @param      t number of the test case
     * @param      str query
     * @param      exp expected tree
     */

    private static void testTree(int t, String str, String exp){
        showTest(t);
        QNode n = rg.parseQuery(str);
        String actual = "";
        if (n == null){
            actual = "error";
        } else {
            actual = n.toTree();
        }
        if (!removeSpaces(actual).equals(removeSpaces(exp))){
            trcfail(t);
            trc("tree",exp,actual);
        }
    }

    /**
     * Test that the specified query on the specified text and RE generates the expected result.
     *
     * @param      t number of the test case
     * @param      res re
     * @param      text text
     * @param      str query
     * @param      exp expected result
     */

    private static void testQuery(int t, String res, String text, String str, String exp){
        showTest(t);
//int savetrc = trc;
//trc = rg.trc;
        String rex = "(.|\\\n)*(" + res + ")(.|\\\n)*";
        if (!re.compile(rex)){
            trcfail(t+1000);
            return;
        }
        if (!re.matchSeq(text)){
            trcfail(t+1001);
            System.out.printf("re %s\n",Trc.strLit(rex));
            return;
        }
        if ((FL_P & trc) != 0){
            re.traceTree();
        }
        QNode qroot = rg.parseQuery(str);
        TRACE(M,"testQuery re %s text %s root %s\n",
            Trc.strLit(rex),squeeze(text,20),qroot.toTree());
        if (qroot == null){
            trcfail(t+1002);
            return;
        }
        List<Match> matches = getTopMatches(re,text);
        TRACE(M,"testQuery matches %s\n",matches);
        String resu = "";
        loop: for (Match m : matches){
            List<Match> list = new LinkedList<Match>();
            getTreeMatches(qroot,0,m,list);
            for (Match ma : list){
                if (resu.length() > 0) resu += "\n";
                resu += text.substring(ma.start,ma.end);
            }
        }
        String actual = resu;
        if (!actual.equals(exp)){
            trcfail(t);
            trc("query",exp,actual);
        }
//trc = savetrc;
    }

    static void testQuery(){
        rg = new ReGrep();
        // ckshow = true;
        // query
        feature("query tree");
        testTree(0,"","error");
        testTree(1,"1","1");
        testTree(2,"1,2","1,2");
        testTree(3,"1(2)","1(2)");
        testTree(4,"1(2),3","1(2),3");
        testTree(5,"1(2),3(4)","1(2),3(4)");
        testTree(6,"1(2,3)","1(2,3)");
        testTree(7,"1(2,3),4(5,6),7,8(9)","1(2,3),4(5,6),7,8(9)");
        testTree(8,"*","*");
        testTree(9,"1(2(3))","1(2(3))");
        testTree(10,"1(2(3),4)","1(2(3),4)");
        testTree(11,"1(2(3),4(5))","1(2(3),4(5))");

        feature("query");
        re = new ReParallel();
        testQuery(0,"abc","xxabcxx","0","abc");
        testQuery(1,"abc","xxabcxxabc","0","abc\nabc");
        testQuery(2,"a(bc)","xxabcxxabc","0","abc\nabc");
        testQuery(3,"a(bc)","xxabcxxabc","0(1)","bc\nbc");
        testQuery(4,"a(bc)","xxabcxxabc","0(0)","a\na");
//rg.settrc("m");
//rg.settrc("q");
//System.exit(1);
    }
}
